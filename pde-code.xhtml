<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="GENERATOR" content="LyX 2.0.3" />
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Finite element code: PDE</title>

<!-- Text Class Preamble -->
<style type="text/css">
div.toc {
margin: 2em 0em;
border-style: solid;
border-width: 2px 0px;
padding: 1em 0em;
}
div.tochead { font-size: x-large; font-weight: bold; }
div.lyxtoc-0 {
margin: 2em 0em 0em 0em;
font-size: xx-large;
font-weight: bold;
}
div.lyxtoc-1 {
margin: 1em 0em 0em 0em;
font-size: x-large;
font-weight: bold;
}
div.lyxtoc-2 {
margin: 0em 0em 0em 1em;
font-size: large;
font-weight: normal;
}
div.lyxtoc-3 { margin: 0em 0em 0em 0.5em; font-size: medium; }
div.lyxtoc-4 { margin: 0em 0em 0em 0.5em; }
div.lyxtoc-5 { margin: 0em 0em 0em 0.5em; }
div.lyxtoc-6 { margin: 0em 0em 0em 0.5em; }
a.tocentry {
text-decoration: none;
color: black;
}
a.tocentry:visited { color: black; }
a.tocarrow {
font-weight: bold;
text-decoration: none;
color: #909090;
}
a.tocarrow:visited { color: #C0C0C0; }
</style>

<!-- Preamble Snippets -->
<style type="text/css">
mstyle.mathbox { font-style: normal; }
</style>
<style type="text/css">
div.bibtexentry { margin-left: 2em; text-indent: -2em; }
span.bibtexlabel:before{ content: "["; }
span.bibtexlabel:after{ content: "] "; }
</style>

<!-- Layout-provided Styles -->
<style type='text/css'>
h1.title {
font-size: x-large;
margin-bottom: 1ex;
text-align: center;

}
div.author {
font-size: large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: center;

}
div.date {
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: center;

}
div.standard {
margin-bottom: 2ex;
}
h2.section {
font-weight: bold;
font-size: x-large;
margin-top: 1.3ex;
margin-bottom: 0.7ex;
text-align: left;

}
h3.subsection {
font-weight: bold;
font-size: large;
margin-top: 0.9ex;
margin-bottom: 0.5ex;
text-align: left;

}
div.scrap {
font-family: monospace;
margin-left: 3ex;
text-align: left;

}
span.scrap_label {


}
div.plain_layout {
text-align: left;

}
div.lyx_code {
font-family: monospace;
margin-top: 0.5ex;
margin-bottom: 0.5ex;
margin-left: 3ex;
margin-right: 3ex;
text-align: left;

}
h4.subsubsection {
font-weight: bold;
font-size: medium;
margin-top: 0.7ex;
margin-bottom: 0.4ex;
text-align: left;

}
span.flex_url {
font-family: monospace;
}
div.float {
border: 2px solid black;
text-align: center;
}
div.float-caption {
text-align: center;
border: 2px solid black;
padding: 1ex;
margin: 1ex;
}
 div.note_comment {
   display: none;
 }
</style>
</head>
<body>
<h1 class="title"><a id='magicparlabel-336999' />
Finite element code: PDE</h1>
<div class="author"><a id='magicparlabel-337000' />
David E. Stewart</div>
<div class="date"><a id='magicparlabel-337001' />
July 9th, 2012</div>
<div class="standard"><a id='magicparlabel-337002' />
</div>
<div class='toc'><div class='tochead part'>Table of Contents</div>

<div class='lyxtoc-1'><a href='#magicparlabel-337003' class='tocentry'>1 Overview</a> <a href='#magicparlabel-337003' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-337009' class='tocentry'>1.1 Basic organization</a> <a href='#magicparlabel-337009' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-337015' class='tocentry'>1.2 PDE representation</a> <a href='#magicparlabel-337015' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-337023' class='tocentry'>1.3 Usage</a> <a href='#magicparlabel-337023' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-337024' class='tocentry'>2 Matrix assembly code</a> <a href='#magicparlabel-337024' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-337107' class='tocentry'>2.1 Petrov&ndash;Galerkin method</a> <a href='#magicparlabel-337107' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-337198' class='tocentry'>2.2 Mesh-based functions and nonlinear problems</a> <a href='#magicparlabel-337198' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-337282' class='tocentry'>2.3 Boundary assembly</a> <a href='#magicparlabel-337282' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-337366' class='tocentry'>3 Handling geometric features</a> <a href='#magicparlabel-337366' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-337371' class='tocentry'>3.1 Feature hash tables</a> <a href='#magicparlabel-337371' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-337507' class='tocentry'>3.2 Geometric utilities</a> <a href='#magicparlabel-337507' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-337508' class='tocentry'>3.2.1 Find boundary</a> <a href='#magicparlabel-337508' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337536' class='tocentry'>3.2.2 Matching edges to triangles</a> <a href='#magicparlabel-337536' class='tocarrow'>&gt;</a></div>
</div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-337555' class='tocentry'>4 Element types</a> <a href='#magicparlabel-337555' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-337557' class='tocentry'>4.1 Piecewise linear elements</a> <a href='#magicparlabel-337557' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-337573' class='tocentry'>4.1.1 Piecewise linear elements: get_Aphihat()</a> <a href='#magicparlabel-337573' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337615' class='tocentry'>4.1.2 Piecewise linear elements: get_nvars()</a> <a href='#magicparlabel-337615' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337630' class='tocentry'>4.1.3 Piecewise linear elements: pxfeature()</a> <a href='#magicparlabel-337630' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337650' class='tocentry'>4.1.4 Piecewise linear elements: vnodes()</a> <a href='#magicparlabel-337650' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-337664' class='tocentry'>4.2 Transformation routines: scalar Lagrange elements</a> <a href='#magicparlabel-337664' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-337695' class='tocentry'>4.3 Piecewise quadratic elements</a> <a href='#magicparlabel-337695' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-337723' class='tocentry'>4.3.1 Piecewise quadratic elements: get_Aphihat()</a> <a href='#magicparlabel-337723' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337771' class='tocentry'>4.3.2 Piecewise quadratic elements: get_nvars()</a> <a href='#magicparlabel-337771' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337789' class='tocentry'>4.3.3 Piecewise quadratic elements: pxfeature()</a> <a href='#magicparlabel-337789' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337810' class='tocentry'>4.3.4 Piecewise quadratic elements: vnodes()</a> <a href='#magicparlabel-337810' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-337827' class='tocentry'>4.4 Piecewise cubic elements</a> <a href='#magicparlabel-337827' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-337843' class='tocentry'>4.4.1 Piecewise cubic elements: get_Aphihat</a> <a href='#magicparlabel-337843' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337901' class='tocentry'>4.4.2 Piecewise cubic elements: get_nvars()</a> <a href='#magicparlabel-337901' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337920' class='tocentry'>4.4.3 Piecewise cubic elements: pxfeature()</a> <a href='#magicparlabel-337920' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-337943' class='tocentry'>4.4.4 Piecewise cubic elements: vnodes()</a> <a href='#magicparlabel-337943' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-337963' class='tocentry'>4.5 Piecewise constant elements</a> <a href='#magicparlabel-337963' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-338017' class='tocentry'>4.6 Vector elements</a> <a href='#magicparlabel-338017' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-338045' class='tocentry'>4.6.1 Vector elements: pxfeature()</a> <a href='#magicparlabel-338045' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-338060' class='tocentry'>4.6.2 Vector elements: trans_Aphilist()</a> <a href='#magicparlabel-338060' class='tocarrow'>&gt;</a></div>
</div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-338081' class='tocentry'>5 Numerical integration</a> <a href='#magicparlabel-338081' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-338083' class='tocentry'>5.1 Two-dimensional integration methods</a> <a href='#magicparlabel-338083' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-338084' class='tocentry'>5.1.1 Radon's method</a> <a href='#magicparlabel-338084' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-338115' class='tocentry'>5.1.2 Gatermann's method</a> <a href='#magicparlabel-338115' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-338156' class='tocentry'>5.1.3 A method of Dunavant</a> <a href='#magicparlabel-338156' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-338213' class='tocentry'>5.2 One-dimensional integration methods</a> <a href='#magicparlabel-338213' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-338214' class='tocentry'>5.2.1 Gauss&ndash;Legendre quadrature</a> <a href='#magicparlabel-338214' class='tocarrow'>&gt;</a></div>
</div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-338229' class='tocentry'>6 Output and visualization</a> <a href='#magicparlabel-338229' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-338230' class='tocentry'>6.1 Visualization</a> <a href='#magicparlabel-338230' class='tocarrow'>&gt;</a>

<div class='lyxtoc-3'><a href='#magicparlabel-338235' class='tocentry'>6.1.1 Visualizing solutions (and mesh functions)</a> <a href='#magicparlabel-338235' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-3'><a href='#magicparlabel-338259' class='tocentry'>6.1.2 Boundary visualization</a> <a href='#magicparlabel-338259' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-2'><a href='#magicparlabel-338306' class='tocentry'>6.2 Refined output</a> <a href='#magicparlabel-338306' class='tocarrow'>&gt;</a></div>
</div>

<div class='lyxtoc-1'><a href='#magicparlabel-338345' class='tocentry'>7 Makefiles and using Noweb</a> <a href='#magicparlabel-338345' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-1'><a href='#magicparlabel-338367' class='tocentry'>8 Test code</a> <a href='#magicparlabel-338367' class='tocarrow'>&gt;</a>

<div class='lyxtoc-2'><a href='#magicparlabel-345902' class='tocentry'>8.1 Checking consistency of element values and derivatives</a> <a href='#magicparlabel-345902' class='tocarrow'>&gt;</a></div>

<div class='lyxtoc-2'><a href='#magicparlabel-345910' class='tocentry'>8.2 Testing overall system</a> <a href='#magicparlabel-345910' class='tocarrow'>&gt;</a></div>
</div>
</div>

<h2 class="section"><span class="section_label">1</span> <a id='magicparlabel-337003' />
<a id="sec_Overview" />
Overview</h2>
<div class="standard"><a id='magicparlabel-337004' />
This describes a pure Matlab finite element code for two dimensional problems. It is assumed that a triangulation of the domain is given in the same format as the output from the Persson &amp; Strang Matlab triangulation code. That is, the basic triangulation data is given in the form of a pair <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mi>p</mi><mo>,</mo><mi>t</mi>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>p</mi>
 </mrow></math> is an array of points: point <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>p</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> is p(i,:), while triangle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> is the triangle with vertices p(j,:), p(k,:), p(l,:) where j = t(i,1), k = t(i,2) and l = t(i,3). This can be generalized to tetrahedra in three dimensions, etc. This also works well with the Matlab trimesh() function for plotting two-dimensional meshes.</div>

<div class="standard"><a id='magicparlabel-337005' />
There are a number of different element types, most notably Lagrange elements which represent scalar piecewise polynomials (that is, the restriction of the basis functions to each triangle is a polynomial). The simplest of these is the Lagrange piecewise linear element, but quadratic and cubic Lagrangian elements have also been implemented. Extensions to <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>C</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msup>
 </mrow></math> elements (such as Bell's triangle and the Argyris element) are also planned, but not yet implemented. Code for the elements can be found in Section&nbsp;<a href="#sec_Element_types">4</a>.</div>

<div class="standard"><a id='magicparlabel-337006' />
Since the values at certain points are shared by elements on different (but touching) triangles, we need a way to determine when these values are shared. This is done via a geometric feature hash table. Code for these aspects can be found in Section&nbsp;<a href="#sec_Handling_geometric_features">3</a>.</div>

<div class="standard"><a id='magicparlabel-337007' />
The core routines are the assembly routines which form the matrices and vectors for the linear systems to be solved. These are for both the Galerkin and Petrov&ndash;Galerkin methods. Similar routines are provided for handling boundary values and conditions. Code for matrix assembly can be found in Section&nbsp;<a href="#sec_Matrix_assembly_code">2</a>. Part of this process is the task of numerical integration. Integration rules can be found in Section&nbsp;<a href="#sec_Numerical_integration">5</a>.</div>

<div class="standard"><a id='magicparlabel-337008' />
Testing codes can be found in Section&nbsp;<a href="#sec_Test_code">8</a>.</div>
<h3 class="subsection"><span class="subsection_label">1.1</span> <a id='magicparlabel-337009' />
<a id="sub_Basic_organization" />
Basic organization</h3>
<div class="standard"><a id='magicparlabel-337010' />
Each element type must be able to compute the values of the basis functions at each point of the reference triangle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mover>
    <mrow><mi>K</mi>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo>=</mo>
   <mstyle class='mathbox'>
    <mrow>co
    </mrow>
   </mstyle><mo form='prefix' fence='true' stretchy='true' symmetric='true'>{</mo>
   <mrow><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mrow><mn>0</mn><mo>,</mo><mn>0</mn>
    </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>,</mo><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mrow><mn>1</mn><mo>,</mo><mn>0</mn>
    </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>,</mo><mspace width="6px" /><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mrow><mn>0</mn><mo>,</mo><mn>1</mn>
    </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>}</mo>
  </mrow>
 </mrow></math>, along with the values of a number of <em>operators</em> applied to the basis functions. That is, for a point <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo> &isin; </mo>
   <mover>
    <mrow><mi>K</mi>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover>
  </mrow>
 </mrow></math> and basis function <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mover>
     <mrow><mi> &phi; </mi>
     </mrow><mo stretchy="true">&Hat;</mo>
    </mover>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> on <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mover>
   <mrow><mi>K</mi>
   </mrow><mo stretchy="true">&Hat;</mo>
  </mover>
 </mrow></math> we need to be able to compute not only <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, but also <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>=</mo><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>=</mo><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>; sometimes higher order derivatives are also necessary, such as for 4th order PDEs. In that case, each element can also compute <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>=</mo>
   <msup>
    <mrow><mi> &part; </mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mo>/</mo><mi> &part; </mi>
   <msubsup>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msubsup>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>=</mo>
   <msup>
    <mrow><mi> &part; </mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mspace width="6px" /><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>=</mo>
   <msup>
    <mrow><mi> &part; </mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mo>/</mo><mi> &part; </mi>
   <msubsup>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msubsup>
  </mrow>
 </mrow></math>. The ordering of these operators is essentially fixed across the different element types.</div>

<div class="standard"><a id='magicparlabel-337011' />
There are also elements for providing vector-valued basis functions, in which case we also need to use different operators: <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo> &sdot; </mo>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo> &sdot; </mo>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mi> &part; </mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo> &sdot; </mo>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, etc. </div>

<div class="standard"><a id='magicparlabel-337012' />
Basis functions on the reference element <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mover>
   <mrow><mi>K</mi>
   </mrow><mo stretchy="true">&Hat;</mo>
  </mover>
 </mrow></math> are used to create basis functions on the actual elements <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>K</mi><mo>=</mo>
   <mstyle class='mathbox'>
    <mrow>co
    </mrow>
   </mstyle><mo form='prefix' fence='true' stretchy='true' symmetric='true'>{</mo>
   <mrow><mspace width="6px" />
    <msub>
     <mrow>
      <mstyle mathvariant='bold'><mi>p</mi>
      </mstyle>
     </mrow>
     <mrow><mi>j</mi>
     </mrow>
    </msub><mo>,</mo><mspace width="6px" />
    <msub>
     <mrow>
      <mstyle mathvariant='bold'><mi>p</mi>
      </mstyle>
     </mrow>
     <mrow><mi>k</mi>
     </mrow>
    </msub><mo>,</mo><mspace width="6px" />
    <msub>
     <mrow>
      <mstyle mathvariant='bold'><mi>p</mi>
      </mstyle>
     </mrow>
     <mrow><mi> &ell; </mi>
     </mrow>
    </msub><mspace width="6px" />
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>}</mo>
  </mrow>
 </mrow></math> by means of an affine transformation <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover>
   <mrow><mo> mapstochar </mo><mo> &rarr; </mo>
   </mrow>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo>=</mo>
   <msub>
    <mrow><mi>T</mi>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo>+</mo>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>b</mi>
     </mstyle>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>T</mi>
   </mrow>
   <mrow><mi>K</mi>
   </mrow>
  </msub>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mstyle mathvariant='bold'><mi>b</mi>
    </mstyle>
   </mrow>
   <mrow><mi>K</mi>
   </mrow>
  </msub>
 </mrow></math> computed from <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>p</mi>
     </mstyle>
    </mrow>
    <mrow><mi>j</mi>
    </mrow>
   </msub><mo>,</mo><mspace width="6px" />
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>p</mi>
     </mstyle>
    </mrow>
    <mrow><mi>k</mi>
    </mrow>
   </msub><mo>,</mo><mspace width="6px" />
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>p</mi>
     </mstyle>
    </mrow>
    <mrow><mi> &ell; </mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>. This also transforms that values of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>'</mo>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> to compute <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>: <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, but <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi> &phi; </mi>
       </mrow>
       <mrow><mi>i</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow>
        <mover>
         <mrow><mi> &phi; </mi>
         </mrow><mo stretchy="true">&Hat;</mo>
        </mover>
       </mrow>
       <mrow><mi>i</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow>
        <mover>
         <mrow><mi>x</mi>
         </mrow><mo stretchy="true">&Hat;</mo>
        </mover>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow>
        <mover>
         <mrow><mi>x</mi>
         </mrow><mo stretchy="true">&Hat;</mo>
        </mover>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>+</mo>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow>
        <mover>
         <mrow><mi> &phi; </mi>
         </mrow><mo stretchy="true">&Hat;</mo>
        </mover>
       </mrow>
       <mrow><mi>i</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow>
        <mover>
         <mrow><mi>x</mi>
         </mrow><mo stretchy="true">&Hat;</mo>
        </mover>
       </mrow>
       <mrow><mn>2</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow>
        <mover>
         <mrow><mi>x</mi>
         </mrow><mo stretchy="true">&Hat;</mo>
        </mover>
       </mrow>
       <mrow><mn>2</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>,</mo>
  </mrow>
 </mrow></math>for example. The derivatives <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi>x</mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math></div>

<div class="standard"><a id='magicparlabel-337013' />
The matrix entries are formed by means of integrals<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mtable>
  <mtr>
   <mtd>
    <msub>
     <mrow><mi>a</mi>
     </mrow>
     <mrow>
      <mrow><mi>i</mi><mi>j</mi>
      </mrow>
     </mrow>
    </msub>
   </mtd>
   <mtd><mo>=</mo>
   </mtd>
   <mtd>
    <msubsup>
     <mrow><mo> &int; </mo>
     </mrow>
     <mrow><mo> &Omega; </mo>
     </mrow>
     <mrow><mo> &Omega; </mo>
     </mrow>
    </msubsup>
    <mrow>
     <msub>
      <mrow><mo> &sum; </mo>
      </mrow>
      <mrow>
       <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mrow><mi>c</mi>
      </mrow>
      <mrow>
       <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
       </mrow>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>A</mi>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>B</mi>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>j</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
    </mrow><mo> &InvisibleTimes; </mo>
    <mrow><mo> &DifferentialD; </mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow>
   </mtd>
  </mtr>
  <mtr>
   <mtd><mrow/>
   </mtd>
   <mtd><mo>=</mo>
   </mtd>
   <mtd>
    <mrow>
     <msub>
      <mrow><mo> &sum; </mo>
      </mrow>
      <mrow><mi>K</mi>
      </mrow>
     </msub>
     <msubsup>
      <mrow><mo> &int; </mo>
      </mrow>
      <mrow><mi>K</mi>
      </mrow>
      <mrow><mi>K</mi>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mrow><mo> &sum; </mo>
       </mrow>
       <mrow>
        <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
        </mrow>
       </mrow>
      </msub>
      <msub>
       <mrow><mi>c</mi>
       </mrow>
       <mrow>
        <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
        </mrow>
       </mrow>
      </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>A</mi>
      <msub>
       <mrow><mi> &phi; </mi>
       </mrow>
       <mrow><mi>i</mi>
       </mrow>
      </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>B</mi>
      <msub>
       <mrow><mi> &phi; </mi>
       </mrow>
       <mrow><mi>j</mi>
       </mrow>
      </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
     </mrow><mo> &InvisibleTimes; </mo>
     <mrow><mo> &DifferentialD; </mo>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle>
     </mrow><mn>.</mn>
    </mrow>
   </mtd>
  </mtr>
 </mtable></math>The sum over <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>B</mi>
 </mrow></math> is over all the operators used to define the Galerkin form of the partial differential equations; the sum over <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math> is the sum over all the triangles of the triangulation. To compute the integral over <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math> we use rules for integration over the reference triangle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mover>
   <mrow><mi>K</mi>
   </mrow><mo stretchy="true">&Hat;</mo>
  </mover>
 </mrow></math>. </div>

<div class="standard"><a id='magicparlabel-337014' />
For the Petrov&ndash;Galerkin method, we can use different basis functions (and thus different element types), but they must be based on the same triangulation:<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>b</mi>
    </mrow>
    <mrow>
     <mrow><mi>i</mi><mi>j</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo>
   <msub>
    <mrow><mo> &sum; </mo>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msubsup>
   <mrow>
    <msub>
     <mrow><mo> &sum; </mo>
     </mrow>
     <mrow>
      <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mrow><mi>c</mi>
     </mrow>
     <mrow>
      <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
      </mrow>
     </mrow>
    </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>A</mi>
    <msub>
     <mrow><mi> &psi; </mi>
     </mrow>
     <mrow><mi>i</mi>
     </mrow>
    </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>B</mi>
    <msub>
     <mrow><mi> &phi; </mi>
     </mrow>
     <mrow><mi>j</mi>
     </mrow>
    </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
   </mrow><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow><mn>.</mn>
  </mrow>
 </mrow></math>There are also matrix assembly routines for boundaries. Boundaries of two-dimensional regions are given as sets of edges (each edge being a pair of indexes into the point array p).</div>
<h3 class="subsection"><span class="subsection_label">1.2</span> <a id='magicparlabel-337015' />
<a id="sub_PDE_representation" />
PDE representation</h3>
<div class="standard"><a id='magicparlabel-337016' />
The PDE itself is represented by pde structure, which is based on the Galerkin (or Galerkin&ndash;Petrov) method. If the weak form is of the Galerkin type:<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup>
   <mrow>
    <msub>
     <mrow><mo> &sum; </mo>
     </mrow>
     <mrow>
      <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mrow><mi>c</mi>
     </mrow>
     <mrow>
      <mrow><mi>A</mi><mo>,</mo><mi>B</mi>
      </mrow>
     </mrow>
    </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>A</mi><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>B</mi><mi>u</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
   </mrow><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow><mo>=</mo>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup>
   <mrow>
    <msub>
     <mrow><mo> &sum; </mo>
     </mrow>
     <mrow><mi>A</mi>
     </mrow>
    </msub>
    <msub>
     <mrow><mi>f</mi>
     </mrow>
     <mrow><mi>A</mi>
     </mrow>
    </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>A</mi><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
   </mrow><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow><mspace width="40px" />
   <mstyle class='mathbox'>
    <mrow>for&nbsp;all&nbsp;
    </mrow>
   </mstyle><mi>v</mi><mo> &isin; </mo>
   <mstyle class='mathbox'>
    <mrow>span
    </mrow>
   </mstyle>
   <msubsup>
    <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>{</mo>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='postfix' fence='true' stretchy='true' symmetric='true'>}</mo>
    </mrow>
    <mrow>
     <mrow><mi>i</mi><mo>=</mo><mn>1</mn>
     </mrow>
    </mrow>
    <mrow><mi>N</mi>
    </mrow>
   </msubsup><mo>,</mo>
  </mrow>
 </mrow></math>then pde consists of the maximum order of the operators <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>B</mi>
 </mrow></math>, together with the functions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>C</mi><mo> &colon; </mo><mo> &Omega; </mo><mo> &rarr; </mo>
   <msup>
    <mrow>
     <mstyle mathvariant='bold'><mi>R</mi>
     </mstyle>
    </mrow>
    <mrow>
     <mrow><mi>M</mi><mo> &times; </mo><mi>M</mi>
     </mrow>
    </mrow>
   </msup>
  </mrow>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mstyle mathvariant='bold'><mi>f</mi>
   </mstyle><mo> &colon; </mo><mo> &Omega; </mo><mo> &rarr; </mo>
   <msup>
    <mrow>
     <mstyle mathvariant='bold'><mi>R</mi>
     </mstyle>
    </mrow>
    <mrow><mi>M</mi>
    </mrow>
   </msup>
  </mrow>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> is the number of operators <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> considered. For example, for a scalar problem in two dimensions where the Galerkin form only involves function values and first derivatives, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> can be <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>I</mi>
 </mrow></math> (identity) for the function values, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> for the first derivatives. Then <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>M</mi><mo>=</mo><mn>3</mn>
  </mrow>
 </mrow></math>. </div>

<div class="standard"><a id='magicparlabel-337017' />
For the PDE <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo>-</mo><mo> &Delta; </mo><mi>u</mi><mo>=</mo><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> with <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msubsup>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msubsup><mspace width="6px" /><mi>exp</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, we use:</div>

<div class="scrap"><a id='magicparlabel-337018' />
&lt;&lt;pde-struct-eg&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337019' />
pde = struct('coeffs',@(x)diag([0,1,1]), ...</div>

<div class="scrap"><a id='magicparlabel-337020' />
        'rhs',@(x)[x(1)^2*exp(x(2));0;0],'order',1)</div>

<div class="scrap"><a id='magicparlabel-337021' />
@</div>

<div class="scrap"><a id='magicparlabel-337022' />
</div>
<h3 class="subsection"><span class="subsection_label">1.3</span> <a id='magicparlabel-337023' />
<a id="sub_Usage" />
Usage</h3>
<div class="standard"><a id='magicparlabel-351957' />
Were we present an example of the solution of<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mtable>
  <mtr>
   <mtd>
    <mrow><mo>-</mo><mo> &Delta; </mo><mi>u</mi>
    </mrow>
   </mtd>
   <mtd><mo>=</mo>
   </mtd>
   <mtd>
    <mrow><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="40px" />
     <mstyle class='mathbox'>
      <mrow>in&nbsp;
      </mrow>
     </mstyle><mo> &Omega; </mo><mo>,</mo>
    </mrow>
   </mtd>
  </mtr>
  <mtr>
   <mtd><mi>u</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
   </mtd>
   <mtd><mo>=</mo>
   </mtd>
   <mtd>
    <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="40px" />
     <mstyle class='mathbox'>
      <mrow>on&nbsp;
      </mrow>
     </mstyle><mi> &part; </mi><mo> &Omega; </mo><mn>.</mn>
    </mrow>
   </mtd>
  </mtr>
 </mtable></math>As usual <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo> &Omega; </mo>
  </mrow>
 </mrow></math> is the boundary of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &Omega; </mo>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo> &Delta; </mo><mi>u</mi><mo>=</mo>
   <msup>
    <mrow><mi> &part; </mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mi>u</mi><mo>/</mo><mi> &part; </mi>
   <msubsup>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msubsup><mo>+</mo>
   <msup>
    <mrow><mi> &part; </mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mi>u</mi><mo>/</mo><mi> &part; </mi>
   <msubsup>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msubsup>
  </mrow>
 </mrow></math> is the Laplacian operator. This is an elliptic partial differential operator of second order with Dirichlet (forced) boundary conditions.</div>

<div class="standard"><a id='magicparlabel-351998' />
The weak form of this PDE is<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>u</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>v</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac><mo>+</mo>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>u</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>2</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>v</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>2</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow><mo>=</mo>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup>
   <mrow><mi> &nabla; </mi><mi>u</mi><mo> &sdot; </mo><mi> &nabla; </mi><mi>v</mi><mspace width="6px" />
   </mrow><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow><mo>=</mo>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup>
   <mrow><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
   </mrow><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow>
  </mrow>
 </mrow></math>for all <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>v</mi>
 </mrow></math> that is &ldquo;nice&rdquo; and satisfies <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo><mn>0</mn>
  </mrow>
 </mrow></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo> &isin; </mo><mi> &part; </mi><mo> &Omega; </mo>
  </mrow>
 </mrow></math>. Here &ldquo;nice&rdquo; can mean smooth, but it is also true when <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>v</mi>
 </mrow></math> is a piecewise linear function over the triangulation with &ldquo;<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mo>=</mo><mn>0</mn>
  </mrow>
 </mrow></math> on <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo> &Omega; </mo>
  </mrow>
 </mrow></math>&rdquo;. </div>

<div class="standard"><a id='magicparlabel-353468' />
The domain <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &Omega; </mo>
 </mrow></math> has to be defined according to the problem. An example is a square <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow><mo>-</mo><mn>1</mn><mo>,</mo><mspace width="6px" /><mo>+</mo><mn>1</mn>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo><mo> &times; </mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow><mo>-</mo><mn>1</mn><mo>,</mo><mspace width="6px" /><mo>+</mo><mn>1</mn>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo>
  </mrow>
 </mrow></math> with a circle center at the origin and radius 1/2 removed. A triangulation can be computed using distmesh from Persson and Strang (URL <span class="flex_url">http://persson.berkeley.edu/distmesh/</span>) as follows:</div>

<div class="scrap"><a id='magicparlabel-354975' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-402219' />
usage.m \</div>

<div class="scrap"><a id='magicparlabel-402214' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-354985' />
fd = @(p)ddiff(drectangle(p,-1,1,-1,1),dcircle(p,0,0,0.5))</div>

<div class="scrap"><a id='magicparlabel-354990' />
fh = @(p)min(4*sqrt(sum(p.^2,2))-1,2)</div>

<div class="scrap"><a id='magicparlabel-354994' />
[p,t]=distmesh2d(fd,fh,0.1,[-1,-1;1,1],[-1,-1;-1,1;1,-1;1,1]);</div>

<div class="scrap"><a id='magicparlabel-356521' />
np = size(p,1)</div>

<div class="scrap"><a id='magicparlabel-354981' />
@</div>

<div class="standard"><a id='magicparlabel-356490' />
The fd function defines the region, while fh is used to control the variation of the triangle sizes. Then distmesh2d() itself creates the triangulation. See the documentation on distmesh for more information. The last line just tells us the number of points in the triangulation. Once the triangulation has been computed, we can create the element type (piecewise linear):</div>

<div class="scrap"><a id='magicparlabel-356507' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-356518' />
lin2d = lin2d_elt()</div>

<div class="scrap"><a id='magicparlabel-356514' />
@</div>

<div class="standard"><a id='magicparlabel-356593' />
The triangulation and the element type together determine the variables:</div>

<div class="scrap"><a id='magicparlabel-356607' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-356613' />
fht = create_fht(p,t,lin2d)</div>

<div class="scrap"><a id='magicparlabel-361210' />
nv = fht_num_vars(fht)</div>

<div class="scrap"><a id='magicparlabel-358061' />
@</div>

<div class="standard"><a id='magicparlabel-358065' />
Here fht is the geometric feature hash table, which relates geometric features (triangles, edges, vertices) with variable indexes. The value of nv is the number of variables in the system.</div>

<div class="standard"><a id='magicparlabel-358101' />
Since the weak form of the PDE is<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup><mo form='prefix' fence='true' stretchy='true' symmetric='true'>[</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>u</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>v</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac><mo>+</mo>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>u</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>2</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
    <mfrac>
     <mrow>
      <mrow><mi> &part; </mi><mi>v</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>2</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
   </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>]</mo><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow><mo>=</mo>
   <msubsup>
    <mrow><mo> &int; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
    <mrow><mo> &Omega; </mo>
    </mrow>
   </msubsup>
   <mrow><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
   </mrow><mo> &InvisibleTimes; </mo>
   <mrow><mo> &DifferentialD; </mo>
    <mstyle mathvariant='bold'><mi>x</mi>
    </mstyle>
   </mrow>
  </mrow>
 </mrow></math>where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>v</mi><mo>=</mo><mn>0</mn>
  </mrow>
 </mrow></math> on <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo> &Omega; </mo>
  </mrow>
 </mrow></math>, the PDE structure representing this is</div>

<div class="scrap"><a id='magicparlabel-358169' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-358172' />
pde = struct('coeffs',@(x)diag([0,1,1]),'rhs',@(x)[f(x);0;0],'order',1)</div>

<div class="scrap"><a id='magicparlabel-359632' />
@</div>

<div class="standard"><a id='magicparlabel-359636' />
The coeffs component is a function returning a matrix that represents the bilinear weak form above:<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi><mi>u</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi><mi>v</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo>+</mo>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi><mi>u</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>2</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
   <mfrac>
    <mrow>
     <mrow><mi> &part; </mi><mi>v</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow><mi> &part; </mi>
      <msub>
       <mrow><mi>x</mi>
       </mrow>
       <mrow><mn>2</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mfrac><mo>=</mo>
   <msup>
    <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
     <mtable>
      <mtr>
       <mtd><mi>v</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow><mi> &part; </mi><mi>v</mi><mo>/</mo><mi> &part; </mi>
         <msub>
          <mrow><mi>x</mi>
          </mrow>
          <mrow><mn>1</mn>
          </mrow>
         </msub>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow><mi> &part; </mi><mi>v</mi><mo>/</mo><mi> &part; </mi>
         <msub>
          <mrow><mi>x</mi>
          </mrow>
          <mrow><mn>2</mn>
          </mrow>
         </msub>
        </mrow>
       </mtd>
      </mtr>
     </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
    </mrow>
    <mrow><mi>T</mi>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
   <mtable>
    <mtr>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>1</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>0</mn>
     </mtd>
     <mtd><mn>1</mn>
     </mtd>
    </mtr>
   </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
   <mtable>
    <mtr>
     <mtd><mi>u</mi>
     </mtd>
    </mtr>
    <mtr>
     <mtd>
      <mrow><mi> &part; </mi><mi>u</mi><mo>/</mo><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd>
      <mrow><mi> &part; </mi><mi>u</mi><mo>/</mo><mi> &part; </mi>
       <msub>
        <mrow><mi>x</mi>
        </mrow>
        <mrow><mn>2</mn>
        </mrow>
       </msub>
      </mrow>
     </mtd>
    </mtr>
   </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo><mn>.</mn>
  </mrow>
 </mrow></math>The rhs component is a function returning a vector that represents the linear part of the weak form (on the right):<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" /><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msup>
    <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
     <mtable>
      <mtr>
       <mtd><mi>v</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
        <mstyle mathvariant='bold'><mi>x</mi>
        </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow><mi> &part; </mi><mi>v</mi><mo>/</mo><mi> &part; </mi>
         <msub>
          <mrow><mi>x</mi>
          </mrow>
          <mrow><mn>1</mn>
          </mrow>
         </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
         <mstyle mathvariant='bold'><mi>x</mi>
         </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow><mi> &part; </mi><mi>v</mi><mo>/</mo><mi> &part; </mi>
         <msub>
          <mrow><mi>x</mi>
          </mrow>
          <mrow><mn>2</mn>
          </mrow>
         </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
         <mstyle mathvariant='bold'><mi>x</mi>
         </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo>
    </mrow>
    <mrow><mi>T</mi>
    </mrow>
   </msup><mo form='prefix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>[</mo>
   <mtable>
    <mtr>
     <mtd><mi>f</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
     </mtd>
    </mtr>
    <mtr>
     <mtd><mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd><mn>0</mn>
     </mtd>
    </mtr>
   </mtable><mo form='postfix' fence='true' stretchy='true' symmetric='true' lspace='thinmathspace'>]</mo><mn>.</mn>
  </mrow>
 </mrow></math>The order component is set to one to indicate that only function values and first order derivatives are needed. The maximum value of order (in the current code) is two.</div>

<div class="standard"><a id='magicparlabel-361223' />
Now we need to create the matrix and right-hand side vector for the linear system to solve. First we assemble the matrix and right-hand side vector for the PDE. As yet, this does not deal with boundary values: </div>

<div class="scrap"><a id='magicparlabel-361252' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-361262' />
% Initialize A and b </div>

<div class="scrap"><a id='magicparlabel-361266' />
A = sparse(nv,nv); </div>

<div class="scrap"><a id='magicparlabel-361269' />
b = zeros(nv,1); </div>

<div class="scrap"><a id='magicparlabel-361279' />
% Assemble matrix and vector  </div>

<div class="scrap"><a id='magicparlabel-361283' />
[A,b] = assembly2d(A,b,pde,lin2d,p,t,fht,@int2d_radon7); </div>

<div class="scrap"><a id='magicparlabel-361258' />
@</div>

<div class="standard"><a id='magicparlabel-361293' />
Note that the matrix <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> is created as a sparse matrix. It is not necessary to do so, but it is recommended as the systems created are generally very sparse. The vector <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>b</mi>
  </mstyle>
 </mrow></math> does not need to be created as a sparse vector. These are initialized to zero by the sparse() and zeros() functions. The assembly2d() function adds the assembled matrices and vectors to the pre-existing <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>b</mi>
  </mstyle>
 </mrow></math>; this feature is useful if you are combining several different partial differential operators into one. An integration method needed to be selected: Radon's 7-point scheme for triangles is 5th order accurate, which is sufficient for our purposes.</div>

<div class="standard"><a id='magicparlabel-362845' />
Since we have Dirichlet boundary conditions, we need to explicitly set the values of the variables of the boundary nodes according to <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mstyle mathvariant='bold'><mi>x</mi>
  </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>. First we need to identify the boundary edges and nodes:</div>

<div class="scrap"><a id='magicparlabel-362863' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-362874' />
[bedges,bnodes,t_index] = boundary2d(t);</div>

<div class="scrap"><a id='magicparlabel-362870' />
@</div>

<div class="standard"><a id='magicparlabel-362878' />
There are several ways of setting boundary values. The method presented here essentially solves a least squares problem to find the finite element function that best approximates the given <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mstyle mathvariant='bold'><mi>x</mi>
  </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>. This shows another usage of the PDE data structure as well as the boundary assembly function:</div>

<div class="scrap"><a id='magicparlabel-364395' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-364405' />
pde2 = struct('coeffs',@(x)[1],'rhs',@(x)g(x),'order',0)</div>

<div class="scrap"><a id='magicparlabel-364401' />
@</div>

<div class="standard"><a id='magicparlabel-364425' />
Note that the order parameter is set to zero to indicate that no derivatives are involved. Then we assemble the normal equations matrix and right-hand side for the least squares problem:</div>

<div class="scrap"><a id='magicparlabel-364459' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-364470' />
[Ab,bb,bvlist] = assembly2dbdry(pde2,lin2d,p,t,bedges,t_index,fht,@int1d_gauss5);</div>

<div class="scrap"><a id='magicparlabel-364466' />
@</div>

<div class="standard"><a id='magicparlabel-364474' />
Now we solve the linear system to obtain values of the boundary variables.</div>

<div class="scrap"><a id='magicparlabel-365978' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-365982' />
g1 = Ab(bvlist,bvlist) \ bb(bvlist);</div>

<div class="scrap"><a id='magicparlabel-365999' />
@</div>

<div class="standard"><a id='magicparlabel-366008' />
Now we can solve the remainder of the system for the non-boundary variables. First, find the non-boundary variables (cbvlist means &ldquo;complement of bvlist&rdquo;).</div>

<div class="scrap"><a id='magicparlabel-366042' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-366052' />
% find non-boundary variables (cbvlist) </div>

<div class="scrap"><a id='magicparlabel-366056' />
v_array = ones(nv,1); v_array(bvlist) = 0; </div>

<div class="scrap"><a id='magicparlabel-366059' />
cbvlist = find(v_array ~= 0);</div>

<div class="scrap"><a id='magicparlabel-366048' />
@</div>

<div class="standard"><a id='magicparlabel-366092' />
Now we solve the linear system for the non-boundary variables and insert the results into the vector <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>u</mi>
  </mstyle>
 </mrow></math>; the boundary variables in <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>u</mi>
  </mstyle>
 </mrow></math> are in g1. </div>

<div class="scrap"><a id='magicparlabel-367604' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-367616' />
u_int = A(cbvlist,cbvlist) \ (b(cbvlist) - A(cbvlist,bvlist)*g1);</div>

<div class="scrap"><a id='magicparlabel-367618' />
u = zeros(nv,1); </div>

<div class="scrap"><a id='magicparlabel-367647' />
u(cbvlist) = u_int; </div>

<div class="scrap"><a id='magicparlabel-367650' />
u( bvlist) = g1; </div>

<div class="scrap"><a id='magicparlabel-367612' />
@</div>

<div class="standard"><a id='magicparlabel-367653' />
We can plot the values of our numerical solution <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>u</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mstyle mathvariant='bold'><mi>x</mi>
  </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math> at the vertices of the triangulation by means of trimesh() and a helper routine pvlist() that returns the variable indexes for the vertices of the triangulation.</div>

<div class="scrap"><a id='magicparlabel-367699' />
&lt;&lt;usage.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-367709' />
pvlist = get_pvlist(fht,np); </div>

<div class="scrap"><a id='magicparlabel-421961' />
figure(2)</div>

<div class="scrap"><a id='magicparlabel-369213' />
trimesh(t,p(:,1),p(:,2),u(pvlist))</div>

<div class="scrap"><a id='magicparlabel-367705' />
@</div>
<h2 class="section"><span class="section_label">2</span> <a id='magicparlabel-337024' />
<a id="sec_Matrix_assembly_code" />
Matrix assembly code</h2>
<div class="standard"><a id='magicparlabel-337025' />
The main matrix assembly code assembly2d() is given below. The function adds values in the matrix <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> and the vector <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>b</mi>
  </mstyle>
 </mrow></math>. In this way, the full assembly process can be accomplished &ldquo;in pieces&rdquo;, if needed. So, for stand-alone use, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>b</mi>
  </mstyle>
 </mrow></math> must be initialized to zero. Note that <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> can (and should) be a sparse matrix.</div>

<div class="standard"><a id='magicparlabel-337026' />
The PDE is represented by two functions which are in the pde structure (see Subsection&nbsp;<a href="#sub_PDE_representation">1.2</a>).</div>

<div class="standard"><a id='magicparlabel-337027' />
The element type is defined by the elt structure (see Section&nbsp;<a href="#sec_Element_types">4</a>).</div>

<div class="standard"><a id='magicparlabel-337028' />
The triangulation is given by the pair (p,t) as described in Section&nbsp;<a href="#sec_Overview">1</a>. </div>

<div class="standard"><a id='magicparlabel-337029' />
The hash table for the map from geometric features (triangles, edges, and vertices) to variables is fht (see Section&nbsp;<a href="#sec_Handling_geometric_features">3</a>).</div>

<div class="standard"><a id='magicparlabel-337030' />
The points and weights for the integration method on the reference element are returned by the function intmethod() (see Section&nbsp;<a href="#sec_Numerical_integration">5</a>). These points and weights are computed in <em>assembly2d-init</em>.</div>

<div class="standard"><a id='magicparlabel-337031' />
The line</div>

<div class="lyx_code"><div class="lyx_code_item"><a id='magicparlabel-337032' />
[vlist,slist] = get_var_triangle(t(i,:),fht,elt,np);</div>
</div>
<div class="standard"><a id='magicparlabel-337033' />
gets the list of (global) variables indexes (vlist) associated with triangle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math>, along with the list of sign changes needed (slist). </div>

<div class="scrap"><a id='magicparlabel-337034' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337035' />
assembly2d.m \</div>

<div class="scrap"><a id='magicparlabel-337036' />
&lt;&lt;assembly2d.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337037' />
function [A,b] = assembly2d(A,b,pde,elt,p,t,fht,intmethod)</div>

<div class="scrap"><a id='magicparlabel-337038' />
% function [A,b] = assembly2d(A,b,pde,elt,p,t,fht,intmethod)</div>

<div class="scrap"><a id='magicparlabel-337039' />
% Adds the assembled matrix and vector representing the</div>

<div class="scrap"><a id='magicparlabel-337040' />
% given PDE (pde) to the A matrix &amp; b vector.</div>

<div class="scrap"><a id='magicparlabel-337041' />
% This uses a given element (elt) with the triangulation given by (p,t).</div>

<div class="scrap"><a id='magicparlabel-337042' />
% The feature hash table (fht) is used to obtain variable indexes</div>

<div class="scrap"><a id='magicparlabel-337043' />
% for given features. This is obtained by create_fht().</div>

<div class="scrap"><a id='magicparlabel-337044' />
%</div>

<div class="scrap"><a id='magicparlabel-337045' />
% A must be nv x nv and b must be nv x 1 where nv is the total</div>

<div class="scrap"><a id='magicparlabel-337046' />
% number of variables (as returned by fht_num_vars()).</div>

<div class="scrap"><a id='magicparlabel-337047' />
% Reference triangle has vertices (0,0), (1,0), (0,1).</div>

<div class="scrap"><a id='magicparlabel-337048' />
&lt;&lt;assembly2d-init&gt;&gt;</div>

<div class="scrap"><a id='magicparlabel-337049' />
&lt;&lt;assembly2d-precompute-Aphihat&gt;&gt;</div>

<div class="scrap"><a id='magicparlabel-337050' />
for i = 1:size(t,1) % for all triangles ...</div>

<div class="scrap"><a id='magicparlabel-337051' />
    % obtain variable list and signs for this triangle</div>

<div class="scrap"><a id='magicparlabel-337052' />
    [vlist,slist] = get_var_triangle(t(i,:),fht,elt,np);</div>

<div class="scrap"><a id='magicparlabel-337053' />
    % set up affine transformation xhat :-&gt; x = T.xhat + b0</div>

<div class="scrap"><a id='magicparlabel-337054' />
    i1 = t(i,1);  i2 = t(i,2);  i3 = t(i,3);</div>

<div class="scrap"><a id='magicparlabel-337055' />
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];</div>

<div class="scrap"><a id='magicparlabel-337056' />
    b0 = p(i1,:)';</div>

<div class="scrap"><a id='magicparlabel-337057' />
    % form weighted sum of integrand at integration points</div>

<div class="scrap"><a id='magicparlabel-337058' />
    intval1 = 0;</div>

<div class="scrap"><a id='magicparlabel-337059' />
    intval2 = 0;</div>

<div class="scrap"><a id='magicparlabel-337060' />
    for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337061' />
        Aphival = elt.trans_Aphihat(T,Aphihatvals{k},order);</div>

<div class="scrap"><a id='magicparlabel-337062' />
        Dmat    = pde.coeffs(T*p_int(k,:)'+b0);</div>

<div class="scrap"><a id='magicparlabel-337063' />
        rhsvec  = pde.rhs(T*p_int(k,:)'+b0);</div>

<div class="scrap"><a id='magicparlabel-337064' />
        integrand_val1 = Aphival*Dmat*Aphival';</div>

<div class="scrap"><a id='magicparlabel-337065' />
        integrand_val2 = Aphival*rhsvec;</div>

<div class="scrap"><a id='magicparlabel-337066' />
        intval1 = intval1 + w_int(k)*integrand_val1;</div>

<div class="scrap"><a id='magicparlabel-337067' />
        intval2 = intval2 + w_int(k)*integrand_val2;</div>

<div class="scrap"><a id='magicparlabel-337068' />
    end</div>

<div class="scrap"><a id='magicparlabel-337069' />
    detT = abs(det(T));</div>

<div class="scrap"><a id='magicparlabel-337070' />
    intval1 = intval1*detT; % scale by Jacobian</div>

<div class="scrap"><a id='magicparlabel-337071' />
    intval2 = intval2*detT;</div>

<div class="scrap"><a id='magicparlabel-337072' />
    intval1 = diag(slist)*intval1*diag(slist); % change signs if needed</div>

<div class="scrap"><a id='magicparlabel-337073' />
    intval2 = slist'.*intval2;</div>

<div class="scrap"><a id='magicparlabel-337074' />
    A(vlist,vlist) = A(vlist,vlist) + intval1; % add to matrix &amp; vec</div>

<div class="scrap"><a id='magicparlabel-337075' />
    b(vlist) = b(vlist) + intval2;</div>

<div class="scrap"><a id='magicparlabel-337076' />
end</div>

<div class="scrap"><a id='magicparlabel-337077' />
@</div>

<div class="standard"><a id='magicparlabel-337078' />
Initialization for <em>assembly2d</em>:</div>

<div class="scrap"><a id='magicparlabel-337079' />
&lt;&lt;assembly2d-init&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337080' />
[p_int,w_int] = intmethod(); % points and weights for reference triangle</div>

<div class="scrap"><a id='magicparlabel-337081' />
% np is the total number of points in the triangulation</div>

<div class="scrap"><a id='magicparlabel-337082' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-337083' />
% compute nv = total number of variables</div>

<div class="scrap"><a id='magicparlabel-337084' />
nv = fht_num_vars(fht);</div>

<div class="scrap"><a id='magicparlabel-337085' />
% nv_elt is the number of variables in one element</div>

<div class="scrap"><a id='magicparlabel-337086' />
nv_elt = sum(elt.nvars);</div>

<div class="scrap"><a id='magicparlabel-337087' />
% order is the order of derivatives used in the assembly;</div>

<div class="scrap"><a id='magicparlabel-337088' />
% we need 0 &lt;= order &lt;= 2</div>

<div class="scrap"><a id='magicparlabel-337089' />
order = pde.order;</div>

<div class="scrap"><a id='magicparlabel-337090' />
intval1 = zeros(nv_elt,nv_elt);</div>

<div class="scrap"><a id='magicparlabel-337091' />
intval2 = zeros(nv_elt,1);</div>

<div class="scrap"><a id='magicparlabel-337092' />
@</div>

<div class="standard"><a id='magicparlabel-337093' />
For efficiency, we precompute the values of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msub>
    <mrow>
     <mover>
      <mrow>
       <mstyle mathvariant='bold'><mi>x</mi>
       </mstyle>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>j</mi>
    </mrow>
   </msub><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mover>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle>
     </mrow><mo stretchy="true">&Hat;</mo>
    </mover>
   </mrow>
   <mrow><mi>j</mi>
   </mrow>
  </msub>
 </mrow></math> are the integration points on the reference triangle. These depend only on the element type and the reference element <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mover>
   <mrow><mi>K</mi>
   </mrow><mo stretchy="true">&Hat;</mo>
  </mover>
 </mrow></math>. </div>

<div class="scrap"><a id='magicparlabel-337094' />
&lt;&lt;assembly2d-precompute-Aphihat&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337095' />
% Save get_Aphihat() values for all the integration points</div>

<div class="scrap"><a id='magicparlabel-337096' />
% on the reference element</div>

<div class="scrap"><a id='magicparlabel-337097' />
Aphihatvals = cell(length(w_int),1);</div>

<div class="scrap"><a id='magicparlabel-337098' />
for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337099' />
    Aphihatvals{k} = elt.get_Aphihat(p_int(k,:),order);</div>

<div class="scrap"><a id='magicparlabel-337100' />
end</div>

<div class="scrap"><a id='magicparlabel-337101' />
@</div>

<div class="standard"><a id='magicparlabel-337102' />
</div>
<h3 class="subsection"><span class="subsection_label">2.1</span> <a id='magicparlabel-337107' />
<a id="sub_Petrov__Galerkin_method" />
Petrov&ndash;Galerkin method</h3>
<div class="standard"><a id='magicparlabel-337108' />
The Petrov&ndash;Galerkin method is supported through the pgassembly2d() function. Since there are potentially two different elements used (elt1 and elt2), we need to pass two separate feature hash tables (fht1 and fht2). Otherwise the inputs are identical to those for the standard Galerkin assembly function assembly2d(). Note that assembly2d() is equivalent to </div>

<div class="lyx_code"><div class="lyx_code_item"><a id='magicparlabel-337109' />
pgassembly2d(A,b,pde,p,t,elt,fht,elt,fht,intmethod)</div>
</div>
<div class="standard"><a id='magicparlabel-337110' />
</div>

<div class="scrap"><a id='magicparlabel-337115' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337116' />
pgassembly2d.m \</div>

<div class="scrap"><a id='magicparlabel-337117' />
&lt;&lt;pgassembly2d.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337118' />
function [A,b] = pgassembly2d(A,b,pde,p,t,elt1,fht1,elt2,fht2,intmethod)</div>

<div class="scrap"><a id='magicparlabel-337119' />
% function [A,b] = pgassembly2d(A,b,pde,p,t,elt1,fht1,elt2,fht2,intmethod)</div>

<div class="scrap"><a id='magicparlabel-337120' />
% </div>

<div class="scrap"><a id='magicparlabel-337121' />
% Petrov-Galerkin matrix assembly.</div>

<div class="scrap"><a id='magicparlabel-337122' />
% Adds the assembled matrix and vector representing the</div>

<div class="scrap"><a id='magicparlabel-337123' />
% given PDE (pde) to the A matrix &amp; b vector.</div>

<div class="scrap"><a id='magicparlabel-337124' />
% This uses a given elements (elt1, elt2) with the triangulation given by (p,t).</div>

<div class="scrap"><a id='magicparlabel-337125' />
% The feature hash tables (fht1 for elt1, fht2 for elt2) are used to obtain </div>

<div class="scrap"><a id='magicparlabel-337126' />
% variable indexes for given features. These are obtained by create_fht().</div>

<div class="scrap"><a id='magicparlabel-337127' />
%</div>

<div class="scrap"><a id='magicparlabel-337128' />
% elt1 represents the test functions, while elt2 represents the basis</div>

<div class="scrap"><a id='magicparlabel-337129' />
% functions.</div>

<div class="scrap"><a id='magicparlabel-337130' />
%</div>

<div class="scrap"><a id='magicparlabel-337131' />
% The two elements can be quite independent, but the triangulation must be</div>

<div class="scrap"><a id='magicparlabel-337132' />
% the same for the two sets of variables.</div>

<div class="scrap"><a id='magicparlabel-337133' />
%</div>

<div class="scrap"><a id='magicparlabel-337134' />
% A must be nv1 x nv2 and b must be nv1 x 1 where nv1 is the total</div>

<div class="scrap"><a id='magicparlabel-337135' />
% number of variables for elt1 and nv2 is the total number of variables</div>

<div class="scrap"><a id='magicparlabel-337136' />
% for elt2 (as returned by fht_num_vars()).</div>

<div class="scrap"><a id='magicparlabel-337137' />
% Reference triangle has vertices (0,0), (1,0), (0,1).</div>

<div class="scrap"><a id='magicparlabel-337138' />
&lt;&lt;pgassembly2d-init&gt;&gt;</div>

<div class="scrap"><a id='magicparlabel-337139' />
&lt;&lt;pgassembly2d-precompute-Aphilist&gt;&gt;</div>

<div class="scrap"><a id='magicparlabel-337140' />
for i = 1:size(t,1) % for all triangles ...</div>

<div class="scrap"><a id='magicparlabel-337141' />
    % obtain variable list and signs for this triangle</div>

<div class="scrap"><a id='magicparlabel-337142' />
    [vlist1,slist1] = get_var_triangle(t(i,:),fht1,elt1,np);</div>

<div class="scrap"><a id='magicparlabel-337143' />
    [vlist2,slist2] = get_var_triangle(t(i,:),fht2,elt2,np);</div>

<div class="scrap"><a id='magicparlabel-337144' />
    % set up affine transformation xhat :-&gt; x = T.xhat + b</div>

<div class="scrap"><a id='magicparlabel-337145' />
    i1 = t(i,1); i2 = t(i,2); i3 = t(i,3);</div>

<div class="scrap"><a id='magicparlabel-337146' />
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];</div>

<div class="scrap"><a id='magicparlabel-337147' />
    b0 = p(i1,:)';</div>

<div class="scrap"><a id='magicparlabel-337148' />
    % form weighted sum of integrand at integration points</div>

<div class="scrap"><a id='magicparlabel-337149' />
    intval1 = 0;</div>

<div class="scrap"><a id='magicparlabel-337150' />
    intval2 = 0;</div>

<div class="scrap"><a id='magicparlabel-337151' />
    for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337152' />
        Aphival1 = elt1.trans_Aphihat(T,Aphihatvals1{k},order);</div>

<div class="scrap"><a id='magicparlabel-337153' />
        Aphival2 = elt2.trans_Aphihat(T,Aphihatvals2{k},order);</div>

<div class="scrap"><a id='magicparlabel-337154' />
        Dmat   = pde.coeffs(T*p_int(k,:)'+b0);</div>

<div class="scrap"><a id='magicparlabel-337155' />
        rhsvec = pde.rhs(   T*p_int(k,:)'+b0);</div>

<div class="scrap"><a id='magicparlabel-337156' />
        integrand_val1 = Aphival1*Dmat*Aphival2';</div>

<div class="scrap"><a id='magicparlabel-337157' />
        integrand_val2 = Aphival1*rhsvec;</div>

<div class="scrap"><a id='magicparlabel-337158' />
        intval1 = intval1 + w_int(k)*integrand_val1;</div>

<div class="scrap"><a id='magicparlabel-337159' />
        intval2 = intval2 + w_int(k)*integrand_val2;</div>

<div class="scrap"><a id='magicparlabel-337160' />
    end</div>

<div class="scrap"><a id='magicparlabel-337161' />
    detT = abs(det(T));</div>

<div class="scrap"><a id='magicparlabel-337162' />
    intval1 = intval1*detT; % scale by Jacobian</div>

<div class="scrap"><a id='magicparlabel-337163' />
    intval2 = intval2*detT;</div>

<div class="scrap"><a id='magicparlabel-337164' />
    intval1 = diag(slist1)*intval1*diag(slist2); % change signs if needed</div>

<div class="scrap"><a id='magicparlabel-337165' />
    intval2 = slist1'.*intval2;</div>

<div class="scrap"><a id='magicparlabel-337166' />
    A(vlist1,vlist2) = A(vlist1,vlist2) + intval1; % add to matrix &amp; vec</div>

<div class="scrap"><a id='magicparlabel-337167' />
    b(vlist1)        = b(vlist1)        + intval2;</div>

<div class="scrap"><a id='magicparlabel-337168' />
end % for i</div>

<div class="scrap"><a id='magicparlabel-337169' />
@</div>

<div class="standard"><a id='magicparlabel-337170' />
The initialization code follows:</div>

<div class="scrap"><a id='magicparlabel-337171' />
&lt;&lt;pgassembly2d-init&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337172' />
[p_int,w_int] = intmethod(); % points and weights for reference triangle</div>

<div class="scrap"><a id='magicparlabel-337173' />
% np is the total number of points in the triangulation</div>

<div class="scrap"><a id='magicparlabel-337174' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-337175' />
% compute total numbers of variables</div>

<div class="scrap"><a id='magicparlabel-337176' />
nv1 = fht_num_vars(fht1);</div>

<div class="scrap"><a id='magicparlabel-337177' />
nv2 = fht_num_vars(fht2);</div>

<div class="scrap"><a id='magicparlabel-337178' />
% nv_elt is the number of variables in one element</div>

<div class="scrap"><a id='magicparlabel-337179' />
nv_elt1 = sum(elt1.nvars);</div>

<div class="scrap"><a id='magicparlabel-337180' />
nv_elt2 = sum(elt2.nvars);</div>

<div class="scrap"><a id='magicparlabel-337181' />
% order is the order of derivatives used in the assembly;</div>

<div class="scrap"><a id='magicparlabel-337182' />
% we need 0 &lt;= order &lt;= 2</div>

<div class="scrap"><a id='magicparlabel-337183' />
order = pde.order;</div>

<div class="scrap"><a id='magicparlabel-337184' />
intval1 = zeros(nv_elt1,nv_elt2);</div>

<div class="scrap"><a id='magicparlabel-337185' />
intval2 = zeros(nv_elt1,1);</div>

<div class="scrap"><a id='magicparlabel-337186' />
@</div>

<div class="standard"><a id='magicparlabel-337187' />
For efficiency we pre-compute the Aphihat values at the integration points on the reference element.</div>

<div class="scrap"><a id='magicparlabel-337188' />
&lt;&lt;pgassembly2d-precompute-Aphilist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337189' />
% Save get_Aphihat() values for all the integration points</div>

<div class="scrap"><a id='magicparlabel-337190' />
% on the reference element</div>

<div class="scrap"><a id='magicparlabel-337191' />
Aphihatvals1 = cell(length(w_int),1);</div>

<div class="scrap"><a id='magicparlabel-337192' />
Aphihatvals2 = cell(length(w_int),1);</div>

<div class="scrap"><a id='magicparlabel-337193' />
for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337194' />
    Aphihatvals1{k} = elt1.get_Aphihat(p_int(k,:),order);</div>

<div class="scrap"><a id='magicparlabel-337195' />
    Aphihatvals2{k} = elt2.get_Aphihat(p_int(k,:),order);</div>

<div class="scrap"><a id='magicparlabel-337196' />
end</div>

<div class="scrap"><a id='magicparlabel-337197' />
@</div>
<h3 class="subsection"><span class="subsection_label">2.2</span> <a id='magicparlabel-337198' />
<a id="sub_Mesh_based_functions" />
Mesh-based functions and nonlinear problems</h3>
<div class="standard"><a id='magicparlabel-337199' />
Mesh-based functions are needed for handling nonlinear PDEs. These functions have the form<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msubsup>
    <mrow><mo> &sum; </mo>
    </mrow>
    <mrow>
     <mrow><mi>i</mi><mo>=</mo><mn>1</mn>
     </mrow>
    </mrow>
    <mrow><mi>N</mi>
    </mrow>
   </msubsup>
   <msub>
    <mrow><mi>g</mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mspace width="6px" />
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>;</mo>
  </mrow>
 </mrow></math><math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi>
 </mrow></math> itself may be a solution of a PDE, or a function of one (or more) such solutions. The assembly routine still produces a matrix and right-hand side for a linear system, but the linear system itself depends on a mesh-based function. This makes it easy to implement (for example), Newton's method for nonlinear PDEs. As with the Petrov&ndash;Galerkin assembly routine, it is important that <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi>
 </mrow></math> is defined using the same triangulation as we are going to use for the assembly of the linear system. However, the element type used does not need to be the same as for the remainder of the linear system. (This can also be used in a Petrov&ndash;Galerkin way, but this has not been implemented as yet.)</div>

<div class="standard"><a id='magicparlabel-337200' />
The differences in the code with assembly2d() can be easily identified: the pde.coeffs() and pde.rhs() functions have an extra input for the <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> values (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> represents one of the operators <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>I</mi>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, etc.). Note that <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mstyle mathvariant='bold'><mi>x</mi>
  </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math> can have vector values if desired. </div>

<div class="scrap"><a id='magicparlabel-337201' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337202' />
assembly2d-nl.m \</div>

<div class="scrap"><a id='magicparlabel-337203' />
&lt;&lt;assembly2d-nl.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337204' />
function [A,b] = assembly2d_nl(A,b,pde,elt,p,t,fht,intmethod,elt_nl,fht_nl,g_nl)</div>

<div class="scrap"><a id='magicparlabel-337205' />
% function [A,b] = assembly2d_nl(A,b,pde,elt,p,t,fht,intmethod,elt_nl,fht_nl,g_nl)</div>

<div class="scrap"><a id='magicparlabel-337206' />
% Adds the assembled matrix and vector representing the</div>

<div class="scrap"><a id='magicparlabel-337207' />
% given PDE (pde) to the A matrix &amp; b vector.</div>

<div class="scrap"><a id='magicparlabel-337208' />
% This uses a given element (elt) with the triangulation given by (p,t).</div>

<div class="scrap"><a id='magicparlabel-337209' />
% The feature hash table (fht) is used to obtain variable indexes</div>

<div class="scrap"><a id='magicparlabel-337210' />
% for given features. This is obtained by create_fht().</div>

<div class="scrap"><a id='magicparlabel-337211' />
%</div>

<div class="scrap"><a id='magicparlabel-337212' />
% A must be nv x nv and b must be nv x 1 where nv is the total</div>

<div class="scrap"><a id='magicparlabel-337213' />
% number of variables (as returned by fht_num_vars()).</div>

<div class="scrap"><a id='magicparlabel-337214' />
%</div>

<div class="scrap"><a id='magicparlabel-337215' />
% The last three inputs (elt_nl, fht_nl, g_nl) represent an additional</div>

<div class="scrap"><a id='magicparlabel-337216' />
% function defined over the triangulation (this will typically be a</div>

<div class="scrap"><a id='magicparlabel-337217' />
% solution of this or some other PDE over the same domain).</div>

<div class="scrap"><a id='magicparlabel-337218' />
% elt_nl is the element type for the additional function</div>

<div class="scrap"><a id='magicparlabel-337219' />
% fht_nl is the feature hashtable for elt_nl </div>

<div class="scrap"><a id='magicparlabel-337220' />
% g_nl is the vector where variable index i for this element has value g_nl(i)</div>

<div class="scrap"><a id='magicparlabel-337221' />
% The pde.coeffs() &amp; pde.rhs() functions will now have the interfaces</div>

<div class="scrap"><a id='magicparlabel-337222' />
% pde.coeffs(x,g_val)</div>

<div class="scrap"><a id='magicparlabel-337223' />
% pde.rhs(x,g_val)</div>

<div class="scrap"><a id='magicparlabel-337224' />
% where g_val is the (row) vector of A.g(x) values where A is one of the standard</div>

<div class="scrap"><a id='magicparlabel-337225' />
% sets of operators (see elt.get_Aphihat()).</div>

<div class="scrap"><a id='magicparlabel-337226' />
% Reference triangle has vertices (0,0), (1,0), (0,1).</div>

<div class="scrap"><a id='magicparlabel-337227' />
[p_int,w_int] = intmethod(); % points and weights for reference triangle</div>

<div class="scrap"><a id='magicparlabel-337228' />
% np is the total number of points in the triangulation</div>

<div class="scrap"><a id='magicparlabel-337229' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-337230' />
% compute nv = total number of variables</div>

<div class="scrap"><a id='magicparlabel-337231' />
nv = fht_num_vars(fht);</div>

<div class="scrap"><a id='magicparlabel-337232' />
nv_nl = fht_num_vars(fht_nl);</div>

<div class="scrap"><a id='magicparlabel-337233' />
% nv_elt is the number of variables in one element</div>

<div class="scrap"><a id='magicparlabel-337234' />
nv_elt = sum(elt.nvars);</div>

<div class="scrap"><a id='magicparlabel-337235' />
nv_nl_elt = sum(elt_nl.nvars);</div>

<div class="scrap"><a id='magicparlabel-337236' />
% order is the order of derivatives used in the assembly;</div>

<div class="scrap"><a id='magicparlabel-337237' />
% we need 0 &lt;= order &lt;= 2</div>

<div class="scrap"><a id='magicparlabel-337238' />
order = pde.order;</div>

<div class="scrap"><a id='magicparlabel-337239' />
intval1 = zeros(nv_elt,nv_elt);</div>

<div class="scrap"><a id='magicparlabel-337240' />
intval2 = zeros(nv_elt,1);</div>

<div class="scrap"><a id='magicparlabel-337241' />
% Save get_Aphihat() values for all the integration points</div>

<div class="scrap"><a id='magicparlabel-337242' />
% on the reference element</div>

<div class="scrap"><a id='magicparlabel-337243' />
Aphihatvals = cell(length(w_int),1);</div>

<div class="scrap"><a id='magicparlabel-337244' />
Aphihatvals_nl = cell(length(w_int),1);</div>

<div class="scrap"><a id='magicparlabel-337245' />
for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337246' />
    Aphihatvals{k}    = elt.get_Aphihat(p_int(k,:),order);</div>

<div class="scrap"><a id='magicparlabel-337247' />
    Aphihatvals_nl{k} = elt.get_Aphihat(p_int(k,:),order);</div>

<div class="scrap"><a id='magicparlabel-337248' />
end</div>

<div class="scrap"><a id='magicparlabel-337249' />
for i = 1:size(t,1) % for all triangles ...</div>

<div class="scrap"><a id='magicparlabel-337250' />
    % obtain variable list and signs for this triangle</div>

<div class="scrap"><a id='magicparlabel-337251' />
    [vlist,slist]       = get_var_triangle(t(i,:),fht,elt,np);</div>

<div class="scrap"><a id='magicparlabel-337252' />
    [vlist_nl,slist_nl] = get_var_triangle(t(i,:),fht_nl,elt_nl,np);</div>

<div class="scrap"><a id='magicparlabel-337253' />
    % set up affine transformation xhat :-&gt; x = T.xhat + b0</div>

<div class="scrap"><a id='magicparlabel-337254' />
    i1 = t(i,1); i2 = t(i,2); i3 = t(i,3);</div>

<div class="scrap"><a id='magicparlabel-337255' />
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];</div>

<div class="scrap"><a id='magicparlabel-337256' />
    b0 = p(i1,:)';</div>

<div class="scrap"><a id='magicparlabel-337257' />
    % form weighted sum of integrand at integration points</div>

<div class="scrap"><a id='magicparlabel-337258' />
    intval1 = 0;</div>

<div class="scrap"><a id='magicparlabel-337259' />
    intval2 = 0;</div>

<div class="scrap"><a id='magicparlabel-337260' />
    % Compute element integral</div>

<div class="scrap"><a id='magicparlabel-337261' />
    for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337262' />
        Aphival    = elt.trans_Aphihat(T,Aphihatvals{k},   order);</div>

<div class="scrap"><a id='magicparlabel-337263' />
        Aphival_nl = elt.trans_Aphihat(T,Aphihatvals_nl{k},order);</div>

<div class="scrap"><a id='magicparlabel-337264' />
        Dmat = pde.coeffs(T*p_int(k,:)'+b0, ...</div>

<div class="scrap"><a id='magicparlabel-337265' />
            (g_nl(vlist_nl).*slist_nl')'*Aphival_nl);</div>

<div class="scrap"><a id='magicparlabel-337266' />
        rhsvec = pde.rhs(T*p_int(k,:)'+b0, ...</div>

<div class="scrap"><a id='magicparlabel-337267' />
            (g_nl(vlist_nl).*slist_nl')'*Aphival_nl);</div>

<div class="scrap"><a id='magicparlabel-337268' />
        integrand_val1 = Aphival*Dmat*Aphival';</div>

<div class="scrap"><a id='magicparlabel-337269' />
        integrand_val2 = Aphival*rhsvec;</div>

<div class="scrap"><a id='magicparlabel-337270' />
        intval1 = intval1 + w_int(k)*integrand_val1;</div>

<div class="scrap"><a id='magicparlabel-337271' />
        intval2 = intval2 + w_int(k)*integrand_val2;</div>

<div class="scrap"><a id='magicparlabel-337272' />
    end</div>

<div class="scrap"><a id='magicparlabel-337273' />
    detT = abs(det(T));</div>

<div class="scrap"><a id='magicparlabel-337274' />
    intval1 = intval1*detT; % scale by Jacobian</div>

<div class="scrap"><a id='magicparlabel-337275' />
    intval2 = intval2*detT;</div>

<div class="scrap"><a id='magicparlabel-337276' />
    intval1 = diag(slist)*intval1*diag(slist); % change signs if needed</div>

<div class="scrap"><a id='magicparlabel-337277' />
    intval2 = slist'.*intval2;</div>

<div class="scrap"><a id='magicparlabel-337278' />
    A(vlist,vlist) = A(vlist,vlist) + intval1; % add to matrix &amp; vec</div>

<div class="scrap"><a id='magicparlabel-337279' />
    b(vlist)       = b(vlist) + intval2;</div>

<div class="scrap"><a id='magicparlabel-337280' />
end % for</div>

<div class="scrap"><a id='magicparlabel-337281' />
@</div>
<h3 class="subsection"><span class="subsection_label">2.3</span> <a id='magicparlabel-337282' />
<a id="sub_Boundary_assembly" />
Boundary assembly</h3>
<div class="standard"><a id='magicparlabel-337283' />
Assembling a matrix and vector using integration over the boundary, or part of it, can be useful for dealing with boundary conditions. The main difference with the other assembly routines is that we need to input the relevant boundary edges as a list of pairs of indexes into p, and to use get_edge_vars() to obtain the list of relevant variables. The integration routine intmethod() used must also be a one-dimensional integration method such as int1d_gauss5(). At the end there is some extra code to &ldquo;trim&rdquo; the matrix and vector assembled to be zero for variables not associated with the boundary.</div>

<div class="standard"><a id='magicparlabel-337284' />
There is an implicit assumption in this code that values on the boundary are not affected by variables not associated with a geometric feature of the boundary. For example, with piecewise linear elements, we need the value on an edge not to be affected by the value at the opposite vertex. This holds, as it should. </div>

<div class="scrap"><a id='magicparlabel-337285' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337286' />
assembly2dbdry.m \</div>

<div class="scrap"><a id='magicparlabel-337287' />
&lt;&lt;assembly2dbdry.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337288' />
function [A,b,bvlist] = assembly2dbdry(pde,elt,p,t,bedges,tidx,fht,intmethod)</div>

<div class="scrap"><a id='magicparlabel-337289' />
% function [A,b,bvlist] = assembly2dbdry(pde,elt,p,t,bedges,tidx,fht,intmethod)</div>

<div class="scrap"><a id='magicparlabel-337290' />
% Adds the assembled matrix and vector representing the</div>

<div class="scrap"><a id='magicparlabel-337291' />
% given PDE (pde) to the A matrix &amp; b vector.</div>

<div class="scrap"><a id='magicparlabel-337292' />
% This uses a given element (elt) with the triangulation given by (p,t,bedges,tidx)</div>

<div class="scrap"><a id='magicparlabel-337293' />
% for the boundary. Note that bedges(i,:) is in triangle t(tidx(i),:).</div>

<div class="scrap"><a id='magicparlabel-337294' />
% The feature hash table (fht) is used to obtain variable indexes</div>

<div class="scrap"><a id='magicparlabel-337295' />
% for given features. This is obtained by create_fht().</div>

<div class="scrap"><a id='magicparlabel-337296' />
%</div>

<div class="scrap"><a id='magicparlabel-337297' />
% A must be nv x nv and b must be nv x 1 where nv is the total</div>

<div class="scrap"><a id='magicparlabel-337298' />
% number of variables (as returned by fht_num_vars()).</div>

<div class="scrap"><a id='magicparlabel-337299' />
% Reference edge has vertices 0 and 1.</div>

<div class="scrap"><a id='magicparlabel-337300' />
[p_int,w_int] = intmethod(); % points and weights for reference triangle</div>

<div class="scrap"><a id='magicparlabel-337301' />
% np is the total number of points in the triangulation</div>

<div class="scrap"><a id='magicparlabel-337302' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-337303' />
% compute nv = total number of variables</div>

<div class="scrap"><a id='magicparlabel-337304' />
nv = fht_num_vars(fht);</div>

<div class="scrap"><a id='magicparlabel-337305' />
% nv_edge is the number of variables in one edge (and associated points)</div>

<div class="scrap"><a id='magicparlabel-337306' />
%nv_elt = sum(elt.nvars);</div>

<div class="scrap"><a id='magicparlabel-337307' />
nv_edge = 0;</div>

<div class="scrap"><a id='magicparlabel-337308' />
for i = 1:size(elt.flist,1)</div>

<div class="scrap"><a id='magicparlabel-337309' />
    if sum(elt.flist(i,:) ~= 0) &lt;= 2</div>

<div class="scrap"><a id='magicparlabel-337310' />
        nv_edge = nv_edge + elt.nvars(i);</div>

<div class="scrap"><a id='magicparlabel-337311' />
    end</div>

<div class="scrap"><a id='magicparlabel-337312' />
end % for</div>

<div class="scrap"><a id='magicparlabel-337313' />
% order is the order of differentiation used in the "PDE"</div>

<div class="scrap"><a id='magicparlabel-337314' />
order = pde.order;</div>

<div class="scrap"><a id='magicparlabel-337315' />
A = sparse(nv,nv);</div>

<div class="scrap"><a id='magicparlabel-337316' />
b = zeros(nv,1);</div>

<div class="scrap"><a id='magicparlabel-337317' />
bvlist = [];</div>

<div class="scrap"><a id='magicparlabel-337318' />
for i = 1:size(bedges,1) % for all boundary edges ...</div>

<div class="scrap"><a id='magicparlabel-337319' />
    % obtain variable list and signs for this triangle &amp; boundary edge</div>

<div class="scrap"><a id='magicparlabel-337320' />
    bedge = bedges(i,:);</div>

<div class="scrap"><a id='magicparlabel-337321' />
    triangle = t(tidx(i),:);</div>

<div class="scrap"><a id='magicparlabel-337322' />
    [tvlist,slist] = get_var_triangle(t(tidx(i),:),fht,elt,np);</div>

<div class="scrap"><a id='magicparlabel-337323' />
    bvlist1 = get_var_edge(bedges(i,:),fht,np);</div>

<div class="scrap"><a id='magicparlabel-337324' />
    bvlist = [bvlist,bvlist1];</div>

<div class="scrap"><a id='magicparlabel-337325' />
    match = match_edge_triangle(bedges(i,:),t(tidx(i),:));</div>

<div class="scrap"><a id='magicparlabel-337326' />
    % set up affine transformation xhat :-&gt; x = T.xhat + b0</div>

<div class="scrap"><a id='magicparlabel-337327' />
    i1 = t(tidx(i),1); i2 = t(tidx(i),2); i3 = t(tidx(i),3);</div>

<div class="scrap"><a id='magicparlabel-337328' />
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];</div>

<div class="scrap"><a id='magicparlabel-337329' />
    b0 = p(i1,:)';</div>

<div class="scrap"><a id='magicparlabel-337330' />
    % Turn p_int on the interval [0,1] to points on the appropriate</div>

<div class="scrap"><a id='magicparlabel-337331' />
    % edge of the reference triangle</div>

<div class="scrap"><a id='magicparlabel-337332' />
    p_ref = [0 0; 1 0; 0 1];</div>

<div class="scrap"><a id='magicparlabel-337333' />
    p_ref0 = p_ref(match(1),:);</div>

<div class="scrap"><a id='magicparlabel-337334' />
    p_ref1 = p_ref(match(2),:);</div>

<div class="scrap"><a id='magicparlabel-337335' />
    % form weighted sum of integrand at integration points</div>

<div class="scrap"><a id='magicparlabel-337336' />
    intval1 = zeros(length(tvlist),length(tvlist));</div>

<div class="scrap"><a id='magicparlabel-337337' />
    intval2 = zeros(length(tvlist),1);</div>

<div class="scrap"><a id='magicparlabel-337338' />
    for k = 1:length(w_int)</div>

<div class="scrap"><a id='magicparlabel-337339' />
        p_int_ref = (1-p_int(k))*p_ref0+p_int(k)*p_ref1;</div>

<div class="scrap"><a id='magicparlabel-337340' />
        % p_int_val = T*p_int_ref'+b0;</div>

<div class="scrap"><a id='magicparlabel-337341' />
        Aphivalhat = elt.get_Aphihat(p_int_ref,order);</div>

<div class="scrap"><a id='magicparlabel-337342' />
        Aphival = elt.trans_Aphihat(T,Aphivalhat,order);</div>

<div class="scrap"><a id='magicparlabel-337343' />
        Dmat = pde.coeffs(T*p_int_ref'+b0);</div>

<div class="scrap"><a id='magicparlabel-337344' />
        rhsvec = pde.rhs(T*p_int_ref'+b0);</div>

<div class="scrap"><a id='magicparlabel-337345' />
        integrand_val1 = Aphival*Dmat*Aphival';</div>

<div class="scrap"><a id='magicparlabel-337346' />
        integrand_val2 = Aphival*rhsvec;</div>

<div class="scrap"><a id='magicparlabel-337347' />
        intval1 = intval1 + w_int(k)*integrand_val1;</div>

<div class="scrap"><a id='magicparlabel-337348' />
        intval2 = intval2 + w_int(k)*integrand_val2;</div>

<div class="scrap"><a id='magicparlabel-337349' />
    end</div>

<div class="scrap"><a id='magicparlabel-337350' />
    detT = norm(p(t(tidx(i),match(1)),:)-p(t(tidx(i),match(2)),:),2);</div>

<div class="scrap"><a id='magicparlabel-337351' />
    intval1 = intval1*detT;</div>

<div class="scrap"><a id='magicparlabel-337352' />
    intval2 = intval2*detT;</div>

<div class="scrap"><a id='magicparlabel-337353' />
    intval1 = diag(slist)*intval1*diag(slist); % change signs if needed</div>

<div class="scrap"><a id='magicparlabel-337354' />
    intval2 = slist'.*intval2;</div>

<div class="scrap"><a id='magicparlabel-337355' />
    A(tvlist,tvlist) = A(tvlist,tvlist) + intval1; % add to matrix &amp; vec</div>

<div class="scrap"><a id='magicparlabel-337356' />
    b(tvlist)        = b(tvlist) + intval2;</div>

<div class="scrap"><a id='magicparlabel-337357' />
end</div>

<div class="scrap"><a id='magicparlabel-337358' />
bvlist = unique(sort(bvlist));</div>

<div class="scrap"><a id='magicparlabel-337359' />
v_array = ones(nv,1);</div>

<div class="scrap"><a id='magicparlabel-337360' />
v_array(bvlist) = 0;</div>

<div class="scrap"><a id='magicparlabel-337361' />
cbvlist = find(v_array ~= 0);</div>

<div class="scrap"><a id='magicparlabel-337362' />
Ab(cbvlist,:) = 0;</div>

<div class="scrap"><a id='magicparlabel-337363' />
Ab(:,cbvlist) = 0;</div>

<div class="scrap"><a id='magicparlabel-337364' />
b(cbvlist) = 0;</div>

<div class="scrap"><a id='magicparlabel-337365' />
@</div>
<h2 class="section"><span class="section_label">3</span> <a id='magicparlabel-337366' />
<a id="sec_Handling_geometric_features" />
Handling geometric features</h2>
<div class="standard"><a id='magicparlabel-337367' />
Geometric features are triangles, edges, and points (vertices) of the triangulation. Each variable is associated with a single geometric feature: if several seem possible, then we choose the one of lowest dimension. For example, if we use a piecewise linear finite element space over a given triangulation, then each variable is associated with a vertex of a triangle in the triangulation. Then each vertex has one variable whose value is the same for all the triangles sharing that vertex. This ensures that at any edge shared between two triangles, the value of a piecewise linear function is the same at the ends of the edge and so is the same along the entire edge. This ensures continuity of the piecewise linear function.</div>

<div class="standard"><a id='magicparlabel-337368' />
A function in the piecewise linear finite element space will have the form<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>v</mi>
    </mrow>
    <mrow><mi>h</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msubsup>
    <mrow><mo> &sum; </mo>
    </mrow>
    <mrow>
     <mrow><mi>i</mi><mo>=</mo><mn>1</mn>
     </mrow>
    </mrow>
    <mrow><mi>N</mi>
    </mrow>
   </msubsup>
   <msub>
    <mrow><mi>v</mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mspace width="6px" />
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>v</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> are the values associated with the vertices of the triangulation; for each triangle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math> in the triangulation, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo>|</mo><mi>K</mi>
  </mrow>
 </mrow></math> is a linear (actually, affine) function. When we assemble the part of a matrix for triangle <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math>, we need to ensure that the same <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>v</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> is used. To do this, we have a list of all the variables (in order) associated with a given vertex. </div>

<div class="standard"><a id='magicparlabel-337369' />
Similarly, for a quadratic Lagrange basis, we typically use a nodal basis using values at the vertices of a triangle, and the values at the midpoints of the edges of the triangle. A function in the finite element space generated by these nodal basis functions must have the same values at every point on an edge shared between two elements. It is sufficient if the values at the shared vertices and shared edge's midpoint are equal: two quadratic functions of one variable that are equal at three points must be the same. The basis functions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi> &phi; </mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> have an associated value or variable <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>v</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> for representing a function in the finite element space<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mi>v</mi>
    </mrow>
    <mrow><mi>h</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>=</mo>
   <msubsup>
    <mrow><mo> &sum; </mo>
    </mrow>
    <mrow>
     <mrow><mi>i</mi><mo>=</mo><mn>1</mn>
     </mrow>
    </mrow>
    <mrow><mi>N</mi>
    </mrow>
   </msubsup>
   <msub>
    <mrow><mi>v</mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mspace width="6px" />
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mn>.</mn>
  </mrow>
 </mrow></math>If <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi> &phi; </mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> is a nodal basis function for a vertex then <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow><mi>v</mi>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> is associated with that vertex; if it is associated with a midpoint of an edge, it is associated with that edge. </div>

<div class="standard"><a id='magicparlabel-337370' />
For a cubic Lagrange basis, we use a nodal basis using values at the vertices, values at points along each edge at the 1/3 and 2/3 positions, and one at the centroid of the triangle. This time there is one variables associated with each vertex, one with each triangle, but two with each edge. It is important to distinguish between the two variables associated with a given edge, because they correspond to different basis functions. </div>
<h3 class="subsection"><span class="subsection_label">3.1</span> <a id='magicparlabel-337371' />
<a id="sub_Feature_hash_tables" />
Feature hash tables</h3>
<div class="standard"><a id='magicparlabel-337372' />
Each geometric feature then has an associated ordered list of variables. To store these we use a hash table. Matlab's container.Map, however, allows only string or integer keys, so we need to convert a feature (given as a list of indexes into the p array) into an integer. This is done as follows:</div>

<div class="scrap"><a id='magicparlabel-337373' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337374' />
get-feature-ref.m \</div>

<div class="scrap"><a id='magicparlabel-337375' />
&lt;&lt;get-feature-ref.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337376' />
function ref = get_feature_ref(f,np)</div>

<div class="scrap"><a id='magicparlabel-337377' />
% function ref = get_feature_ref(f,np)</div>

<div class="scrap"><a id='magicparlabel-337378' />
%</div>

<div class="scrap"><a id='magicparlabel-337379' />
% Return a unique integer for the given feature, for</div>

<div class="scrap"><a id='magicparlabel-337380' />
% use in the feature hashtable.</div>

<div class="scrap"><a id='magicparlabel-337381' />
% np is the number of points in the triangulation.</div>

<div class="scrap"><a id='magicparlabel-337382' />
ref = sum(int64(f) .* int64(np).^int64(0:length(f)-1));</div>

<div class="scrap"><a id='magicparlabel-337383' />
end</div>

<div class="scrap"><a id='magicparlabel-337384' />
@</div>

<div class="standard"><a id='magicparlabel-337385' />
From the triangulation and the element type we can create the entire hash table (see <em>create-fht.m</em>). Note that we need certain information from the element type (elt): elt.flist is a list of geometric features to which variables are associated for the reference element. Note that these are lists of integers in the set <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>{</mo>
  <mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>}</mo>
 </mrow></math>; these integers refer to the vertices of the reference element: vertex 1 is <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mn>0</mn><mo>,</mo><mn>0</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>, vertex 2 is <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mn>1</mn><mo>,</mo><mn>0</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>, and vertex 3 is <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mn>0</mn><mo>,</mo><mn>1</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>. The number of variables associated with the feature elt.flist(i,:) is elt.nvars(i). For more details, see Section&nbsp;<a href="#sec_Element_types">4</a>. Variables are numbered sequentially as they are discovered. Note that if a geometric feature has already been found, then it is skipped.</div>

<div class="scrap"><a id='magicparlabel-337386' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337387' />
create-fht.m \</div>

<div class="scrap"><a id='magicparlabel-337388' />
&lt;&lt;create-fht.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337389' />
function [fht,v2fref,v2fidx] = create_fht(p,t,elt)</div>

<div class="scrap"><a id='magicparlabel-337390' />
% function [fht,v2fref,v2fidx] = create_fht(p,t,elt)</div>

<div class="scrap"><a id='magicparlabel-337391' />
%</div>

<div class="scrap"><a id='magicparlabel-337392' />
% Create feature hash table (fht) which shows what variables</div>

<div class="scrap"><a id='magicparlabel-337393' />
% are associated with which geometric features.</div>

<div class="scrap"><a id='magicparlabel-337394' />
% The geometric features inserted into fht must be</div>

<div class="scrap"><a id='magicparlabel-337395' />
% in normalized form (that is, a sorted vector of point indexes).</div>

<div class="scrap"><a id='magicparlabel-337396' />
%</div>

<div class="scrap"><a id='magicparlabel-337397' />
% This routine also returns a variable to feature ref array (v2fref)</div>

<div class="scrap"><a id='magicparlabel-337398' />
% where variable with index i is associated with feature with </div>

<div class="scrap"><a id='magicparlabel-337399' />
% reference number v2fref(i).</div>

<div class="scrap"><a id='magicparlabel-337400' />
fht = containers.Map('KeyType','int64','ValueType','any');</div>

<div class="scrap"><a id='magicparlabel-337401' />
nvars = elt.nvars;</div>

<div class="scrap"><a id='magicparlabel-337402' />
flist = elt.flist; % list of features with associated variables</div>

<div class="scrap"><a id='magicparlabel-337403' />
v2fref = [];</div>

<div class="scrap"><a id='magicparlabel-337404' />
v2fidx = [];</div>

<div class="scrap"><a id='magicparlabel-337405' />
% flist is assumed normalized except for trailing zeros</div>

<div class="scrap"><a id='magicparlabel-337406' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-337407' />
counter = 0;</div>

<div class="scrap"><a id='magicparlabel-337408' />
for i = 1:size(t,1) % for each triangle ...</div>

<div class="scrap"><a id='magicparlabel-337409' />
    triangle = [0, t(i,:)];</div>

<div class="scrap"><a id='magicparlabel-337410' />
    tflist = triangle(flist+1);</div>

<div class="scrap"><a id='magicparlabel-337411' />
    for j = 1:size(flist,1)</div>

<div class="scrap"><a id='magicparlabel-337412' />
        % for each feature ...</div>

<div class="scrap"><a id='magicparlabel-337413' />
        f = tflist(j,:);</div>

<div class="scrap"><a id='magicparlabel-337414' />
        f = f(find(f ~= 0));</div>

<div class="scrap"><a id='magicparlabel-337415' />
        f = sort(f);</div>

<div class="scrap"><a id='magicparlabel-337416' />
        % Is this feature already in fht? If not add its variables.</div>

<div class="scrap"><a id='magicparlabel-337417' />
        ref = get_feature_ref(f,np);</div>

<div class="scrap"><a id='magicparlabel-337418' />
        if ~ isKey(fht,ref)</div>

<div class="scrap"><a id='magicparlabel-337419' />
            fht(ref) = [(counter+1):(counter + nvars(j))];</div>

<div class="scrap"><a id='magicparlabel-337420' />
            counter = counter + nvars(j);</div>

<div class="scrap"><a id='magicparlabel-337421' />
            v2fref = [v2fref, ref*ones(1,nvars(j))];</div>

<div class="scrap"><a id='magicparlabel-337422' />
            v2fidx = [v2fidx, 1:nvars(j)];</div>

<div class="scrap"><a id='magicparlabel-337423' />
        end</div>

<div class="scrap"><a id='magicparlabel-337424' />
    end % for each feature</div>

<div class="scrap"><a id='magicparlabel-337425' />
    size_fht = size(fht);</div>

<div class="scrap"><a id='magicparlabel-337426' />
end % for each triangle</div>

<div class="scrap"><a id='magicparlabel-337427' />
end % function create_fht</div>

<div class="scrap"><a id='magicparlabel-337428' />
@</div>

<div class="standard"><a id='magicparlabel-337429' />
Using the feature hash table (fht) can be done through a number of functions; the main one (used by the assembly functions) is get_var_triangle(). This finds all variables associated with any geometric feature (triangle, edge, vertex) of the triangle. This triangle is represented as a triple of indexes into the p array. </div>

<div class="scrap"><a id='magicparlabel-337430' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337431' />
get-var-triangle.m \</div>

<div class="scrap"><a id='magicparlabel-337432' />
&lt;&lt;get-var-triangle.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337433' />
function [vlist,slist] = get_var_triangle(tri,fht,elt,np)</div>

<div class="scrap"><a id='magicparlabel-337434' />
% function [vlist,slist] = get_var_triangle(tri,fht,elt,np)</div>

<div class="scrap"><a id='magicparlabel-337435' />
%</div>

<div class="scrap"><a id='magicparlabel-337436' />
% Get the list of variables (vlist) and the list of sign changes (slist)</div>

<div class="scrap"><a id='magicparlabel-337437' />
% for a given triangle tri using the feature ahstable (fht) for</div>

<div class="scrap"><a id='magicparlabel-337438' />
% the given element type (see elt data structure).</div>

<div class="scrap"><a id='magicparlabel-337439' />
% Note that np is the number of points.</div>

<div class="scrap"><a id='magicparlabel-337440' />
%</div>

<div class="scrap"><a id='magicparlabel-337441' />
% tri is a 1 x 3 array of indexes into the p array of points in the</div>

<div class="scrap"><a id='magicparlabel-337442' />
% triangulation</div>

<div class="scrap"><a id='magicparlabel-337443' />
tri2 = [0,tri];</div>

<div class="scrap"><a id='magicparlabel-337444' />
flist = elt.flist;</div>

<div class="scrap"><a id='magicparlabel-337445' />
flist = tri2(flist+1); % use point indexes</div>

<div class="scrap"><a id='magicparlabel-337446' />
vlist = [];</div>

<div class="scrap"><a id='magicparlabel-337447' />
slist = [];</div>

<div class="scrap"><a id='magicparlabel-337448' />
for i = 1:size(flist,1) % for each feature</div>

<div class="scrap"><a id='magicparlabel-337449' />
f = flist(i,:);</div>

<div class="scrap"><a id='magicparlabel-337450' />
f = f(find(f ~= 0)); % strip zeros from f</div>

<div class="scrap"><a id='magicparlabel-337451' />
[fn,px] = sort(f); % normalize f: fn(px) == f</div>

<div class="scrap"><a id='magicparlabel-337452' />
ref = get_feature_ref(fn,np);</div>

<div class="scrap"><a id='magicparlabel-337453' />
if ~ isKey(fht,ref)</div>

<div class="scrap"><a id='magicparlabel-337454' />
    error('PDE_FE:missing value','get_var_triangle: Missing feature',fn,ref)</div>

<div class="scrap"><a id='magicparlabel-337455' />
return</div>

<div class="scrap"><a id='magicparlabel-337456' />
else</div>

<div class="scrap"><a id='magicparlabel-337457' />
    fvlist = fht(ref);</div>

<div class="scrap"><a id='magicparlabel-337458' />
    [pxvars,fslist] = elt.pxfeature(px);</div>

<div class="scrap"><a id='magicparlabel-337459' />
    fvlist = fvlist(pxvars);</div>

<div class="scrap"><a id='magicparlabel-337460' />
end</div>

<div class="scrap"><a id='magicparlabel-337461' />
% concatenate the list of variable indexes &amp; signs</div>

<div class="scrap"><a id='magicparlabel-337462' />
vlist = [vlist,fvlist];</div>

<div class="scrap"><a id='magicparlabel-337463' />
slist = [slist,fslist];</div>

<div class="scrap"><a id='magicparlabel-337464' />
end</div>

<div class="scrap"><a id='magicparlabel-337465' />
@</div>

<div class="standard"><a id='magicparlabel-337466' />
For performing boundary integrals we use the corresponding function for edges:</div>

<div class="scrap"><a id='magicparlabel-337467' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337468' />
get-var-edge.m \</div>

<div class="scrap"><a id='magicparlabel-337469' />
&lt;&lt;get-var-edge.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337470' />
function [vlist] = get_var_edge(edge,fht,np)</div>

<div class="scrap"><a id='magicparlabel-337471' />
% function [vlist] = get_var_edge(edge,fht,np)</div>

<div class="scrap"><a id='magicparlabel-337472' />
%</div>

<div class="scrap"><a id='magicparlabel-337473' />
% Returns list of variable indexes for given edge (including end-point</div>

<div class="scrap"><a id='magicparlabel-337474' />
% variables). The feature hash table (fht) is used to look up variable</div>

<div class="scrap"><a id='magicparlabel-337475' />
% lists. Also np is the number of points in the triangulation.</div>

<div class="scrap"><a id='magicparlabel-337476' />
vlist = [];</div>

<div class="scrap"><a id='magicparlabel-337477' />
ref = get_feature_ref(sort(edge),np);</div>

<div class="scrap"><a id='magicparlabel-337478' />
if isKey(fht,ref)</div>

<div class="scrap"><a id='magicparlabel-337479' />
    vlist = [vlist, fht(ref)];</div>

<div class="scrap"><a id='magicparlabel-337480' />
end</div>

<div class="scrap"><a id='magicparlabel-337481' />
ref = get_feature_ref(edge(1),np);</div>

<div class="scrap"><a id='magicparlabel-337482' />
if isKey(fht,ref)</div>

<div class="scrap"><a id='magicparlabel-337483' />
    vlist = [vlist, fht(ref)];</div>

<div class="scrap"><a id='magicparlabel-337484' />
end</div>

<div class="scrap"><a id='magicparlabel-337485' />
ref = get_feature_ref(edge(2),np);</div>

<div class="scrap"><a id='magicparlabel-337486' />
if isKey(fht,ref)</div>

<div class="scrap"><a id='magicparlabel-337487' />
    vlist = [vlist, fht(ref)];</div>

<div class="scrap"><a id='magicparlabel-337488' />
end</div>

<div class="scrap"><a id='magicparlabel-337489' />
@</div>

<div class="standard"><a id='magicparlabel-337490' />
The total number of variables can be found using the following routine, which simply adds the lengths of all the lists of variables in fht. Note that this assumes that every variable is associated with exactly one geometric feature.</div>

<div class="scrap"><a id='magicparlabel-337491' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337492' />
fht-num-vars.m \</div>

<div class="scrap"><a id='magicparlabel-337493' />
&lt;&lt;fht-num-vars.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337494' />
function nvars = fht_num_vars(fht)</div>

<div class="scrap"><a id='magicparlabel-337495' />
% function nvars = fht_num_vars(fht)</div>

<div class="scrap"><a id='magicparlabel-337496' />
%</div>

<div class="scrap"><a id='magicparlabel-337497' />
% Returns the total number of variables for a discretization</div>

<div class="scrap"><a id='magicparlabel-337498' />
% based on the feature hash table (fht), which stores</div>

<div class="scrap"><a id='magicparlabel-337499' />
% variable index lists for each geometric feature.</div>

<div class="scrap"><a id='magicparlabel-337500' />
nvars = 0;</div>

<div class="scrap"><a id='magicparlabel-337501' />
vals = values(fht);</div>

<div class="scrap"><a id='magicparlabel-337502' />
for i = 1:length(vals)</div>

<div class="scrap"><a id='magicparlabel-337503' />
    nvars = nvars + length(vals{i});</div>

<div class="scrap"><a id='magicparlabel-337504' />
end</div>

<div class="scrap"><a id='magicparlabel-337505' />
end</div>

<div class="scrap"><a id='magicparlabel-337506' />
@</div>
<h3 class="subsection"><span class="subsection_label">3.2</span> <a id='magicparlabel-337507' />
<a id="sub_Geometric_utilities" />
Geometric utilities</h3>
<h4 class="subsubsection"><span class="subsubsection_label">3.2.1</span> <a id='magicparlabel-337508' />
Find boundary</h4>
<div class="standard"><a id='magicparlabel-337509' />
Finding boundary edges can be done directly from the t array: a boundary edge is an edge of exactly one triangle. The basic code is here:</div>

<div class="scrap"><a id='magicparlabel-337510' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337511' />
boundary2d.m \</div>

<div class="scrap"><a id='magicparlabel-337512' />
&lt;&lt;boundary2d.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337513' />
function [bedges,bnodes,t_index] = boundary2d(t)</div>

<div class="scrap"><a id='magicparlabel-337514' />
% function [bedges,bnodes,t_index] = boundary2d(t)</div>

<div class="scrap"><a id='magicparlabel-337515' />
%</div>

<div class="scrap"><a id='magicparlabel-337516' />
% Construct boundary edge list from triangle list t</div>

<div class="scrap"><a id='magicparlabel-337517' />
% t is ntriangles x 3, bedges = nedges x 2</div>

<div class="scrap"><a id='magicparlabel-337518' />
% Edge k joins points bd(k,1) and bd(k,2).</div>

<div class="scrap"><a id='magicparlabel-337519' />
%</div>

<div class="scrap"><a id='magicparlabel-337520' />
% Simply check when edges only appear once in the triangle list.</div>

<div class="scrap"><a id='magicparlabel-337521' />
%</div>

<div class="scrap"><a id='magicparlabel-337522' />
% Also returns the triangle index for each boundary edge</div>

<div class="scrap"><a id='magicparlabel-337523' />
t = sort(t,2); % sort each row of t</div>

<div class="scrap"><a id='magicparlabel-337524' />
bd1 = sortrows([t(:,1),t(:,2),(1:size(t,1))';</div>

<div class="scrap"><a id='magicparlabel-337525' />
                t(:,2),t(:,3),(1:size(t,1))';</div>

<div class="scrap"><a id='magicparlabel-337526' />
                t(:,1),t(:,3),(1:size(t,1))']);</div>

<div class="scrap"><a id='magicparlabel-337527' />
[bd2,idx1] = unique(bd1(:,1:2),'rows','first');</div>

<div class="scrap"><a id='magicparlabel-337528' />
[bd2,idx2] = unique(bd1(:,1:2),'rows','last');</div>

<div class="scrap"><a id='magicparlabel-337529' />
eqlist = find(idx1 == idx2);</div>

<div class="scrap"><a id='magicparlabel-337530' />
bedges = bd1(idx1(eqlist),1:2);</div>

<div class="scrap"><a id='magicparlabel-337531' />
t_index = bd1(idx1(eqlist),3);</div>

<div class="scrap"><a id='magicparlabel-337532' />
bedges2 = bd2(eqlist,:);</div>

<div class="scrap"><a id='magicparlabel-337533' />
bnodes = unique(sort(bedges(:)));</div>

<div class="scrap"><a id='magicparlabel-337534' />
@</div>

<div class="standard"><a id='magicparlabel-337535' />
Note that this routine also returns bnodes, a list of all vertices in the boundary, and t_index where t_index(i) is the row index into t for the edge bedges(i,:). </div>
<h4 class="subsubsection"><span class="subsubsection_label">3.2.2</span> <a id='magicparlabel-337536' />
Matching edges to triangles</h4>
<div class="standard"><a id='magicparlabel-337537' />
This returns a two-integer vector matching a single given edge to a single given triangle. It is assumed that the edge is an edge of the triangle. All objects given as lists of indexes into p.</div>

<div class="scrap"><a id='magicparlabel-337538' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337539' />
match-edge-triangle.m \</div>

<div class="scrap"><a id='magicparlabel-337540' />
&lt;&lt;match-edge-triangle.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337541' />
function match = match_edge_triangle(edge,triangle)</div>

<div class="scrap"><a id='magicparlabel-337542' />
% function match = match_edge_triangle(edge,triangle)</div>

<div class="scrap"><a id='magicparlabel-337543' />
%</div>

<div class="scrap"><a id='magicparlabel-337544' />
% Returns index vector (2 elements) match so that</div>

<div class="scrap"><a id='magicparlabel-337545' />
% edge(i) = triangle(match(i)), i = 1, 2.</div>

<div class="scrap"><a id='magicparlabel-337546' />
for i = 1:2</div>

<div class="scrap"><a id='magicparlabel-337547' />
    for j = 1:3</div>

<div class="scrap"><a id='magicparlabel-337548' />
        if edge(i) == triangle(j)</div>

<div class="scrap"><a id='magicparlabel-337549' />
            match(i) = j;</div>

<div class="scrap"><a id='magicparlabel-337550' />
        end</div>

<div class="scrap"><a id='magicparlabel-337551' />
    end % for j</div>

<div class="scrap"><a id='magicparlabel-337552' />
end % for i</div>

<div class="scrap"><a id='magicparlabel-337553' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337554' />
@</div>
<h2 class="section"><span class="section_label">4</span> <a id='magicparlabel-337555' />
<a id="sec_Element_types" />
Element types</h2>
<div class="standard"><a id='magicparlabel-337556' />
Each element type is represented by a corresponding data structure. An element type must provide the basis functions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mover>
     <mrow><mi> &phi; </mi>
     </mrow><mo stretchy="true">&Hat;</mo>
    </mover>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> on the reference element and the various functions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> for <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mo>=</mo><mi>I</mi>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi> &part; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub>
  </mrow>
 </mrow></math> etc., and it must also provide the information as to which basis functions <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mover>
     <mrow><mi> &phi; </mi>
     </mrow><mo stretchy="true">&Hat;</mo>
    </mover>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> are associated with which geometric feature. The reference element has the basis functions ordered in a specific way. For a real element <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math>, there must be an identification of the geometric features (triangle, edges, vertices) of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>K</mi>
 </mrow></math> with the corresponding geometric features of the reference element <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mover>
   <mrow><mi>K</mi>
   </mrow><mo stretchy="true">&Hat;</mo>
  </mover>
 </mrow></math>.</div>
<h3 class="subsection"><span class="subsection_label">4.1</span> <a id='magicparlabel-337557' />
<a id="sub_Piecewise_linear_elements" />
Piecewise linear elements</h3>
<div class="standard"><a id='magicparlabel-337558' />
First we consider piecewise linear elements. The main function called is lin2d_elt(). It creates a structure which contains the other routines needed to properly define the element type.</div>

<div class="scrap"><a id='magicparlabel-337559' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337560' />
lin2d-elt.m \</div>

<div class="scrap"><a id='magicparlabel-337561' />
&lt;&lt;lin2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337562' />
function elt = lin2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337563' />
% function elt = lin2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337564' />
%</div>

<div class="scrap"><a id='magicparlabel-337565' />
% Returns the linear 2-D (3-point) element data structure.</div>

<div class="scrap"><a id='magicparlabel-337566' />
[nvars,flist] = lin2d_get_nvars();</div>

<div class="scrap"><a id='magicparlabel-337567' />
elt = struct('get_Aphihat',@lin2d_get_Aphihat, ...</div>

<div class="scrap"><a id='magicparlabel-337568' />
    'nvars',nvars,'flist',flist, ...</div>

<div class="scrap"><a id='magicparlabel-337569' />
    'pxfeature',@lin2d_pxfeature,'vnodes',lin2d_vnodes(), ...</div>

<div class="scrap"><a id='magicparlabel-337570' />
    'trans_Aphihat',@trans2d_Aphilist);</div>

<div class="scrap"><a id='magicparlabel-337571' />
end</div>

<div class="scrap"><a id='magicparlabel-337572' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.1.1</span> <a id='magicparlabel-337573' />
Piecewise linear elements: get_Aphihat()</h4>
<div class="standard"><a id='magicparlabel-337574' />
The first component of the structure is get_Aphihat, which is set to be the function lin2d_get_Aphihat(). This computes <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi>
   <msub>
    <mrow>
     <mover>
      <mrow><mi> &phi; </mi>
      </mrow><mo stretchy="true">&Hat;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> for <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mspace width="6px" /><mn>2</mn><mo>,</mo><mspace width="6px" />
   <mi>&hellip;
   </mi><mo>,</mo><mspace width="6px" /><mi>M</mi>
  </mrow>
 </mrow></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>M</mi>
 </mrow></math> is the number of basis functions for the reference element:</div>

<div class="scrap"><a id='magicparlabel-337575' />
&lt;&lt;lin2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337576' />
function Aphilist = lin2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337577' />
% Aphilist = lin2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337578' />
%</div>

<div class="scrap"><a id='magicparlabel-337579' />
% Returns array of basis function values, their gradient and Hessian entries</div>

<div class="scrap"><a id='magicparlabel-337580' />
% for linear (affine) basis functions on a 2-D reference triangle at xhat.</div>

<div class="scrap"><a id='magicparlabel-337581' />
% The vertices of the reference triangle are (0,0), (1,0), and (0,1).</div>

<div class="scrap"><a id='magicparlabel-337582' />
% Aphilist(i,j) is the value of the j'th operator on phi_i at xhat.</div>

<div class="scrap"><a id='magicparlabel-337583' />
% Here phi_i is the affine function where phi_i(xhat_j) == 1</div>

<div class="scrap"><a id='magicparlabel-337584' />
% if i == j, and zero otherwise; xhat_i is the i'th vertex listed above.</div>

<div class="scrap"><a id='magicparlabel-337585' />
%</div>

<div class="scrap"><a id='magicparlabel-337586' />
% Order of operators: Aphi(xhat) = phi(xhat), d/dx1 phi(xhat),</div>

<div class="scrap"><a id='magicparlabel-337587' />
% d/dx2 phi(xhat), d^2/dx1^2 phi(xhat), d^2/dx1.dx2 phi(xhat),</div>

<div class="scrap"><a id='magicparlabel-337588' />
% d^2/dx2^2 phi(xhat).  Note that x1 = x and x2 = y.</div>

<div class="scrap"><a id='magicparlabel-337589' />
x = xhat(1);  y = xhat(2);</div>

<div class="scrap"><a id='magicparlabel-337590' />
% Basis function values</div>

<div class="scrap"><a id='magicparlabel-337591' />
Aphilist0 = [1-x-y; </div>

<div class="scrap"><a id='magicparlabel-337592' />
             x; </div>

<div class="scrap"><a id='magicparlabel-337593' />
             y];</div>

<div class="scrap"><a id='magicparlabel-337594' />
if order &gt;= 1</div>

<div class="scrap"><a id='magicparlabel-337595' />
    % Basis gradient values (along rows)</div>

<div class="scrap"><a id='magicparlabel-337596' />
    Aphilist1 = [-1 -1;</div>

<div class="scrap"><a id='magicparlabel-337597' />
                  1  0;</div>

<div class="scrap"><a id='magicparlabel-337598' />
                  0  1];</div>

<div class="scrap"><a id='magicparlabel-337599' />
end</div>

<div class="scrap"><a id='magicparlabel-337600' />
if order &gt;= 2</div>

<div class="scrap"><a id='magicparlabel-337601' />
    % Basis hessian values (along rows: dx1^2, dx1.dx2, dx2^2)</div>

<div class="scrap"><a id='magicparlabel-337602' />
    Aphilist2 = [0 0 0;</div>

<div class="scrap"><a id='magicparlabel-337603' />
                 0 0 0;</div>

<div class="scrap"><a id='magicparlabel-337604' />
                 0 0 0];</div>

<div class="scrap"><a id='magicparlabel-337605' />
end</div>

<div class="scrap"><a id='magicparlabel-337606' />
if order == 0</div>

<div class="scrap"><a id='magicparlabel-337607' />
    Aphilist = Aphilist0;</div>

<div class="scrap"><a id='magicparlabel-337608' />
elseif order == 1</div>

<div class="scrap"><a id='magicparlabel-337609' />
    Aphilist = [Aphilist0,Aphilist1];</div>

<div class="scrap"><a id='magicparlabel-337610' />
elseif order == 2</div>

<div class="scrap"><a id='magicparlabel-337611' />
    Aphilist = [Aphilist0,Aphilist1,Aphilist2];</div>

<div class="scrap"><a id='magicparlabel-337612' />
end</div>

<div class="scrap"><a id='magicparlabel-337613' />
@</div>

<div class="standard"><a id='magicparlabel-337614' />
This is the main workhorse of the element type; it is the function that is called the most of all of the functions in the structure.</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.1.2</span> <a id='magicparlabel-337615' />
Piecewise linear elements: get_nvars()</h4>
<div class="standard"><a id='magicparlabel-337616' />
In order to match up geometric features with variables, we need lin2d_get_nvars(). In the case of piecewise linear basis functions, the geometric features used are the vertices of the triangle, and there is one variable for each vertex.</div>

<div class="scrap"><a id='magicparlabel-337617' />
&lt;&lt;lin2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337618' />
function [nvars,flist] = lin2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-337619' />
% function [nvars,flist] = lin2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-337620' />
%</div>

<div class="scrap"><a id='magicparlabel-337621' />
% Returns list of number of variables per feature in flist (nvars).</div>

<div class="scrap"><a id='magicparlabel-337622' />
% flist is the list of features (m x 3 integer array) associated with </div>

<div class="scrap"><a id='magicparlabel-337623' />
% the corresponding variable</div>

<div class="scrap"><a id='magicparlabel-337624' />
nvars = [1;1;1];</div>

<div class="scrap"><a id='magicparlabel-337625' />
flist = [1 0 0;</div>

<div class="scrap"><a id='magicparlabel-337626' />
         2 0 0;</div>

<div class="scrap"><a id='magicparlabel-337627' />
         3 0 0]; % the three vertices</div>

<div class="scrap"><a id='magicparlabel-337628' />
end</div>

<div class="scrap"><a id='magicparlabel-337629' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.1.3</span> <a id='magicparlabel-337630' />
Piecewise linear elements: pxfeature()</h4>
<div class="standard"><a id='magicparlabel-337631' />
In addition, when a geometric feature is found as part of some element, the orientation of the element may result in certain variables being permuted. In the case of piecewise linear elements, the geometric features are vertices, which do not have an orientation. Consequently this code is essentially trivial. This component of the element type structure becomes important for certain other more complex elements.</div>

<div class="scrap"><a id='magicparlabel-337632' />
&lt;&lt;lin2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337633' />
function [px_vars,signs] = lin2d_pxfeature(px)</div>

<div class="scrap"><a id='magicparlabel-337634' />
% function [px_vars,signs] = lin2d_pxfeature(px)</div>

<div class="scrap"><a id='magicparlabel-337635' />
%</div>

<div class="scrap"><a id='magicparlabel-337636' />
% Returns the permutation of the variables (px_vars),</div>

<div class="scrap"><a id='magicparlabel-337637' />
% and the sign changes (signs) resulting from a permutation (px)</div>

<div class="scrap"><a id='magicparlabel-337638' />
% applied to a feature of the appropriate dimension (== length(px)).</div>

<div class="scrap"><a id='magicparlabel-337639' />
% This is for the linear (or affine) 2-D triangle elements.</div>

<div class="scrap"><a id='magicparlabel-337640' />
dimp1 = sum(px ~= 0);  % dimp1 == dimension plus 1</div>

<div class="scrap"><a id='magicparlabel-337641' />
switch dimp1</div>

<div class="scrap"><a id='magicparlabel-337642' />
    case 1 % points</div>

<div class="scrap"><a id='magicparlabel-337643' />
        px_vars = [1]; signs = [1];</div>

<div class="scrap"><a id='magicparlabel-337644' />
    otherwise % not a valid feature</div>

<div class="scrap"><a id='magicparlabel-337645' />
        px_vars = []; signs = [];</div>

<div class="scrap"><a id='magicparlabel-337646' />
    end</div>

<div class="scrap"><a id='magicparlabel-337647' />
end % switch</div>

<div class="scrap"><a id='magicparlabel-337648' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337649' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.1.4</span> <a id='magicparlabel-337650' />
Piecewise linear elements: vnodes()</h4>
<div class="standard"><a id='magicparlabel-337651' />
The next component is lin2d_vnodes(), although it is not essential. This gives the nodal points in a reference triangle for the basis functions.</div>

<div class="scrap"><a id='magicparlabel-337652' />
&lt;&lt;lin2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337653' />
function vnodes = lin2d_vnodes()</div>

<div class="scrap"><a id='magicparlabel-337654' />
% function vnodes = lin2d_vnodes()</div>

<div class="scrap"><a id='magicparlabel-337655' />
% </div>

<div class="scrap"><a id='magicparlabel-337656' />
% Returns the positions of the variable nodes</div>

<div class="scrap"><a id='magicparlabel-337657' />
% with respect to the reference element.</div>

<div class="scrap"><a id='magicparlabel-337658' />
% Same format as p (2 x m)</div>

<div class="scrap"><a id='magicparlabel-337659' />
vnodes = [0 0;</div>

<div class="scrap"><a id='magicparlabel-337660' />
          1 0;</div>

<div class="scrap"><a id='magicparlabel-337661' />
          0 1];</div>

<div class="scrap"><a id='magicparlabel-337662' />
end</div>

<div class="scrap"><a id='magicparlabel-337663' />
@</div>
<h3 class="subsection"><span class="subsection_label">4.2</span> <a id='magicparlabel-337664' />
<a id="sub_Transformation_scalar_Lagrange_elements" />
Transformation routines: scalar Lagrange elements</h3>
<div class="standard"><a id='magicparlabel-337665' />
The last component is the transformation routine to transform the basis functions and their derivatives from the reference triangle to a given real triangle where the map <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover>
   <mrow><mo> mapstochar </mo><mo> &rarr; </mo>
   </mrow>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo>=</mo>
   <msub>
    <mrow><mi>T</mi>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo>+</mo>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>b</mi>
     </mstyle>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>:</div>

<div class="scrap"><a id='magicparlabel-337666' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337667' />
trans2d-Aphilist.m \</div>

<div class="scrap"><a id='magicparlabel-337668' />
&lt;&lt;trans2d-Aphilist.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337669' />
function Aphilist2 = trans2d_Aphilist(T,Aphilist,order)</div>

<div class="scrap"><a id='magicparlabel-337670' />
% function Aphilist2 = trans2d_Aphilist(T,Aphilist,order)</div>

<div class="scrap"><a id='magicparlabel-337671' />
%</div>

<div class="scrap"><a id='magicparlabel-337672' />
% Transforms Aphilist into Aphilist2 according to matrix T (2 x 2)</div>

<div class="scrap"><a id='magicparlabel-337673' />
% Note: Order of colums is [val, d/dx1, d/dx2, d^2/dx1^2, d^2/dx1.dx2, d^2/dx2^2]</div>

<div class="scrap"><a id='magicparlabel-337674' />
Aphilist2 = zeros(size(Aphilist));</div>

<div class="scrap"><a id='magicparlabel-337675' />
Aphilist2(:,1) = Aphilist(:,1); % values unchanged</div>

<div class="scrap"><a id='magicparlabel-337676' />
if order &gt;= 1</div>

<div class="scrap"><a id='magicparlabel-337677' />
    S = inv(T);</div>

<div class="scrap"><a id='magicparlabel-337678' />
    Aphilist2(:,2:3) = Aphilist(:,2:3)*S; % chain rule for 1st derivatives</div>

<div class="scrap"><a id='magicparlabel-337679' />
end % if</div>

<div class="scrap"><a id='magicparlabel-337680' />
if order &gt;= 2</div>

<div class="scrap"><a id='magicparlabel-337681' />
    % chain rule for 2nd derivatives (affine transformation)</div>

<div class="scrap"><a id='magicparlabel-337682' />
    Aphilist2(:,4) = Aphilist(:,4)*(S(1,1)^2)+ ...</div>

<div class="scrap"><a id='magicparlabel-337683' />
           Aphilist(:,5)*(2*S(2,1)*S(1,1))+ ...</div>

<div class="scrap"><a id='magicparlabel-337684' />
           Aphilist(:,6)*(S(2,1)^2);</div>

<div class="scrap"><a id='magicparlabel-337685' />
    Aphilist2(:,5) = Aphilist(:,4)*(S(1,1)*S(1,2))+ ...</div>

<div class="scrap"><a id='magicparlabel-337686' />
           Aphilist(:,5)*(S(1,1)*S(2,2)+S(1,2)*S(2,1))+ ...</div>

<div class="scrap"><a id='magicparlabel-337687' />
           Aphilist(:,6)*(S(2,2)*S(2,1));</div>

<div class="scrap"><a id='magicparlabel-337688' />
    Aphilist2(:,6) = Aphilist(:,4)*(S(1,2)^2)+ ...</div>

<div class="scrap"><a id='magicparlabel-337689' />
           Aphilist(:,5)*(2*S(1,2)*S(2,2))+ ...</div>

<div class="scrap"><a id='magicparlabel-337690' />
           Aphilist(:,6)*(S(2,2)^2);</div>

<div class="scrap"><a id='magicparlabel-337691' />
end % if</div>

<div class="scrap"><a id='magicparlabel-337692' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337693' />
@</div>

<div class="standard"><a id='magicparlabel-337694' />
The Aphilist_trans2d() function is common to all scalar Lagrange elements. However, for vector-valued elements or for certain <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msup>
   <mrow><mi>C</mi>
   </mrow>
   <mrow><mn>1</mn>
   </mrow>
  </msup>
 </mrow></math> elements (such as Bell's triangle or the Argyris element), this needs to be modified.</div>
<h3 class="subsection"><span class="subsection_label">4.3</span> <a id='magicparlabel-337695' />
<a id="sub_Piecewise_quadratic_elements" />
Piecewise quadratic elements</h3>
<div class="standard"><a id='magicparlabel-337696' />
Piecewise quadratic elements are based on nodal interpolation at the vertices and the midpoints of the edges, as illustrated in Figure&nbsp;<a href="#fig_Quadratic_Lagrange_element">1</a>. It is important to use the midpoint as when two elements share a common edge, it is important that the nodal points are the same for both elements.</div>

<div class="standard"><a id='magicparlabel-337697' />
</div>
<div class='float float-figure'><div class="plain_layout" style='text-align: center;'><a id='magicparlabel-337701' />
<img style='width:60%;' src='0_space_dstewart_Documents_MATLAB_pde2_noweb_quadratic-elt.png' alt='image: 0_space_dstewart_Documents_MATLAB_pde2_noweb_quadratic-elt.png' />
</div>

<div class="plain_layout"><a id='magicparlabel-337702' />
<div class='float-caption float-caption-figure'>Figure 1:<div class="plain_layout"><a id='magicparlabel-337706' />
<a id="fig_Quadratic_Lagrange_element" />
Quadratic Lagrange element</div>
</div></div>

<div class="plain_layout"><a id='magicparlabel-337707' />
</div>
</div>


<div class="standard"><a id='magicparlabel-337708' />
The function that creates the element type data structure for piecewise quadratic elements is very similar to that for piecewise linear elements.</div>

<div class="scrap"><a id='magicparlabel-337709' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337710' />
quad2d-elt.m \</div>

<div class="scrap"><a id='magicparlabel-337711' />
&lt;&lt;quad2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337712' />
function elt = quad2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337713' />
% function elt = quad2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337714' />
%</div>

<div class="scrap"><a id='magicparlabel-337715' />
% Returns the quadratic 2-D (6-point) element data structure</div>

<div class="scrap"><a id='magicparlabel-337716' />
[nvars,flist] = quad2d_get_nvars();</div>

<div class="scrap"><a id='magicparlabel-337717' />
elt = struct('get_Aphihat',@quad2d_get_Aphihat, ...</div>

<div class="scrap"><a id='magicparlabel-337718' />
    'nvars',nvars,'flist',flist, ...</div>

<div class="scrap"><a id='magicparlabel-337719' />
    'pxfeature',@quad2d_pxfeature,'vnodes',quad2d_vnodes(), ...</div>

<div class="scrap"><a id='magicparlabel-337720' />
    'trans_Aphihat',@trans2d_Aphilist);</div>

<div class="scrap"><a id='magicparlabel-337721' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337722' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.3.1</span> <a id='magicparlabel-337723' />
Piecewise quadratic elements: get_Aphihat()</h4>
<div class="standard"><a id='magicparlabel-337724' />
This is the main workhorse of the quadratic element data structure:</div>

<div class="scrap"><a id='magicparlabel-337725' />
&lt;&lt;quad2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337726' />
function Aphilist = quad2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337727' />
% function Aphilist = quad2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337728' />
%</div>

<div class="scrap"><a id='magicparlabel-337729' />
% Returns array of basis functions, their gradient and Hessian entries</div>

<div class="scrap"><a id='magicparlabel-337730' />
% for quadratic basis functions on a 2-D reference triangle at xhat.</div>

<div class="scrap"><a id='magicparlabel-337731' />
% The vertices of the reference triangle are (0,0), (1,0), and (0,1).</div>

<div class="scrap"><a id='magicparlabel-337732' />
% Aphilist(i,j) is the value of the j'th operator on phi_i at xhat.</div>

<div class="scrap"><a id='magicparlabel-337733' />
% Here phi_i is the affine function where phi_i(xhat_j) == 1</div>

<div class="scrap"><a id='magicparlabel-337734' />
% if i == j, and zero otherwise; xhat_i is the i'th vertex listed above.</div>

<div class="scrap"><a id='magicparlabel-337735' />
%</div>

<div class="scrap"><a id='magicparlabel-337736' />
% order is the maximum order of derivatives considered (order &lt;= 2)</div>

<div class="scrap"><a id='magicparlabel-337737' />
%</div>

<div class="scrap"><a id='magicparlabel-337738' />
% Order of operators: Aphi(xhat) = phi(xhat), d/dx1 phi(xhat),</div>

<div class="scrap"><a id='magicparlabel-337739' />
% d/dx2 phi(xhat), d^2/dx1^2 phi(xhat), d^2/dx1.dx2 phi(xhat),</div>

<div class="scrap"><a id='magicparlabel-337740' />
% d^2/dx2^2 phi(xhat).</div>

<div class="scrap"><a id='magicparlabel-337741' />
x = xhat(1);  y = xhat(2);</div>

<div class="scrap"><a id='magicparlabel-337742' />
% basis function values</div>

<div class="scrap"><a id='magicparlabel-337743' />
Aphilist = [2*(1-x-y)*(0.5-x-y);</div>

<div class="scrap"><a id='magicparlabel-337744' />
            2*x*(x-0.5);</div>

<div class="scrap"><a id='magicparlabel-337745' />
            2*y*(y-0.5);</div>

<div class="scrap"><a id='magicparlabel-337746' />
            4*x*(1-x-y);</div>

<div class="scrap"><a id='magicparlabel-337747' />
            4*y*(1-x-y);</div>

<div class="scrap"><a id='magicparlabel-337748' />
            4*x*y];</div>

<div class="scrap"><a id='magicparlabel-337749' />
if order &gt;= 1</div>

<div class="scrap"><a id='magicparlabel-337750' />
    % gradients (rows) of basis functions</div>

<div class="scrap"><a id='magicparlabel-337751' />
    Aphilist1 = [2*(2*(x+y)-1.5), 2*(2*(x+y)-1.5);</div>

<div class="scrap"><a id='magicparlabel-337752' />
                 4*x-1,           0;</div>

<div class="scrap"><a id='magicparlabel-337753' />
                 0,               4*y-1;</div>

<div class="scrap"><a id='magicparlabel-337754' />
                 4*(1-y)-8*x,     -4*x;</div>

<div class="scrap"><a id='magicparlabel-337755' />
                 -4*y,            4*(1-x)-8*y;</div>

<div class="scrap"><a id='magicparlabel-337756' />
                 4*y,             4*x];</div>

<div class="scrap"><a id='magicparlabel-337757' />
    Aphilist = [Aphilist, Aphilist1];</div>

<div class="scrap"><a id='magicparlabel-337758' />
end</div>

<div class="scrap"><a id='magicparlabel-337759' />
if order &gt;= 2</div>

<div class="scrap"><a id='magicparlabel-337760' />
    % Hessian matrix entries of basis functions: dx1^2, dx1.dx2, dx2^2</div>

<div class="scrap"><a id='magicparlabel-337761' />
    Aphilist2 = [4,  4,  4;</div>

<div class="scrap"><a id='magicparlabel-337762' />
                 4,  0,  0;</div>

<div class="scrap"><a id='magicparlabel-337763' />
                 0,  0,  4;</div>

<div class="scrap"><a id='magicparlabel-337764' />
                -8, -4,  0;</div>

<div class="scrap"><a id='magicparlabel-337765' />
                 0, -4, -8;</div>

<div class="scrap"><a id='magicparlabel-337766' />
                 0,  4,  0];</div>

<div class="scrap"><a id='magicparlabel-337767' />
    Aphilist = [Aphilist, Aphilist2];</div>

<div class="scrap"><a id='magicparlabel-337768' />
end % if</div>

<div class="scrap"><a id='magicparlabel-337769' />
end % function </div>

<div class="scrap"><a id='magicparlabel-337770' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.3.2</span> <a id='magicparlabel-337771' />
Piecewise quadratic elements: get_nvars()</h4>
<div class="standard"><a id='magicparlabel-337772' />
Three basis functions are associated with the vertices, and three are associated with edges.</div>

<div class="scrap"><a id='magicparlabel-337773' />
&lt;&lt;quad2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337774' />
function [nvars,flist] = quad2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-337775' />
% function [nvars,flist] = quad2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-337776' />
%</div>

<div class="scrap"><a id='magicparlabel-337777' />
% Returns list of number of variables per feature in flist (nvars).</div>

<div class="scrap"><a id='magicparlabel-337778' />
% flist is the list of features (m x 3 integer array) associated with </div>

<div class="scrap"><a id='magicparlabel-337779' />
% the corresponding variable</div>

<div class="scrap"><a id='magicparlabel-337780' />
nvars = [1;1;1;1;1;1];</div>

<div class="scrap"><a id='magicparlabel-337781' />
flist = [1 0 0;</div>

<div class="scrap"><a id='magicparlabel-337782' />
         2 0 0;</div>

<div class="scrap"><a id='magicparlabel-337783' />
         3 0 0;</div>

<div class="scrap"><a id='magicparlabel-337784' />
         1 2 0;</div>

<div class="scrap"><a id='magicparlabel-337785' />
         1 3 0;</div>

<div class="scrap"><a id='magicparlabel-337786' />
         2 3 0];</div>

<div class="scrap"><a id='magicparlabel-337787' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337788' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.3.3</span> <a id='magicparlabel-337789' />
Piecewise quadratic elements: pxfeature()</h4>
<div class="standard"><a id='magicparlabel-337790' />
Again this code is essentially trivial, even though we now have variables associated with edges rather than only with vertices as in the piecewise linear case.</div>

<div class="scrap"><a id='magicparlabel-337791' />
&lt;&lt;quad2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337792' />
function [px_vars,signs] = quad2d_pxfeature(px)</div>

<div class="scrap"><a id='magicparlabel-337793' />
% function [px_vars,signs] = quad2d_pxfeature(px)</div>

<div class="scrap"><a id='magicparlabel-337794' />
%</div>

<div class="scrap"><a id='magicparlabel-337795' />
% Returns the permutation of the variables (px_vars),</div>

<div class="scrap"><a id='magicparlabel-337796' />
% and the sign changes (signs) resulting from a permutation (px)</div>

<div class="scrap"><a id='magicparlabel-337797' />
% applied to a feature of the appropriate dimension (== length(px)).</div>

<div class="scrap"><a id='magicparlabel-337798' />
% This is for the quadratic 2-D triangle elements.</div>

<div class="scrap"><a id='magicparlabel-337799' />
dim = sum(px ~= 0)-1;</div>

<div class="scrap"><a id='magicparlabel-337800' />
switch dim</div>

<div class="scrap"><a id='magicparlabel-337801' />
    case 0 % points</div>

<div class="scrap"><a id='magicparlabel-337802' />
        px_vars = [1]; signs = [1];</div>

<div class="scrap"><a id='magicparlabel-337803' />
    case 1 % edges</div>

<div class="scrap"><a id='magicparlabel-337804' />
        px_vars = [1]; signs = [1];</div>

<div class="scrap"><a id='magicparlabel-337805' />
    otherwise % not a valid feature</div>

<div class="scrap"><a id='magicparlabel-337806' />
        px_vars = []; signs = [];</div>

<div class="scrap"><a id='magicparlabel-337807' />
end % switch</div>

<div class="scrap"><a id='magicparlabel-337808' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337809' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.3.4</span> <a id='magicparlabel-337810' />
Piecewise quadratic elements: vnodes()</h4>
<div class="standard"><a id='magicparlabel-337811' />
Again, not essential, but perhaps useful.</div>

<div class="scrap"><a id='magicparlabel-337812' />
&lt;&lt;quad2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337813' />
function vnodes = quad2d_vnodes()</div>

<div class="scrap"><a id='magicparlabel-337814' />
% function vnodes = quad2d_vnodes()</div>

<div class="scrap"><a id='magicparlabel-337815' />
%</div>

<div class="scrap"><a id='magicparlabel-337816' />
% Returns the positions of the variable nodes</div>

<div class="scrap"><a id='magicparlabel-337817' />
% with respect to the reference element.</div>

<div class="scrap"><a id='magicparlabel-337818' />
% Same format as p (2 x m)</div>

<div class="scrap"><a id='magicparlabel-337819' />
vnodes = [0   0;</div>

<div class="scrap"><a id='magicparlabel-337820' />
          1   0;</div>

<div class="scrap"><a id='magicparlabel-337821' />
          0   1; </div>

<div class="scrap"><a id='magicparlabel-337822' />
          1/2 0;</div>

<div class="scrap"><a id='magicparlabel-337823' />
          0   1/2;</div>

<div class="scrap"><a id='magicparlabel-337824' />
          1/2 1/2];</div>

<div class="scrap"><a id='magicparlabel-337825' />
end</div>

<div class="scrap"><a id='magicparlabel-337826' />
@</div>
<h3 class="subsection"><span class="subsection_label">4.4</span> <a id='magicparlabel-337827' />
<a id="sub_Piecewise_cubic_elements" />
Piecewise cubic elements</h3>
<div class="standard"><a id='magicparlabel-337828' />
These elements have a nodal basis with nodes at the vertices, at the 1/3 and 2/3 points on each edge, and the centroid of the triangle. Because they have two node points on each edge, there may need to be some permutations to ensure correct references to variables (see pxfeature() below).</div>

<div class="scrap"><a id='magicparlabel-337829' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337830' />
cub2d-elt.m \</div>

<div class="scrap"><a id='magicparlabel-337831' />
&lt;&lt;cub2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337832' />
function elt = cub2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337833' />
% function elt = cub2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337834' />
%</div>

<div class="scrap"><a id='magicparlabel-337835' />
% Returns cubic 2-D (10-point) element data structure</div>

<div class="scrap"><a id='magicparlabel-337836' />
[nvars,flist] = cub2d_get_nvars();</div>

<div class="scrap"><a id='magicparlabel-337837' />
elt = struct('get_Aphihat',@cub2d_get_Aphihat, ...</div>

<div class="scrap"><a id='magicparlabel-337838' />
    'nvars',nvars,'flist',flist, ...</div>

<div class="scrap"><a id='magicparlabel-337839' />
    'pxfeature',@cub2d_pxfeature,'vnodes',cub2d_vnodes(), ...</div>

<div class="scrap"><a id='magicparlabel-337840' />
    'trans_Aphihat',@trans2d_Aphilist);</div>

<div class="scrap"><a id='magicparlabel-337841' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337842' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.4.1</span> <a id='magicparlabel-337843' />
Piecewise cubic elements: get_Aphihat</h4>
<div class="standard"><a id='magicparlabel-337844' />
There are six basis functions on the reference element.</div>

<div class="scrap"><a id='magicparlabel-337845' />
&lt;&lt;cub2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337846' />
function Aphihat = cub2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337847' />
% function Aphihat = cub2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337848' />
%</div>

<div class="scrap"><a id='magicparlabel-337849' />
% Returns basis function values, gradients and Hessian</div>

<div class="scrap"><a id='magicparlabel-337850' />
% entries for Lagrangian cubic basis functions on the</div>

<div class="scrap"><a id='magicparlabel-337851' />
% reference triangle with vertices (0,0), (1,0), and (0,1).</div>

<div class="scrap"><a id='magicparlabel-337852' />
% Each row contains the value, 1st derivatives, and 2nd derivatives </div>

<div class="scrap"><a id='magicparlabel-337853' />
% of the corresponding basis function on the reference element.</div>

<div class="scrap"><a id='magicparlabel-337854' />
x = xhat(1);</div>

<div class="scrap"><a id='magicparlabel-337855' />
y = xhat(2);</div>

<div class="scrap"><a id='magicparlabel-337856' />
Aphihat0 = [(9/2)*(1-x-y)*(2/3-x-y)*(1/3-x-y);</div>

<div class="scrap"><a id='magicparlabel-337857' />
    (9/2)*x*(x-1/3)*(x-2/3);</div>

<div class="scrap"><a id='magicparlabel-337858' />
    (9/2)*y*(y-1/3)*(y-2/3);</div>

<div class="scrap"><a id='magicparlabel-337859' />
    (27/2)*x*(2/3-x-y)*(1-x-y);</div>

<div class="scrap"><a id='magicparlabel-337860' />
    (27/2)*x*(x-1/3)*(1-x-y);</div>

<div class="scrap"><a id='magicparlabel-337861' />
    (27/2)*y*(2/3-x-y)*(1-x-y);</div>

<div class="scrap"><a id='magicparlabel-337862' />
    (27/2)*y*(y-1/3)*(1-x-y);</div>

<div class="scrap"><a id='magicparlabel-337863' />
    (27/2)*x*y*(x-1/3);</div>

<div class="scrap"><a id='magicparlabel-337864' />
    (27/2)*x*y*(y-1/3);</div>

<div class="scrap"><a id='magicparlabel-337865' />
    27*x*y*(1-x-y)];</div>

<div class="scrap"><a id='magicparlabel-337866' />
if order &gt;= 1</div>

<div class="scrap"><a id='magicparlabel-337867' />
    Aphihat1 = [ ...</div>

<div class="scrap"><a id='magicparlabel-337868' />
      18*x + 18*y - 27*x*y - (27*x^2)/2 - (27*y^2)/2 - 11/2, 18*x + 18*y - 27*x*y - (27*x^2)/2 - (27*y^2)/2 - 11/2;</div>

<div class="scrap"><a id='magicparlabel-337869' />
      (27*x^2)/2 - 9*x + 1, 0;</div>

<div class="scrap"><a id='magicparlabel-337870' />
      0, (27*y^2)/2 - 9*y + 1;</div>

<div class="scrap"><a id='magicparlabel-337871' />
      (81*x^2)/2 + 54*x*y - 45*x + (27*y^2)/2 - (45*y)/2 + 9, (9*x*(6*x + 6*y - 5))/2;</div>

<div class="scrap"><a id='magicparlabel-337872' />
      36*x + (9*y)/2 - 27*x*y - (81*x^2)/2 - 9/2, -(27*x*(x - 1/3))/2;</div>

<div class="scrap"><a id='magicparlabel-337873' />
      (9*y*(6*x + 6*y - 5))/2, (27*x^2)/2 + 54*x*y - (45*x)/2 + (81*y^2)/2 - 45*y + 9;</div>

<div class="scrap"><a id='magicparlabel-337874' />
      -(27*y*(y - 1/3))/2, (9*x)/2 + 36*y - 27*x*y - (81*y^2)/2 - 9/2;</div>

<div class="scrap"><a id='magicparlabel-337875' />
      (9*y*(6*x - 1))/2, (27*x*(x - 1/3))/2;</div>

<div class="scrap"><a id='magicparlabel-337876' />
      (27*y*(y - 1/3))/2, (9*x*(6*y - 1))/2;</div>

<div class="scrap"><a id='magicparlabel-337877' />
      -27*y*(2*x + y - 1), -27*x*(x + 2*y - 1)];</div>

<div class="scrap"><a id='magicparlabel-337878' />
end</div>

<div class="scrap"><a id='magicparlabel-337879' />
if order &gt;= 2</div>

<div class="scrap"><a id='magicparlabel-337880' />
    Aphihat2 = [ ...</div>

<div class="scrap"><a id='magicparlabel-337881' />
      18 - 27*y - 27*x, 18 - 27*y - 27*x, 18 - 27*y - 27*x;</div>

<div class="scrap"><a id='magicparlabel-337882' />
      27*x - 9, 0, 0;</div>

<div class="scrap"><a id='magicparlabel-337883' />
      0, 0, 27*y - 9;</div>

<div class="scrap"><a id='magicparlabel-337884' />
      81*x + 54*y - 45, 54*x + 27*y - 45/2, 27*x;</div>

<div class="scrap"><a id='magicparlabel-337885' />
      36 - 27*y - 81*x, 9/2 - 27*x, 0;</div>

<div class="scrap"><a id='magicparlabel-337886' />
      27*y, 27*x + 54*y - 45/2, 54*x + 81*y - 45;</div>

<div class="scrap"><a id='magicparlabel-337887' />
      0, 9/2 - 27*y, 36 - 81*y - 27*x;</div>

<div class="scrap"><a id='magicparlabel-337888' />
      27*y, 27*x - 9/2, 0;</div>

<div class="scrap"><a id='magicparlabel-337889' />
      0, 27*y - 9/2, 27*x;</div>

<div class="scrap"><a id='magicparlabel-337890' />
      -54*y, 27 - 54*y - 54*x, -54*x];</div>

<div class="scrap"><a id='magicparlabel-337891' />
end</div>

<div class="scrap"><a id='magicparlabel-337892' />
if order == 0</div>

<div class="scrap"><a id='magicparlabel-337893' />
    Aphihat = Aphihat0;</div>

<div class="scrap"><a id='magicparlabel-337894' />
elseif order == 1</div>

<div class="scrap"><a id='magicparlabel-337895' />
    Aphihat = [Aphihat0, Aphihat1];</div>

<div class="scrap"><a id='magicparlabel-337896' />
elseif order == 2</div>

<div class="scrap"><a id='magicparlabel-337897' />
    Aphihat = [Aphihat0, Aphihat1, Aphihat2];</div>

<div class="scrap"><a id='magicparlabel-337898' />
end</div>

<div class="scrap"><a id='magicparlabel-337899' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337900' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.4.2</span> <a id='magicparlabel-337901' />
Piecewise cubic elements: get_nvars()</h4>
<div class="standard"><a id='magicparlabel-337902' />
Again, note the two variables for each edge.</div>

<div class="scrap"><a id='magicparlabel-337903' />
&lt;&lt;cub2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337904' />
function [nvars,flist] = cub2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-337905' />
% function [nvars,flist] = cub2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-337906' />
% </div>

<div class="scrap"><a id='magicparlabel-337907' />
% Returns list of number of variables per feature in flist (nvars).</div>

<div class="scrap"><a id='magicparlabel-337908' />
% flist is the list of features (m x 3 integer array) associated with </div>

<div class="scrap"><a id='magicparlabel-337909' />
% the corresponding variable</div>

<div class="scrap"><a id='magicparlabel-337910' />
nvars = [1;1;1;2;2;2;1];</div>

<div class="scrap"><a id='magicparlabel-337911' />
flist = [1 0 0;</div>

<div class="scrap"><a id='magicparlabel-337912' />
         2 0 0;</div>

<div class="scrap"><a id='magicparlabel-337913' />
         3 0 0;</div>

<div class="scrap"><a id='magicparlabel-337914' />
         1 2 0;</div>

<div class="scrap"><a id='magicparlabel-337915' />
         1 3 0;</div>

<div class="scrap"><a id='magicparlabel-337916' />
         2 3 0;</div>

<div class="scrap"><a id='magicparlabel-337917' />
         1 2 3];</div>

<div class="scrap"><a id='magicparlabel-337918' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337919' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.4.3</span> <a id='magicparlabel-337920' />
Piecewise cubic elements: pxfeature()</h4>
<div class="standard"><a id='magicparlabel-337921' />
Here we need to permute the two edge variables.</div>

<div class="scrap"><a id='magicparlabel-337922' />
&lt;&lt;cub2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337923' />
function [px_vars,signs] = cub2d_pxfeature(px)</div>

<div class="scrap"><a id='magicparlabel-337924' />
% function [px_vars,signs] = cub2d_pxfeature(px)</div>

<div class="scrap"><a id='magicparlabel-337925' />
%</div>

<div class="scrap"><a id='magicparlabel-337926' />
% Returns the permutation of the variables (px_vars),</div>

<div class="scrap"><a id='magicparlabel-337927' />
% and the sign changes (signs) resulting from a permutation (px)</div>

<div class="scrap"><a id='magicparlabel-337928' />
% applied to a feature of the appropriate dimension (== length(px)).</div>

<div class="scrap"><a id='magicparlabel-337929' />
% This is for the quadratic 2-D triangle elements.</div>

<div class="scrap"><a id='magicparlabel-337930' />
dim = sum(px ~= 0)-1;</div>

<div class="scrap"><a id='magicparlabel-337931' />
switch dim</div>

<div class="scrap"><a id='magicparlabel-337932' />
    case 0 % points</div>

<div class="scrap"><a id='magicparlabel-337933' />
        px_vars = [1]; signs = [1];</div>

<div class="scrap"><a id='magicparlabel-337934' />
    case 1 % edges</div>

<div class="scrap"><a id='magicparlabel-337935' />
        px_vars = px; signs = [1 1];</div>

<div class="scrap"><a id='magicparlabel-337936' />
    case 2 % triangles</div>

<div class="scrap"><a id='magicparlabel-337937' />
        px_vars = [1]; signs = [1];</div>

<div class="scrap"><a id='magicparlabel-337938' />
    otherwise % not a valid feature</div>

<div class="scrap"><a id='magicparlabel-337939' />
        px_vars = []; signs = [];</div>

<div class="scrap"><a id='magicparlabel-337940' />
end % switch</div>

<div class="scrap"><a id='magicparlabel-337941' />
end % function</div>

<div class="scrap"><a id='magicparlabel-337942' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.4.4</span> <a id='magicparlabel-337943' />
Piecewise cubic elements: vnodes()</h4>
<div class="scrap"><a id='magicparlabel-337944' />
&lt;&lt;cub2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337945' />
function vnodes = cub2d_vnodes()</div>

<div class="scrap"><a id='magicparlabel-337946' />
% function vnodes = cub2d_vnodes()</div>

<div class="scrap"><a id='magicparlabel-337947' />
%</div>

<div class="scrap"><a id='magicparlabel-337948' />
% Returns the positions of the variable nodes</div>

<div class="scrap"><a id='magicparlabel-337949' />
% with respect to the reference element.</div>

<div class="scrap"><a id='magicparlabel-337950' />
% Same format as p (2 x m)</div>

<div class="scrap"><a id='magicparlabel-337951' />
vnodes = [0   0;</div>

<div class="scrap"><a id='magicparlabel-337952' />
          1   0;</div>

<div class="scrap"><a id='magicparlabel-337953' />
          0   1;</div>

<div class="scrap"><a id='magicparlabel-337954' />
          0   1/3;</div>

<div class="scrap"><a id='magicparlabel-337955' />
          0   2/3;</div>

<div class="scrap"><a id='magicparlabel-337956' />
          1/3 0;</div>

<div class="scrap"><a id='magicparlabel-337957' />
          2/3 0;</div>

<div class="scrap"><a id='magicparlabel-337958' />
          1/3 2/3;</div>

<div class="scrap"><a id='magicparlabel-337959' />
          2/3 1/3;</div>

<div class="scrap"><a id='magicparlabel-337960' />
          1/3 1/3];</div>

<div class="scrap"><a id='magicparlabel-337961' />
end</div>

<div class="scrap"><a id='magicparlabel-337962' />
@</div>
<h3 class="subsection"><span class="subsection_label">4.5</span> <a id='magicparlabel-337963' />
<a id="sub_Piecewise_constant_elements" />
Piecewise constant elements</h3>
<div class="standard"><a id='magicparlabel-337964' />
Piecewise constant functions are either completely constant, or are discontinuous. This limits their applicability, but they can still be useful. Their definition for this system follows.</div>

<div class="scrap"><a id='magicparlabel-337965' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337966' />
const2d-elt.m \</div>

<div class="scrap"><a id='magicparlabel-337967' />
&lt;&lt;const2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337968' />
function elt = const2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337969' />
% function elt = const2d_elt()</div>

<div class="scrap"><a id='magicparlabel-337970' />
%</div>

<div class="scrap"><a id='magicparlabel-337971' />
% Returns constant 2-D triangle element</div>

<div class="scrap"><a id='magicparlabel-337972' />
[nvars,flist] = const2d_get_nvars();</div>

<div class="scrap"><a id='magicparlabel-337973' />
elt = struct('get_Aphihat',@const2d_get_Aphihat, ...</div>

<div class="scrap"><a id='magicparlabel-337974' />
    'nvars',nvars,'flist',flist, ...</div>

<div class="scrap"><a id='magicparlabel-337975' />
    'pxfeature',@const2d_pxfeature,'vnodes',const2d_vnodes(), ...</div>

<div class="scrap"><a id='magicparlabel-337976' />
    'trans_Aphihat',@trans2d_Aphilist);</div>

<div class="scrap"><a id='magicparlabel-337977' />
end</div>

<div class="scrap"><a id='magicparlabel-337978' />
@</div>

<div class="standard"><a id='magicparlabel-337979' />
The basis functions are easy to compute:</div>

<div class="scrap"><a id='magicparlabel-337980' />
&lt;&lt;const2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-337981' />
function Aphilist = const2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337982' />
% function Aphilist = const2d_get_Aphihat(xhat,order)</div>

<div class="scrap"><a id='magicparlabel-337983' />
%</div>

<div class="scrap"><a id='magicparlabel-337984' />
% Returns array of basis function values, their gradient and Hessian entries</div>

<div class="scrap"><a id='magicparlabel-337985' />
% for constant basis functions on a 2-D reference triangle at xhat.</div>

<div class="scrap"><a id='magicparlabel-337986' />
% Basis function values</div>

<div class="scrap"><a id='magicparlabel-337987' />
Aphilist0 = [1];</div>

<div class="scrap"><a id='magicparlabel-337988' />
if order &gt;= 1</div>

<div class="scrap"><a id='magicparlabel-337989' />
    % Basis gradient values (along rows)</div>

<div class="scrap"><a id='magicparlabel-337990' />
    Aphilist1 = [0 0];</div>

<div class="scrap"><a id='magicparlabel-337991' />
end</div>

<div class="scrap"><a id='magicparlabel-337992' />
if order &gt;= 2</div>

<div class="scrap"><a id='magicparlabel-337993' />
    % Basis hessian values (along rows: d1^2, d1.d2, d2^2)</div>

<div class="scrap"><a id='magicparlabel-337994' />
    Aphilist2 = [0 0 0];</div>

<div class="scrap"><a id='magicparlabel-337995' />
end</div>

<div class="scrap"><a id='magicparlabel-337996' />
if order == 0</div>

<div class="scrap"><a id='magicparlabel-337997' />
    Aphilist = Aphilist0;</div>

<div class="scrap"><a id='magicparlabel-337998' />
elseif order == 1</div>

<div class="scrap"><a id='magicparlabel-337999' />
    Aphilist = [Aphilist0,Aphilist1];</div>

<div class="scrap"><a id='magicparlabel-338000' />
elseif order == 2</div>

<div class="scrap"><a id='magicparlabel-338001' />
    Aphilist = [Aphilist0,Aphilist1,Aphilist2];</div>

<div class="scrap"><a id='magicparlabel-338002' />
end</div>

<div class="scrap"><a id='magicparlabel-338003' />
@</div>

<div class="standard"><a id='magicparlabel-338004' />
There is only one variable, and that is associated with the triangle as a whole.</div>

<div class="scrap"><a id='magicparlabel-338005' />
&lt;&lt;const2d-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338006' />
function [nvars,flist] = const2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-338007' />
% function [nvars,flist] = const2d_get_nvars()</div>

<div class="scrap"><a id='magicparlabel-338008' />
%</div>

<div class="scrap"><a id='magicparlabel-338009' />
% Returns list of number of variables per feature in flist (nvars).</div>

<div class="scrap"><a id='magicparlabel-338010' />
% flist is the list of features (m x 3 integer array) associated with </div>

<div class="scrap"><a id='magicparlabel-338011' />
% the corresponding variable</div>

<div class="scrap"><a id='magicparlabel-338012' />
nvars = [1];</div>

<div class="scrap"><a id='magicparlabel-338013' />
flist = [1 2 3];</div>

<div class="scrap"><a id='magicparlabel-338014' />
end</div>

<div class="scrap"><a id='magicparlabel-338015' />
@</div>

<div class="standard"><a id='magicparlabel-338016' />
There is only one variable so changing the orientation does not do much to the variables.</div>
<h3 class="subsection"><span class="subsection_label">4.6</span> <a id='magicparlabel-338017' />
<a id="sub_Vector_elements" />
Vector elements</h3>
<div class="standard"><a id='magicparlabel-338018' />
Rather than create a vector element type separately for each scalar element type, we can create them automatically from the scalar element type. There is a new transformation routine, and it is here that the vector character is made apparent. The final result after the transformation has the columns of the output ordered as <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo> &sdot; </mo>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo> &sdot; </mo>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo> &sdot; </mo><mi> &part; </mi>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>e</mi>
     </mstyle>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msub><mo> &sdot; </mo><mi> &part; </mi>
   <msub>
    <mrow><mi> &phi; </mi>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mn>1</mn>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, etc. That is, the components alternate. </div>

<div class="scrap"><a id='magicparlabel-338019' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338020' />
eltx2-elt.m \</div>

<div class="scrap"><a id='magicparlabel-338021' />
&lt;&lt;eltx2-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338022' />
function eltx2 = eltx2_elt(elt)</div>

<div class="scrap"><a id='magicparlabel-338023' />
% function eltx2 = eltx2_elt(elt)</div>

<div class="scrap"><a id='magicparlabel-338024' />
%</div>

<div class="scrap"><a id='magicparlabel-338025' />
% Returns element data structure with the same basis</div>

<div class="scrap"><a id='magicparlabel-338026' />
% functions as defined by elt, but with 2 components for</div>

<div class="scrap"><a id='magicparlabel-338027' />
% each component of elt.</div>

<div class="scrap"><a id='magicparlabel-338028' />
nvars = elt.nvars;</div>

<div class="scrap"><a id='magicparlabel-338029' />
nvarsx2 = 2*nvars;</div>

<div class="scrap"><a id='magicparlabel-338030' />
flist = elt.flist;</div>

<div class="scrap"><a id='magicparlabel-338031' />
flistx2 = flist;</div>

<div class="scrap"><a id='magicparlabel-338032' />
trans_Aphihat = @(T,Aphilist,order)(transx2(elt.trans_Aphihat,T,Aphilist,order));</div>

<div class="scrap"><a id='magicparlabel-338033' />
pxfeature = @(px)(pxfeaturex2(elt.pxfeature,px));</div>

<div class="scrap"><a id='magicparlabel-338034' />
vnodes = elt.vnodes();</div>

<div class="scrap"><a id='magicparlabel-338035' />
vnodesx2 = zeros(2*size(vnodes,1),size(vnodes,2));</div>

<div class="scrap"><a id='magicparlabel-338036' />
vnodesx2(2*(1:size(vnodes,1))-1,:) = vnodes;</div>

<div class="scrap"><a id='magicparlabel-338037' />
vnodesx2(2*(1:size(vnodes,1)) ,:) = vnodes;</div>

<div class="scrap"><a id='magicparlabel-338038' />
eltx2 = struct('get_Aphihat',elt.get_Aphihat, ...</div>

<div class="scrap"><a id='magicparlabel-338039' />
    'nvars',nvarsx2,'flist',flistx2, ...</div>

<div class="scrap"><a id='magicparlabel-338040' />
    'pxfeature',pxfeature,'vnodes',vnodesx2, ...</div>

<div class="scrap"><a id='magicparlabel-338041' />
    'trans_Aphihat',trans_Aphihat);</div>

<div class="scrap"><a id='magicparlabel-338042' />
end % function</div>

<div class="scrap"><a id='magicparlabel-338043' />
@</div>

<div class="standard"><a id='magicparlabel-338044' />
Note that the original get_Aphihat() function is used. But we need new permutation and transformation functions based on the originals.</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.6.1</span> <a id='magicparlabel-338045' />
Vector elements: pxfeature()</h4>
<div class="scrap"><a id='magicparlabel-338046' />
&lt;&lt;eltx2-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338047' />
function [px_varsx2,signsx2] = pxfeaturex2(base_pxfeature,px)</div>

<div class="scrap"><a id='magicparlabel-338048' />
% function [px_varsx2,signsx2] = pxfeaturex2(base_pxfeature,px)</div>

<div class="scrap"><a id='magicparlabel-338049' />
%</div>

<div class="scrap"><a id='magicparlabel-338050' />
% Uses base_pxfeature to create pxfeature() function for the "x2" element</div>

<div class="scrap"><a id='magicparlabel-338051' />
[px_vars,signs] = base_pxfeature(px);</div>

<div class="scrap"><a id='magicparlabel-338052' />
px_varsx2 = zeros(1,2*length(px_vars));</div>

<div class="scrap"><a id='magicparlabel-338053' />
signsx2   = zeros(1,2*length(px_vars));</div>

<div class="scrap"><a id='magicparlabel-338054' />
px_varsx2(2*(1:length(px_vars))-1) = 2*px_vars-1;</div>

<div class="scrap"><a id='magicparlabel-338055' />
signsx2(2*(1:length(px_vars))-1)   = signs;</div>

<div class="scrap"><a id='magicparlabel-338056' />
px_varsx2(2*(1:length(px_vars)) )  = 2*px_vars;</div>

<div class="scrap"><a id='magicparlabel-338057' />
signsx2(2*(1:length(px_vars)) )    = signs;</div>

<div class="scrap"><a id='magicparlabel-338058' />
end % function</div>

<div class="scrap"><a id='magicparlabel-338059' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">4.6.2</span> <a id='magicparlabel-338060' />
Vector elements: trans_Aphilist()</h4>
<div class="scrap"><a id='magicparlabel-338061' />
&lt;&lt;eltx2-elt.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338062' />
function Aphilistx2 = transx2(base_trans,T,Aphilist,order)</div>

<div class="scrap"><a id='magicparlabel-338063' />
% function Aphilistx2 = transx2(base_trans,T,Aphilist,order)</div>

<div class="scrap"><a id='magicparlabel-338064' />
%</div>

<div class="scrap"><a id='magicparlabel-338065' />
% Uses base_trans to create trans_Aphilist function for the "x2" element</div>

<div class="scrap"><a id='magicparlabel-338066' />
Aphilist = base_trans(T,Aphilist,order);</div>

<div class="scrap"><a id='magicparlabel-338067' />
nb = size(Aphilist,1);</div>

<div class="scrap"><a id='magicparlabel-338068' />
Aphilistx2 = zeros(2*nb,size(Aphilist,2));</div>

<div class="scrap"><a id='magicparlabel-338069' />
Aphilistx2(2*(1:nb)-1,1) = Aphilist(:,1);</div>

<div class="scrap"><a id='magicparlabel-338070' />
Aphilistx2(2*(1:nb) ,2) = Aphilist(:,1);</div>

<div class="scrap"><a id='magicparlabel-338071' />
if order &gt;= 1</div>

<div class="scrap"><a id='magicparlabel-338072' />
    Aphilistx2(2*(1:nb)-1,3:4) = Aphilist(:,2:3);</div>

<div class="scrap"><a id='magicparlabel-338073' />
    Aphilistx2(2*(1:nb) ,5:6) = Aphilist(:,2:3);</div>

<div class="scrap"><a id='magicparlabel-338074' />
end</div>

<div class="scrap"><a id='magicparlabel-338075' />
if order &gt;= 2</div>

<div class="scrap"><a id='magicparlabel-338076' />
    Aphilistx2(2*(1:nb)-1,7:9) = Aphilist(:,4:6);</div>

<div class="scrap"><a id='magicparlabel-338077' />
    Aphilistx2(2*(1:nb) ,10:12) = Aphilist(:,4:6);</div>

<div class="scrap"><a id='magicparlabel-338078' />
end</div>

<div class="scrap"><a id='magicparlabel-338079' />
end % function</div>

<div class="scrap"><a id='magicparlabel-338080' />
@</div>
<h2 class="section"><span class="section_label">5</span> <a id='magicparlabel-338081' />
<a id="sec_Numerical_integration" />
Numerical integration</h2>
<div class="standard"><a id='magicparlabel-338082' />
Numerical integration is basic to the assembly process. The numerical integration routine should be exact for products of the basis functions that are used. Since the assembly routines perform the transformation from reference elements, these routines just need to return the points and weights for the method on a reference element, which is the triangle with vertices <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mn>0</mn><mo>,</mo><mn>0</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mn>1</mn><mo>,</mo><mn>0</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mrow><mn>0</mn><mo>,</mo><mn>1</mn>
  </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math>. </div>
<h3 class="subsection"><span class="subsection_label">5.1</span> <a id='magicparlabel-338083' />
<a id="sub_Two_dimensional_integration" />
Two-dimensional integration methods</h3>
<h4 class="subsubsection"><span class="subsubsection_label">5.1.1</span> <a id='magicparlabel-338084' />
<a id="sub_Radon_method" />
Radon's method</h4>
<div class="standard"><a id='magicparlabel-338085' />
This is a 7-point method with order 5.</div>

<div class="scrap"><a id='magicparlabel-338086' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338087' />
int2d-radon7.m \</div>

<div class="scrap"><a id='magicparlabel-338088' />
&lt;&lt;int2d-radon7.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338089' />
function [p,w] = int2d_radon7()</div>

<div class="scrap"><a id='magicparlabel-338090' />
% function [p,w] = int2d_radon7()</div>

<div class="scrap"><a id='magicparlabel-338091' />
%</div>

<div class="scrap"><a id='magicparlabel-338092' />
% Returns the points (p) and weights (w) of J. Radon's 7-point</div>

<div class="scrap"><a id='magicparlabel-338093' />
% integration formula for the triangle with vertices (0,0), (1,0), (0,1).</div>

<div class="scrap"><a id='magicparlabel-338094' />
% This formula is exact for polynomials up to degree 5.</div>

<div class="scrap"><a id='magicparlabel-338095' />
% Points are the rows of p.</div>

<div class="scrap"><a id='magicparlabel-338096' />
%</div>

<div class="scrap"><a id='magicparlabel-338097' />
% Reference: J. Radon, Zur mechanischen Kubatur. (German)</div>

<div class="scrap"><a id='magicparlabel-338098' />
% Monatsh. Math. 52, (1948), pp. 286-300.</div>

<div class="scrap"><a id='magicparlabel-338099' />
p = [1/3, 1/3;</div>

<div class="scrap"><a id='magicparlabel-338100' />
    (6+sqrt(15))/21,   (9-2*sqrt(15))/21;</div>

<div class="scrap"><a id='magicparlabel-338101' />
    (9-2*sqrt(15))/21, (6+sqrt(15))/21;</div>

<div class="scrap"><a id='magicparlabel-338102' />
    (6+sqrt(15))/21,   (6+sqrt(15))/21;</div>

<div class="scrap"><a id='magicparlabel-338103' />
    (6-sqrt(15))/21,   (9+2*sqrt(15))/21;</div>

<div class="scrap"><a id='magicparlabel-338104' />
    (9+2*sqrt(15))/21, (6-sqrt(15))/21;</div>

<div class="scrap"><a id='magicparlabel-338105' />
    (6-sqrt(15))/21,   (6-sqrt(15))/21];</div>

<div class="scrap"><a id='magicparlabel-338106' />
w = [9/80;</div>

<div class="scrap"><a id='magicparlabel-338107' />
    (155+sqrt(15))/2400;</div>

<div class="scrap"><a id='magicparlabel-338108' />
    (155+sqrt(15))/2400;</div>

<div class="scrap"><a id='magicparlabel-338109' />
    (155+sqrt(15))/2400;</div>

<div class="scrap"><a id='magicparlabel-338110' />
    (155-sqrt(15))/2400;</div>

<div class="scrap"><a id='magicparlabel-338111' />
    (155-sqrt(15))/2400;</div>

<div class="scrap"><a id='magicparlabel-338112' />
    (155-sqrt(15))/2400];</div>

<div class="scrap"><a id='magicparlabel-338113' />
end</div>

<div class="scrap"><a id='magicparlabel-338114' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">5.1.2</span> <a id='magicparlabel-338115' />
<a id="sub_Gatermann_method" />
Gatermann's method</h4>
<div class="standard"><a id='magicparlabel-338116' />
This is a 12-point method with order 7.</div>

<div class="scrap"><a id='magicparlabel-338117' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338118' />
int2d-gatermann12.m \</div>

<div class="scrap"><a id='magicparlabel-338119' />
&lt;&lt;int2d-gatermann12.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338120' />
function [p,w] = int2d_gatermann12()</div>

<div class="scrap"><a id='magicparlabel-338121' />
% function [p,w] = int2d_gatermann12()</div>

<div class="scrap"><a id='magicparlabel-338122' />
%</div>

<div class="scrap"><a id='magicparlabel-338123' />
% Returns the points (p) and weights (w) of K. Gatermann's 12-point</div>

<div class="scrap"><a id='magicparlabel-338124' />
% integration formula for the triangle with vertices (0,0), (1,0), (0,1).</div>

<div class="scrap"><a id='magicparlabel-338125' />
% This formula is exact for polynomials up to degree 7???.</div>

<div class="scrap"><a id='magicparlabel-338126' />
% Points are the rows of p.</div>

<div class="scrap"><a id='magicparlabel-338127' />
%</div>

<div class="scrap"><a id='magicparlabel-338128' />
% Reference: The Construction of Symmetric Cubature Formulas</div>

<div class="scrap"><a id='magicparlabel-338129' />
% for the Square and the Triangle, Computing 40, 229 - 240 (1988)</div>

<div class="scrap"><a id='magicparlabel-338130' />
p = [0.06751786707392436, 0.8700998678316848;  % 1</div>

<div class="scrap"><a id='magicparlabel-338131' />
     0.06238226509439084, 0.06751786707392436; % 2</div>

<div class="scrap"><a id='magicparlabel-338132' />
     0.8700998678316848,  0.06238226509439084; % 3</div>

<div class="scrap"><a id='magicparlabel-338133' />
     0.3215024938520156,  0.6232720494910644;  % 4</div>

<div class="scrap"><a id='magicparlabel-338134' />
     0.05522545665692000, 0.3215024938520156;  % 5</div>

<div class="scrap"><a id='magicparlabel-338135' />
     0.6232720494910644,  0.05522545665692000; % 6</div>

<div class="scrap"><a id='magicparlabel-338136' />
     0.6609491961867980,  0.3047265008681072;  % 7</div>

<div class="scrap"><a id='magicparlabel-338137' />
     0.03432430294509488, 0.6609491961867980;  % 8</div>

<div class="scrap"><a id='magicparlabel-338138' />
     0.3047265008681072,  0.03432430294509488; % 9</div>

<div class="scrap"><a id='magicparlabel-338139' />
     0.2777161669764050,  0.2064414986699949;  % 10</div>

<div class="scrap"><a id='magicparlabel-338140' />
     0.5158423343536001,  0.2777161669764050;  % 11</div>

<div class="scrap"><a id='magicparlabel-338141' />
     0.2064414986699949,  0.5158423343536001]; % 12</div>

<div class="scrap"><a id='magicparlabel-338142' />
w = [0.02651702815743450;</div>

<div class="scrap"><a id='magicparlabel-338143' />
     0.02651702815743450;</div>

<div class="scrap"><a id='magicparlabel-338144' />
     0.02651702815743450;</div>

<div class="scrap"><a id='magicparlabel-338145' />
     0.04388140871444811;</div>

<div class="scrap"><a id='magicparlabel-338146' />
     0.04388140871444811;</div>

<div class="scrap"><a id='magicparlabel-338147' />
     0.04388140871444811;</div>

<div class="scrap"><a id='magicparlabel-338148' />
     0.02877504278497528;</div>

<div class="scrap"><a id='magicparlabel-338149' />
     0.02877504278497528;</div>

<div class="scrap"><a id='magicparlabel-338150' />
     0.02877504278497528;</div>

<div class="scrap"><a id='magicparlabel-338151' />
     0.06749318700980879;</div>

<div class="scrap"><a id='magicparlabel-338152' />
     0.06749318700980879;</div>

<div class="scrap"><a id='magicparlabel-338153' />
     0.06749318700980879];</div>

<div class="scrap"><a id='magicparlabel-338154' />
end</div>

<div class="scrap"><a id='magicparlabel-338155' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">5.1.3</span> <a id='magicparlabel-338156' />
<a id="sub_integration_Dunavant" />
A method of Dunavant</h4>
<div class="standard"><a id='magicparlabel-338157' />
This is a 33-point method with order 12.</div>

<div class="scrap"><a id='magicparlabel-338158' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338159' />
int2d-dunavant33.m \</div>

<div class="scrap"><a id='magicparlabel-338160' />
&lt;&lt;int2d-dunavant33.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338161' />
function [p,w] = int2d_dunavant33()</div>

<div class="scrap"><a id='magicparlabel-338162' />
% function [p,w] = int2d_dunavant33()</div>

<div class="scrap"><a id='magicparlabel-338163' />
%</div>

<div class="scrap"><a id='magicparlabel-338164' />
% Returns points and weights for Dunavant (1978)'s </div>

<div class="scrap"><a id='magicparlabel-338165' />
% 12th order 33 point triangle integration method.</div>

<div class="scrap"><a id='magicparlabel-338166' />
% Values taken directly from Dunavant's paper:</div>

<div class="scrap"><a id='magicparlabel-338167' />
% "High degree efficient symmetrical Gaussian quadrature rules for the</div>

<div class="scrap"><a id='magicparlabel-338168' />
% triangle", Internat. J. Numer. Methods Eng. vol 21, pp. 1129-1148 (1978)</div>

<div class="scrap"><a id='magicparlabel-338169' />
% p=12 ng=33 nsige17.8 ssqa9.d-58 error= 1.d-27 ifn= 2439 infers1 time= 74</div>

<div class="scrap"><a id='magicparlabel-338170' />
% weight alpha beta gamma</div>

<div class="scrap"><a id='magicparlabel-338171' />
% 0.025731066440455 0.023565220452390 0.488217389773805 0.488217389773805</div>

<div class="scrap"><a id='magicparlabel-338172' />
% 0.043692544538038 0.120551215411079 0.439724392294460 0.439724392294460</div>

<div class="scrap"><a id='magicparlabel-338173' />
% 0.062858224217885 0.457579229975768 0.271210385012116 0.271210385012116</div>

<div class="scrap"><a id='magicparlabel-338174' />
% 0.034796112930709 0.744847708916828 0.127576145541586 0.127576145541586</div>

<div class="scrap"><a id='magicparlabel-338175' />
% 0.006166261051559 0.957365299093579 0.021317350453210 0.021317350453210</div>

<div class="scrap"><a id='magicparlabel-338176' />
% 0.040371557766381 0.115343494534698 0.275713269685514 0.608943235779788</div>

<div class="scrap"><a id='magicparlabel-338177' />
% 0.022356773202303 0.022838332222257 0.281325580989940 0.695836086787803</div>

<div class="scrap"><a id='magicparlabel-338178' />
% 0.017316231108659 0.025734050548330 0.116251915907597 0.858014033544073</div>

<div class="scrap"><a id='magicparlabel-338179' />
table = [...</div>

<div class="scrap"><a id='magicparlabel-338180' />
0.025731066440455 0.023565220452390 0.488217389773805 0.488217389773805</div>

<div class="scrap"><a id='magicparlabel-338181' />
0.043692544538038 0.120551215411079 0.439724392294460 0.439724392294460</div>

<div class="scrap"><a id='magicparlabel-338182' />
0.062858224217885 0.457579229975768 0.271210385012116 0.271210385012116</div>

<div class="scrap"><a id='magicparlabel-338183' />
0.034796112930709 0.744847708916828 0.127576145541586 0.127576145541586</div>

<div class="scrap"><a id='magicparlabel-338184' />
0.006166261051559 0.957365299093579 0.021317350453210 0.021317350453210</div>

<div class="scrap"><a id='magicparlabel-338185' />
0.040371557766381 0.115343494534698 0.275713269685514 0.608943235779788</div>

<div class="scrap"><a id='magicparlabel-338186' />
0.022356773202303 0.022838332222257 0.281325580989940 0.695836086787803</div>

<div class="scrap"><a id='magicparlabel-338187' />
0.017316231108659 0.025734050548330 0.116251915907597 0.858014033544073];</div>

<div class="scrap"><a id='magicparlabel-338188' />
idx = 1; t_idx = 1;</div>

<div class="scrap"><a id='magicparlabel-338189' />
p = zeros(33,2); w = zeros(32,1);</div>

<div class="scrap"><a id='magicparlabel-338190' />
for t_idx = 1:size(table,1)</div>

<div class="scrap"><a id='magicparlabel-338191' />
    if table(t_idx,3) == table(t_idx,4)</div>

<div class="scrap"><a id='magicparlabel-338192' />
        % 3 entries</div>

<div class="scrap"><a id='magicparlabel-338193' />
        w(idx:(idx+2)) = table(t_idx,1);</div>

<div class="scrap"><a id='magicparlabel-338194' />
        p(idx+0,:) = table(t_idx,[2,3]);</div>

<div class="scrap"><a id='magicparlabel-338195' />
        p(idx+1,:) = table(t_idx,[3,2]);</div>

<div class="scrap"><a id='magicparlabel-338196' />
        p(idx+2,:) = table(t_idx,[3,4]);</div>

<div class="scrap"><a id='magicparlabel-338197' />
        idx = idx+3;</div>

<div class="scrap"><a id='magicparlabel-338198' />
    else</div>

<div class="scrap"><a id='magicparlabel-338199' />
        % 6 entries</div>

<div class="scrap"><a id='magicparlabel-338200' />
        w(idx:(idx+5)) = table(t_idx,1);</div>

<div class="scrap"><a id='magicparlabel-338201' />
        p(idx+0,:) = table(t_idx,[2,3]);</div>

<div class="scrap"><a id='magicparlabel-338202' />
        p(idx+1,:) = table(t_idx,[2,4]);</div>

<div class="scrap"><a id='magicparlabel-338203' />
        p(idx+2,:) = table(t_idx,[3,2]);</div>

<div class="scrap"><a id='magicparlabel-338204' />
        p(idx+3,:) = table(t_idx,[3,4]);</div>

<div class="scrap"><a id='magicparlabel-338205' />
        p(idx+4,:) = table(t_idx,[4,2]);</div>

<div class="scrap"><a id='magicparlabel-338206' />
        p(idx+5,:) = table(t_idx,[4,3]);</div>

<div class="scrap"><a id='magicparlabel-338207' />
        idx = idx+6;</div>

<div class="scrap"><a id='magicparlabel-338208' />
    end % if</div>

<div class="scrap"><a id='magicparlabel-338209' />
end % for</div>

<div class="scrap"><a id='magicparlabel-338210' />
w = w/2;</div>

<div class="scrap"><a id='magicparlabel-338211' />
end % function</div>

<div class="scrap"><a id='magicparlabel-338212' />
@</div>
<h3 class="subsection"><span class="subsection_label">5.2</span> <a id='magicparlabel-338213' />
<a id="sub_One_dimensional_integration" />
One-dimensional integration methods</h3>
<h4 class="subsubsection"><span class="subsubsection_label">5.2.1</span> <a id='magicparlabel-338214' />
<a id="sub_Gauss__Legendre_quadrature" />
Gauss&ndash;Legendre quadrature</h4>
<div class="standard"><a id='magicparlabel-338215' />
Here we use the 5-point Gauss&ndash;Legendre quadrature method which is a 9th order method.</div>

<div class="scrap"><a id='magicparlabel-338216' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338217' />
int1d-gauss5.m \</div>

<div class="scrap"><a id='magicparlabel-338218' />
&lt;&lt;int1d-gauss5.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338219' />
function [p,w] = int1d_gauss5()</div>

<div class="scrap"><a id='magicparlabel-338220' />
% function [p,w] = int1d_gauss5()</div>

<div class="scrap"><a id='magicparlabel-338221' />
%</div>

<div class="scrap"><a id='magicparlabel-338222' />
% Returns points and weights for a 5-point Gauss rule</div>

<div class="scrap"><a id='magicparlabel-338223' />
% in 1-D for the interval [0,1]</div>

<div class="scrap"><a id='magicparlabel-338224' />
p = [1/2; (1+sqrt(5-2*sqrt(10/7))/3)/2; (1-sqrt(5-2*sqrt(10/7))/3)/2; ...</div>

<div class="scrap"><a id='magicparlabel-338225' />
     (1+sqrt(5+2*sqrt(10/7))/3)/2; (1-sqrt(5+2*sqrt(10/7))/3)/2];</div>

<div class="scrap"><a id='magicparlabel-338226' />
w = 0.5*[128/225; (322+13*sqrt(70))/900; (322+13*sqrt(70))/900; ...</div>

<div class="scrap"><a id='magicparlabel-338227' />
     (322-13*sqrt(70))/900; (322-13*sqrt(70))/900];</div>

<div class="scrap"><a id='magicparlabel-338228' />
@</div>
<h2 class="section"><span class="section_label">6</span> <a id='magicparlabel-338229' />
<a id="sec_Output_and_visualization" />
Output and visualization</h2>
<h3 class="subsection"><span class="subsection_label">6.1</span> <a id='magicparlabel-338230' />
<a id="sub_Visualization" />
Visualization</h3>
<div class="standard"><a id='magicparlabel-338231' />
Visualization of the results is greatly simplified by Matlab's trimesh() function. For example, to see a triangulation as given by (p,t), we use</div>

<div class="scrap"><a id='magicparlabel-338232' />
&lt;&lt;trimesh-example&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338233' />
trimesh(t,p(:,1),p(:,2))</div>

<div class="scrap"><a id='magicparlabel-338234' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">6.1.1</span> <a id='magicparlabel-338235' />
<a id="sub_Visualizing_solutions" />
Visualizing solutions (and mesh functions)</h4>
<div class="standard"><a id='magicparlabel-338236' />
One way of seeing the solution of a PDE (or some other quantity defined on a mesh for a certain element) is to get the list of variables associated with each point and plot those variable values. This will work for scalar element types of Lagrange type (such as the piecewise linear, quadratic, and cubic elements described in Sections&nbsp;<a href="#sub_Piecewise_linear_elements">4.1</a>, <a href="#sub_Piecewise_quadratic_elements">4.3</a>, and <a href="#sub_Piecewise_cubic_elements">4.4</a>). We can use the following routine:</div>

<div class="scrap"><a id='magicparlabel-338237' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338238' />
get-pvlist.m \</div>

<div class="scrap"><a id='magicparlabel-338239' />
&lt;&lt;get-pvlist.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338240' />
function pvlist = get_pvlist(fht,np)</div>

<div class="scrap"><a id='magicparlabel-338241' />
% function pvlist = get_pvlist(fht,np)</div>

<div class="scrap"><a id='magicparlabel-338242' />
%</div>

<div class="scrap"><a id='magicparlabel-338243' />
% Get list of variable indexes for the points.</div>

<div class="scrap"><a id='magicparlabel-338244' />
% That is, pvlist(i) is the variable number for the point</div>

<div class="scrap"><a id='magicparlabel-338245' />
% in the triangulation with index i.</div>

<div class="scrap"><a id='magicparlabel-338246' />
% As usual, np is the number of points.</div>

<div class="scrap"><a id='magicparlabel-338247' />
pvlist = zeros(np,1);</div>

<div class="scrap"><a id='magicparlabel-338248' />
for i = 1:np</div>

<div class="scrap"><a id='magicparlabel-338249' />
    pvlist(i) = fht(get_feature_ref(i,np));</div>

<div class="scrap"><a id='magicparlabel-338250' />
end</div>

<div class="scrap"><a id='magicparlabel-338251' />
@</div>

<div class="standard"><a id='magicparlabel-338252' />
Then we can view the solution via</div>

<div class="scrap"><a id='magicparlabel-338253' />
&lt;&lt;visualization-example&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338254' />
u = ...;  % compute solution</div>

<div class="scrap"><a id='magicparlabel-338255' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-338256' />
pvlist = get_pvlist(fht,np); </div>

<div class="scrap"><a id='magicparlabel-338257' />
trimesh(t,p(:,1),p(:,2),u(pvlist)) </div>

<div class="scrap"><a id='magicparlabel-338258' />
@</div>
<h4 class="subsubsection"><span class="subsubsection_label">6.1.2</span> <a id='magicparlabel-338259' />
<a id="sub_Boundary_visualization" />
Boundary visualization</h4>
<div class="standard"><a id='magicparlabel-338260' />
There are two functions for boundary visualization: one which plots just the boundary and one with the boundary and normal vectors.</div>

<div class="scrap"><a id='magicparlabel-338261' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338262' />
plot-boundary2d.m \</div>

<div class="scrap"><a id='magicparlabel-338263' />
&lt;&lt;plot-boundary2d.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338264' />
function plot_boundary2d(p,t,bb)</div>

<div class="scrap"><a id='magicparlabel-338265' />
% function plot_boundary2d(p,t,bb)</div>

<div class="scrap"><a id='magicparlabel-338266' />
%</div>

<div class="scrap"><a id='magicparlabel-338267' />
% Plots the boundary of a mesh in 2D given by p and t.</div>

<div class="scrap"><a id='magicparlabel-338268' />
% The i'th point is p(i,:), and triangle j is given by</div>

<div class="scrap"><a id='magicparlabel-338269' />
% points with indexes t(j,1), t(j,2) &amp; t(j,3).</div>

<div class="scrap"><a id='magicparlabel-338270' />
%</div>

<div class="scrap"><a id='magicparlabel-338271' />
% The bounding box is given in bb = [xmin, xmax, ymin,ymax].</div>

<div class="scrap"><a id='magicparlabel-338272' />
%</div>

<div class="scrap"><a id='magicparlabel-338273' />
% See distmesh.m etc.</div>

<div class="scrap"><a id='magicparlabel-338274' />
[bedges,bnodes] = boundary2d(t);</div>

<div class="scrap"><a id='magicparlabel-338275' />
bdry_tri = [bedges(:,1),bedges(:,2),bedges(:,2)];</div>

<div class="scrap"><a id='magicparlabel-338276' />
triplot(bdry_tri,p(:,1),p(:,2));</div>

<div class="scrap"><a id='magicparlabel-338277' />
axis(bb)</div>

<div class="scrap"><a id='magicparlabel-338278' />
@</div>

<div class="standard"><a id='magicparlabel-338279' />
And now with normal vectors (use with equal axes to preserve orthogonality):</div>

<div class="scrap"><a id='magicparlabel-338280' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338281' />
plot-boundary2dwnormals.m \</div>

<div class="scrap"><a id='magicparlabel-338282' />
&lt;&lt;plot-boundary2dwnormals.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338283' />
function plot_boundary2dwnormals(p,t,bb)</div>

<div class="scrap"><a id='magicparlabel-338284' />
% function plot_boundary2dwnormals(p,t,bb)</div>

<div class="scrap"><a id='magicparlabel-338285' />
%</div>

<div class="scrap"><a id='magicparlabel-338286' />
% Plots the boundary of a mesh in 2D given by p and t.</div>

<div class="scrap"><a id='magicparlabel-338287' />
% The i'th point is p(i,:), and triangle j is given by</div>

<div class="scrap"><a id='magicparlabel-338288' />
% points with indexes t(j,1), t(j,2) &amp; t(j,3).</div>

<div class="scrap"><a id='magicparlabel-338289' />
% The normals are also plotted from the center of each edge.</div>

<div class="scrap"><a id='magicparlabel-338290' />
% The length of the normal vectors is the length of the edge.</div>

<div class="scrap"><a id='magicparlabel-338291' />
%</div>

<div class="scrap"><a id='magicparlabel-338292' />
% The bounding box is given in bb = [xmin, xmax, ymin,ymax].</div>

<div class="scrap"><a id='magicparlabel-338293' />
%</div>

<div class="scrap"><a id='magicparlabel-338294' />
% See distmesh.m etc.</div>

<div class="scrap"><a id='magicparlabel-338295' />
[bedges,bnodes,normals] = boundary2d_2(p,t);</div>

<div class="scrap"><a id='magicparlabel-338296' />
bdry_tri = [bedges(:,1),bedges(:,2),bedges(:,2)];</div>

<div class="scrap"><a id='magicparlabel-338297' />
midpts = 0.5*(p(bedges(:,1),:)+p(bedges(:,2),:));</div>

<div class="scrap"><a id='magicparlabel-338298' />
len_edges = sqrt(sum((p(bedges(:,1),:)-p(bedges(:,2),:)).^2,2));</div>

<div class="scrap"><a id='magicparlabel-338299' />
arrowpts = midpts + diag(sparse(len_edges))*normals;</div>

<div class="scrap"><a id='magicparlabel-338300' />
hold on</div>

<div class="scrap"><a id='magicparlabel-338301' />
triplot(bdry_tri,p(:,1),p(:,2));</div>

<div class="scrap"><a id='magicparlabel-338302' />
arrow(midpts,arrowpts);</div>

<div class="scrap"><a id='magicparlabel-338303' />
axis(bb);</div>

<div class="scrap"><a id='magicparlabel-338304' />
hold off</div>

<div class="scrap"><a id='magicparlabel-338305' />
@</div>
<h3 class="subsection"><span class="subsection_label">6.2</span> <a id='magicparlabel-338306' />
<a id="sub_Refined_output" />
Refined output</h3>
<div class="standard"><a id='magicparlabel-338307' />
The results of trimesh() do not capture the higher order behavior of the mesh function or solution as it assumes the function is piecewise linear. To capture the quadratic or higher order behavior we need to create a sub-mesh and plot on the submesh. This can be done by, for example, creating a sub-mesh for the reference element, and then replacing each triangle in the triangulation with the reference element's sub-mesh transformed in the usual way (<math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover>
   <mrow><mo> mapstochar </mo><mo> &rarr; </mo>
   </mrow>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo>=</mo>
   <msub>
    <mrow><mi>T</mi>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
   <mover>
    <mrow>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle>
    </mrow><mo stretchy="true">&Hat;</mo>
   </mover><mo>+</mo>
   <msub>
    <mrow>
     <mstyle mathvariant='bold'><mi>b</mi>
     </mstyle>
    </mrow>
    <mrow><mi>K</mi>
    </mrow>
   </msub>
  </mrow>
 </mrow></math>). The values can then be computed on the sub-mesh of the original triangulation, and the result plotted using trimesh().</div>

<div class="standard"><a id='magicparlabel-338308' />
First we have code to create a sub-mesh for the reference element.</div>

<div class="scrap"><a id='magicparlabel-338309' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338310' />
ref-triangle-submesh.m \</div>

<div class="scrap"><a id='magicparlabel-338311' />
&lt;&lt;ref-triangle-submesh.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338312' />
function [p,t] = ref_triangle_submesh(n)</div>

<div class="scrap"><a id='magicparlabel-338313' />
% function [p,t] = ref_triangle_submesh(n)</div>

<div class="scrap"><a id='magicparlabel-338314' />
%</div>

<div class="scrap"><a id='magicparlabel-338315' />
% Creates a standard mesh on the reference triangle</div>

<div class="scrap"><a id='magicparlabel-338316' />
% (vertices at (0,0), (1,0) and (0,1)).</div>

<div class="scrap"><a id='magicparlabel-338317' />
% n+1 is the number of grid points on each edge</div>

<div class="scrap"><a id='magicparlabel-338318' />
% Generate points</div>

<div class="scrap"><a id='magicparlabel-338319' />
p = zeros(n*(n+1)/2,2);</div>

<div class="scrap"><a id='magicparlabel-338320' />
k = 1;</div>

<div class="scrap"><a id='magicparlabel-338321' />
for i = 0:n</div>

<div class="scrap"><a id='magicparlabel-338322' />
    for j = 0:n-i</div>

<div class="scrap"><a id='magicparlabel-338323' />
        p(k,:) = [i,j];</div>

<div class="scrap"><a id='magicparlabel-338324' />
        k = k+1;</div>

<div class="scrap"><a id='magicparlabel-338325' />
    end</div>

<div class="scrap"><a id='magicparlabel-338326' />
end</div>

<div class="scrap"><a id='magicparlabel-338327' />
p = p / n;</div>

<div class="scrap"><a id='magicparlabel-338328' />
% Create triangulation</div>

<div class="scrap"><a id='magicparlabel-338329' />
t = zeros(n*n,3);</div>

<div class="scrap"><a id='magicparlabel-338330' />
k = 1;</div>

<div class="scrap"><a id='magicparlabel-338331' />
idx = 1;</div>

<div class="scrap"><a id='magicparlabel-338332' />
for i = 0:n-1</div>

<div class="scrap"><a id='magicparlabel-338333' />
    for j = 0:n-i-1</div>

<div class="scrap"><a id='magicparlabel-338334' />
        if j &gt; 0</div>

<div class="scrap"><a id='magicparlabel-338335' />
            t(k,:) = [idx, idx+n-i, idx+n-i+1];</div>

<div class="scrap"><a id='magicparlabel-338336' />
            k = k+1;</div>

<div class="scrap"><a id='magicparlabel-338337' />
        end</div>

<div class="scrap"><a id='magicparlabel-338338' />
        t(k,:) = [idx, idx+n-i+1, idx+1];</div>

<div class="scrap"><a id='magicparlabel-338339' />
        k = k+1;</div>

<div class="scrap"><a id='magicparlabel-338340' />
        idx = idx+1;</div>

<div class="scrap"><a id='magicparlabel-338341' />
    end % for j</div>

<div class="scrap"><a id='magicparlabel-338342' />
    idx = idx+1;</div>

<div class="scrap"><a id='magicparlabel-338343' />
end % for i</div>

<div class="scrap"><a id='magicparlabel-338344' />
@</div>

<div class="standard"><a id='magicparlabel-338371' />
Once a sub-mesh for the reference element has been created, the creation of the sub-mesh of the original triangulation, and the computation of the values at the sub-mesh nodes, is handled by the following code. Let <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <mstyle mathvariant='bold'><mi>x</mi>
  </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math> be the mesh-based function represented by the values of vars. Then vals(i,1) contains <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
  <msub>
   <mrow>
    <mover>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle>
     </mrow><mo stretchy="true">&Tilde;</mo>
    </mover>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mover>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle>
     </mrow><mo stretchy="true">&Tilde;</mo>
    </mover>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <msub>
   <mrow>
    <mover>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle>
     </mrow><mo stretchy="true">&Tilde;</mo>
    </mover>
   </mrow>
   <mrow><mi>i</mi>
   </mrow>
  </msub>
 </mrow></math> is point <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>i</mi>
 </mrow></math> in the sub-mesh of the original triangulation, provided elt is a scalar element type. However, vals(i,r) contains <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>A</mi><mi>g</mi><mo>&af;</mo><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msub>
    <mrow>
     <mover>
      <mrow>
       <mstyle mathvariant='bold'><mi>x</mi>
       </mstyle>
      </mrow><mo stretchy="true">&Tilde;</mo>
     </mover>
    </mrow>
    <mrow><mi>i</mi>
    </mrow>
   </msub><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>A</mi>
 </mrow></math> is the <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mi>r</mi>
 </mrow></math>th operator (of order <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo> &le; </mo>
 </mrow></math>order) from the list of the operators for elt. In this way, derivative information can be also displayed; for vector element types, the different components can also be evaluated and displayed. For problems in elasticity, for example, components of the stress and strain tensors can be computed and displayed this way. </div>

<div class="scrap"><a id='magicparlabel-338394' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338403' />
get-submesh-vals.m \</div>

<div class="scrap"><a id='magicparlabel-338407' />
&lt;&lt;get-submesh-vals.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338415' />
function [pv,tv,vals] = get_submesh_vals(p,t,fht,elt,vars,p_ref,t_ref,order)</div>

<div class="scrap"><a id='magicparlabel-338417' />
% function [pv,tv,vals] = get_submesh_vals(p,t,fht,elt,vars,p_ref,t_ref,order)</div>

<div class="scrap"><a id='magicparlabel-338418' />
%</div>

<div class="scrap"><a id='magicparlabel-338419' />
% Return triangulation (pv,tv) and values (vals) for </div>

<div class="scrap"><a id='magicparlabel-338420' />
% the given variable values (vars).</div>

<div class="scrap"><a id='magicparlabel-338421' />
% Each triangle in the master triangulation (p,t)</div>

<div class="scrap"><a id='magicparlabel-338422' />
% is subdivided according to the triangulation given for</div>

<div class="scrap"><a id='magicparlabel-338423' />
% the reference element (p_ref,t_ref).</div>

<div class="scrap"><a id='magicparlabel-338424' />
%</div>

<div class="scrap"><a id='magicparlabel-338425' />
% The relationship between the elements of the master</div>

<div class="scrap"><a id='magicparlabel-338426' />
% triangulation (p,t) is given by fht and elt.</div>

<div class="scrap"><a id='magicparlabel-338427' />
%</div>

<div class="scrap"><a id='magicparlabel-338428' />
% Values and derivatives up to the given order are returned in vals.</div>

<div class="scrap"><a id='magicparlabel-338429' />
% Get the values for the basis functions on p_ref</div>

<div class="scrap"><a id='magicparlabel-338430' />
Aphihat = cell(size(p_ref,1),1);</div>

<div class="scrap"><a id='magicparlabel-338431' />
for i = 1:size(p_ref,1)</div>

<div class="scrap"><a id='magicparlabel-338432' />
    Aphihat{i} = elt.get_Aphihat(p_ref(i,:),order);</div>

<div class="scrap"><a id='magicparlabel-338433' />
end</div>

<div class="scrap"><a id='magicparlabel-338434' />
np = size(p,1);</div>

<div class="scrap"><a id='magicparlabel-338435' />
np_ref = size(p_ref,1);</div>

<div class="scrap"><a id='magicparlabel-338436' />
nt_ref = size(t_ref,1);</div>

<div class="scrap"><a id='magicparlabel-338437' />
pv = zeros(size(t,1)*np_ref,2);</div>

<div class="scrap"><a id='magicparlabel-338438' />
tv = zeros(size(t,1)*nt_ref,3);</div>

<div class="scrap"><a id='magicparlabel-338439' />
vals = zeros(size(t,1)*np_ref,size(Aphihat{1},2));</div>

<div class="scrap"><a id='magicparlabel-338440' />
for i = 1:size(t,1)</div>

<div class="scrap"><a id='magicparlabel-338441' />
    T = [p(t(i,2),:)'-p(t(i,1),:)', p(t(i,3),:)'-p(t(i,1),:)'];</div>

<div class="scrap"><a id='magicparlabel-338442' />
    b = p(t(i,1),:)';</div>

<div class="scrap"><a id='magicparlabel-338443' />
    pv((i-1)*np_ref+(1:np_ref),:) = p_ref*T'+ones(np_ref,1)*b';</div>

<div class="scrap"><a id='magicparlabel-338444' />
    tv((i-1)*nt_ref+(1:nt_ref),:) = t_ref+(i-1)*np_ref;</div>

<div class="scrap"><a id='magicparlabel-338445' />
    % get variable indexes</div>

<div class="scrap"><a id='magicparlabel-338446' />
    [vlist,slist] = get_var_triangle(t(i,:),fht,elt,np);</div>

<div class="scrap"><a id='magicparlabel-338447' />
    % basis function values</div>

<div class="scrap"><a id='magicparlabel-338448' />
    for j = 1:np_ref</div>

<div class="scrap"><a id='magicparlabel-338449' />
        Aphival = elt.trans_Aphihat(T,Aphihat{j},order);</div>

<div class="scrap"><a id='magicparlabel-338450' />
        vals((i-1)*np_ref+j,:) = (vars(vlist)'.*slist)*Aphival;</div>

<div class="scrap"><a id='magicparlabel-338451' />
    end % for j</div>

<div class="scrap"><a id='magicparlabel-338452' />
end % for i</div>

<div class="scrap"><a id='magicparlabel-338453' />
end % function</div>

<div class="scrap"><a id='magicparlabel-338411' />
@</div>
<h2 class="section"><span class="section_label">7</span> <a id='magicparlabel-338345' />
<a id="sec_Makefiles_etc" />
Makefiles and using Noweb</h2>
<div class="standard"><a id='magicparlabel-338346' />
This article is a simple test for using Noweb for mixing code and documentation. One difficulty with using Noweb is that there is no automatic way of generating all code files. However, we can use a <em>Makefile</em> to identify all actual code files and so that we can obtain all the code files by means of the following code fragment:</div>

<div class="scrap"><a id='magicparlabel-338347' />
&lt;&lt;gen-all-files&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338348' />
notangle -t8 -RMakefile pde-code.nw &gt; Makefile</div>

<div class="scrap"><a id='magicparlabel-338349' />
make all</div>

<div class="scrap"><a id='magicparlabel-338350' />
@</div>

<div class="standard"><a id='magicparlabel-338351' />
The &ldquo;-t8&rdquo; option is to ensure that tabs are passed without conversion to spaces.</div>

<div class="standard"><a id='magicparlabel-338352' />
The <em>Makefile</em> will know which files to create and the procedure for creating them. The code chunk <em>filelist</em> contains the list of files to create (on separate lines but with &ldquo;\&rdquo; at the end of each line). <div class="note_comment"><div class="plain_layout"><a id='magicparlabel-338356' />
Because of this we need a blank line following the <em>filelist</em> chunk.</div>
</div></div>

<div class="scrap"><a id='magicparlabel-338357' />
&lt;&lt;Makefile&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-338358' />
files = &lt;&lt;filelist&gt;&gt;</div>

<div class="scrap"><a id='magicparlabel-338359' />
        pde-code.tex filelist</div>

<div class="scrap"><a id='magicparlabel-338360' />
source = pde-code.nw</div>

<div class="scrap"><a id='magicparlabel-338361' />
all: $(files)</div>

<div class="scrap"><a id='magicparlabel-338362' />
$(files): $(source)</div>

<div class="scrap"><a id='magicparlabel-338363' />
	notangle -R$@ $(source) &gt; $@</div>

<div class="scrap"><a id='magicparlabel-338364' />
pde-code.tex: $(source)</div>

<div class="scrap"><a id='magicparlabel-338365' />
	noweave -delay -index $(source) &gt; $@</div>

<div class="scrap"><a id='magicparlabel-338366' />
@</div>

<div class="standard"><a id='magicparlabel-415698' />
Unfortunately Noweb does not like underscores (_) while Matlab M-files cannot have dashes (-) in the file name. So in this file all the Matlab source files have underscores replaced by dashes. To fix that and be able to run in Matlab, a script has been included to help you do this:</div>

<div class="scrap"><a id='magicparlabel-415733' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-415740' />
filenamehack.bash \</div>

<div class="scrap"><a id='magicparlabel-415744' />
&lt;&lt;filenamehack.bash&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-415753' />
#!/bin/bash</div>

<div class="scrap"><a id='magicparlabel-418867' />
for f in `cat filelist`; do</div>

<div class="scrap"><a id='magicparlabel-418868' />
  if [[ "$f" =~ .*-.*\.m ]] </div>

<div class="scrap"><a id='magicparlabel-418869' />
  then mv "$f" `echo "$f" | sed -e s/-/_/g`</div>

<div class="scrap"><a id='magicparlabel-418870' />
  fi</div>

<div class="scrap"><a id='magicparlabel-418871' />
done </div>

<div class="scrap"><a id='magicparlabel-415749' />
@</div>

<div class="standard"><a id='magicparlabel-420420' />
To use this script in Unix (or Cygwin or &hellip;), just use the command &ldquo;bash filenamehack.bash&rdquo;.</div>
<h2 class="section"><span class="section_label">8</span> <a id='magicparlabel-338367' />
<a id="sec_Test_code" />
Test code</h2>
<h3 class="subsection"><span class="subsection_label">8.1</span> <a id='magicparlabel-345902' />
Checking consistency of element values and derivatives</h3>
<div class="standard"><a id='magicparlabel-345917' />
Checking the consistency between the element values and the derivatives the element structure provides is an important part of testing. The following code checks consistency of derivatives and values up to the 2nd order derivatives for two-dimensional scalar elements. this uses centered difference approximations; <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>d</mi>
  </mstyle>
 </mrow></math> should be small. This code returns <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mfrac>
   <mrow>
    <mrow>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo>+</mo>
      <mstyle mathvariant='bold'><mi>d</mi>
      </mstyle>
     </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>-</mo>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo>-</mo>
      <mstyle mathvariant='bold'><mi>d</mi>
      </mstyle>
     </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>-</mo><mn>2</mn>
     <msup>
      <mrow>
       <mstyle mathvariant='bold'><mi>d</mi>
       </mstyle>
      </mrow>
      <mrow><mi>T</mi>
      </mrow>
     </msup><mi> &nabla; </mi>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
    </mrow>
   </mrow>
   <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
    <mstyle mathvariant='bold'><mi>d</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
   </mrow>
  </mfrac>
 </mrow></math>and<math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mfrac>
   <mrow>
    <mrow><mi> &nabla; </mi>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo>+</mo>
      <mstyle mathvariant='bold'><mi>d</mi>
      </mstyle>
     </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>-</mo><mi> &nabla; </mi>
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mrow>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo>-</mo>
      <mstyle mathvariant='bold'><mi>d</mi>
      </mstyle>
     </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mo>-</mo><mn>2</mn>
     <mstyle class='mathbox'>
      <mrow>Hess
      </mrow>
     </mstyle><mspace width="6px" />
     <msub>
      <mrow><mi> &phi; </mi>
      </mrow>
      <mrow><mi>i</mi>
      </mrow>
     </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mstyle mathvariant='bold'><mi>x</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo><mspace width="6px" />
     <mstyle mathvariant='bold'><mi>d</mi>
     </mstyle>
    </mrow>
   </mrow>
   <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
    <mstyle mathvariant='bold'><mi>d</mi>
    </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
   </mrow>
  </mfrac>
 </mrow></math>where <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <mstyle class='mathbox'>
    <mrow>Hess
    </mrow>
   </mstyle><mspace width="6px" /><mi> &psi; </mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math> is the Hessian matrix of 2nd order partial derivatives: <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow>
   <msub>
    <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
     <mrow>
      <mstyle class='mathbox'>
       <mrow>Hess
       </mrow>
      </mstyle><mspace width="6px" /><mi> &psi; </mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
      <mstyle mathvariant='bold'><mi>x</mi>
      </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
     </mrow><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
    </mrow>
    <mrow>
     <mrow><mi>p</mi><mi>q</mi>
     </mrow>
    </mrow>
   </msub><mo>=</mo>
   <msup>
    <mrow><mi> &part; </mi>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mi> &psi; </mi><mo>/</mo><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mi>p</mi>
    </mrow>
   </msub><mi> &part; </mi>
   <msub>
    <mrow><mi>x</mi>
    </mrow>
    <mrow><mi>q</mi>
    </mrow>
   </msub><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <mstyle mathvariant='bold'><mi>x</mi>
   </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>. Provided <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>d</mi>
  </mstyle>
 </mrow></math> is small on the scale of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>x</mi>
  </mstyle>
 </mrow></math>, both ratios should be <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mrow><mi>O</mi><mo form='prefix' fence='true' stretchy='true' symmetric='true'>(</mo>
   <msup>
    <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
     <mstyle mathvariant='bold'><mi>d</mi>
     </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
    </mrow>
    <mrow><mn>2</mn>
    </mrow>
   </msup><mo form='postfix' fence='true' stretchy='true' symmetric='true'>)</mo>
  </mrow>
 </mrow></math>, and so be small compared to <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow><mo form='prefix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
  <mstyle mathvariant='bold'><mi>d</mi>
  </mstyle><mo form='postfix' fence='true' stretchy='true' symmetric='true'>Vert</mo>
 </mrow></math>. If you are not sure how small is &ldquo;small&rdquo;, reduce the size of <math xmlns="http://www.w3.org/1998/Math/MathML">
 <mrow>
  <mstyle mathvariant='bold'><mi>d</mi>
  </mstyle>
 </mrow></math> by a factor of two or ten, and repeat the computation. The returned values should be reduced by a factor of four or a hundred, respectively.</div>

<div class="scrap"><a id='magicparlabel-345952' />
&lt;&lt;filelist&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-345959' />
check-derivs.m \</div>

<div class="scrap"><a id='magicparlabel-345963' />
&lt;&lt;check-derivs.m&gt;&gt;=</div>

<div class="scrap"><a id='magicparlabel-345971' />
function [err_dphi,err_ddphi] = check_derivs(Aphifunc,x,d)</div>

<div class="scrap"><a id='magicparlabel-345973' />
% function [err_dphi,err_ddphi] = check_derivs(Aphifunc,x,d)</div>

<div class="scrap"><a id='magicparlabel-345974' />
%</div>

<div class="scrap"><a id='magicparlabel-345975' />
% Returns errors in derivative test: err_dphi is the error vector for</div>

<div class="scrap"><a id='magicparlabel-345976' />
% (phi(x+d)-phi(x-d)-2*grad phi(x)'*d)/norm(d),</div>

<div class="scrap"><a id='magicparlabel-345977' />
% err_ddphi is the error vector for</div>

<div class="scrap"><a id='magicparlabel-345978' />
% (grad phi(x+d)-grad phi(x-d)-2*Hess phi(x)*d)/norm(d).</div>

<div class="scrap"><a id='magicparlabel-345979' />
%</div>

<div class="scrap"><a id='magicparlabel-345980' />
% Assumes scalar element: order of rows:</div>

<div class="scrap"><a id='magicparlabel-345981' />
% [phi(x), (d/dx1)phi(x), (d/dx2)phi(x), (d^2/dx1^2)phi(x), ...</div>

<div class="scrap"><a id='magicparlabel-345982' />
% (d^2/dx1.dx2)phi(x), (d^2/dx2^2)phi(x)]</div>

<div class="scrap"><a id='magicparlabel-345983' />
Aphivalx   = Aphifunc(x,2);</div>

<div class="scrap"><a id='magicparlabel-345984' />
Aphivalxpd = Aphifunc(x+d,2);</div>

<div class="scrap"><a id='magicparlabel-345985' />
Aphivalxmd = Aphifunc(x-d,2);</div>

<div class="scrap"><a id='magicparlabel-345986' />
phixpd = Aphivalxpd(:,1);</div>

<div class="scrap"><a id='magicparlabel-345987' />
phixmd = Aphivalxmd(:,1);</div>

<div class="scrap"><a id='magicparlabel-345988' />
dphix  = Aphivalx(:,2:3);</div>

<div class="scrap"><a id='magicparlabel-345989' />
err_dphi = (phixpd-phixmd-2*dphix*d)/norm(d);</div>

<div class="scrap"><a id='magicparlabel-345990' />
dphixpd = Aphivalxpd(:,2:3);</div>

<div class="scrap"><a id='magicparlabel-345991' />
dphixmd = Aphivalxmd(:,2:3);</div>

<div class="scrap"><a id='magicparlabel-345992' />
ddphix  = Aphivalx(:,4:6);</div>

<div class="scrap"><a id='magicparlabel-345993' />
err_ddphi = (dphixpd-dphixmd-2*(d(1)*ddphix(:,1:2)+d(2)*ddphix(:,2:3)))/norm(d);</div>

<div class="scrap"><a id='magicparlabel-345967' />
@</div>
<h3 class="subsection"><span class="subsection_label">8.2</span> <a id='magicparlabel-345910' />
Testing overall system</h3>
<div class="standard"><a id='magicparlabel-338368' />
<h2 class='bibtex'>References</h2></div>
</body>
</html>
