#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass literate-article
\use_default_options true
\begin_modules
noweb
theorems-std
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman palatino
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command makeindex
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Finite element code: PDE
\end_layout

\begin_layout Author
David E.
 Stewart
\end_layout

\begin_layout Date
July 9th, 2012
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Overview"

\end_inset

Overview
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\R}{\mathbb{R}}
\end_inset

This describes a pure Matlab finite element code for two dimensional problems.
 It is assumed that a triangulation of the domain is given in the same format
 as the output from the Persson & Strang Matlab triangulation code 
\begin_inset CommandInset citation
LatexCommand cite
key "ps:smgm"

\end_inset

.
 That is, the basic triangulation data is given in the form of a pair 
\begin_inset Formula $(p,t)$
\end_inset

 where 
\begin_inset Formula $p$
\end_inset

 is an array of points: point 
\begin_inset Formula $p_{i}$
\end_inset

 is 
\family typewriter
p(i,:)
\family default
, while triangle 
\begin_inset Formula $i$
\end_inset

 is the triangle with vertices 
\family typewriter
p(j,:)
\family default
, 
\family typewriter
p(k,:)
\family default
, 
\family typewriter
p(l,:)
\family default
 where 
\family typewriter
j = t(i,1)
\family default
, 
\family typewriter
k = t(i,2)
\family default
 and 
\family typewriter
l = t(i,3)
\family default
.
 This can be generalized to tetrahedra in three dimensions, etc.
 This also works well with the Matlab 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
trimesh()
\end_layout

\end_inset

trimesh()
\family default
 function for plotting two-dimensional meshes.
\end_layout

\begin_layout Standard
There are a number of different element types, most notably 
\begin_inset Index idx
status open

\begin_layout Plain Layout
element!Lagrange
\end_layout

\end_inset

Lagrange elements which represent scalar piecewise polynomials (that is,
 the restriction of the basis functions to each triangle is a polynomial).
 The simplest of these is the Lagrange piecewise linear element, but quadratic
 and cubic Lagrangian elements have also been implemented.
 Extensions to 
\begin_inset Formula $C^{1}$
\end_inset

 elements (such as Bell's triangle and the Argyris element) are also planned,
 but not yet implemented.
 Code for the elements can be found in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Element-types"

\end_inset

.
\end_layout

\begin_layout Standard
Since the values at certain points are shared by elements on different (but
 touching) triangles, we need a way to determine when these values are shared.
 This is done via a geometric feature hash table.
 Code for these aspects can be found in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Handling-geometric-features"

\end_inset

.
\end_layout

\begin_layout Standard
The core routines are the assembly routines which form the matrices and
 vectors for the linear systems to be solved.
 These are for both the Galerkin and Petrov--Galerkin methods.
 Similar routines are provided for handling boundary values and conditions.
 Code for matrix assembly can be found in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Matrix-assembly-code"

\end_inset

.
 Part of this process is the task of numerical integration.
 Integration rules can be found in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Numerical-integration"

\end_inset

.
\end_layout

\begin_layout Standard
Testing codes can be found in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Test-code"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Basic-organization"

\end_inset

Basic organization
\end_layout

\begin_layout Standard
Each element type must be able to compute the values of the basis functions
 at each point of the reference triangle 
\begin_inset Formula $\widehat{K}=\mbox{co}\left\{ \,(0,0),\,(1,0),\,(0,1)\,\right\} $
\end_inset

, along with the values of a number of 
\emph on
operators
\emph default
 applied to the basis functions.
 That is, for a point 
\begin_inset Formula $\widehat{\mathbf{x}}\in\widehat{K}$
\end_inset

 and basis function 
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

 on 
\begin_inset Formula $\widehat{K}$
\end_inset

 we need to be able to compute not only 
\begin_inset Formula $\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

, but also 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 where 
\begin_inset Formula $\mathcal{A}=\partial/\partial x_{1}$
\end_inset

, 
\begin_inset Formula $\mathcal{A}=\partial/\partial x_{2}$
\end_inset

; sometimes higher order derivatives are also necessary, such as for 4th
 order PDEs.
 In that case, each element can also compute 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 where 
\begin_inset Formula $\mathcal{A}=\partial^{2}/\partial x_{1}^{2}$
\end_inset

, 
\begin_inset Formula $\mathcal{A}=\partial^{2}/\partial x_{1}\,\partial x_{2}$
\end_inset

 and 
\begin_inset Formula $\mathcal{A}=\partial^{2}/\partial x_{2}^{2}$
\end_inset

.
 The ordering of these operators is essentially fixed across the different
 element types.
\end_layout

\begin_layout Standard
There are also elements for providing vector-valued basis functions, in
 which case we also need to use different operators: 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})=\widehat{\phi}_{i}(\widehat{\mathbf{x}})\cdot\mathbf{e}_{1}$
\end_inset

, 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})=\widehat{\phi}_{i}(\widehat{\mathbf{x}})\cdot\mathbf{e}_{2}$
\end_inset

, 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})=\partial\widehat{\phi}_{i}(\widehat{\mathbf{x}})/\partial x_{1}\cdot\mathbf{e}_{1}$
\end_inset

, etc.
 
\end_layout

\begin_layout Standard
Basis functions on the reference element 
\begin_inset Formula $\widehat{K}$
\end_inset

 are used to create basis functions on the actual elements 
\begin_inset Formula $K=\mbox{co}\left\{ \,\mathbf{p}_{j},\,\mathbf{p}_{k},\,\mathbf{p}_{\ell}\,\right\} $
\end_inset

 by means of an affine transformation 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

 with 
\begin_inset Formula $T_{K}$
\end_inset

 and 
\begin_inset Formula $\mathbf{b}_{K}$
\end_inset

 computed from 
\begin_inset Formula $\mathbf{p}_{j},\,\mathbf{p}_{k},\,\mathbf{p}_{\ell}$
\end_inset

.
 This also transforms that values of 
\begin_inset Formula $\mathcal{A}'\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 to compute 
\begin_inset Formula $\mathcal{A}\phi_{i}(\mathbf{x})$
\end_inset

: 
\begin_inset Formula $\phi_{i}(\mathbf{x})=\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

, but 
\begin_inset Formula 
\[
\frac{\partial\phi_{i}}{\partial x_{1}}(\mathbf{x})=\frac{\partial\widehat{\phi}_{i}}{\partial\widehat{x}_{1}}(\widehat{\mathbf{x}})\frac{\partial\widehat{x}_{1}}{\partial x_{1}}(\mathbf{x})+\frac{\partial\widehat{\phi}_{i}}{\partial\widehat{x}_{2}}(\widehat{\mathbf{x}})\frac{\partial\widehat{x}_{2}}{\partial x_{1}}(\mathbf{x}),
\]

\end_inset

for example.
 The derivatives 
\begin_inset Formula $\partial\widehat{x}_{i}/\partial x_{i}$
\end_inset

 are entries of the 
\begin_inset Formula $T_{K}$
\end_inset

 matrix.
 In fact, 
\begin_inset Formula 
\[
\nabla\phi_{i}(\mathbf{x})=(T_{K})^{T}\nabla\widehat{\phi}_{i}(\widehat{\mathbf{x}}).
\]

\end_inset


\end_layout

\begin_layout Standard
The matrix entries are formed by means of integrals
\begin_inset Formula 
\begin{eqnarray*}
a_{ij} & = & \int_{\Omega}\sum_{\mathcal{A},\mathcal{B}}c_{\mathcal{A},\mathcal{B}}(\mathbf{x})\,\mathcal{A}\phi_{i}(\mathbf{x})\,\mathcal{B}\phi_{j}(\mathbf{x})\, d\mathbf{x}\\
 & = & \sum_{K}\int_{K}\sum_{\mathcal{A},\mathcal{B}}c_{\mathcal{A},\mathcal{B}}(\mathbf{x})\,\mathcal{A}\phi_{i}(\mathbf{x})\,\mathcal{B}\phi_{j}(\mathbf{x})\, d\mathbf{x}.
\end{eqnarray*}

\end_inset

The sum over 
\begin_inset Formula $\mathcal{A}$
\end_inset

 and 
\begin_inset Formula $\mathcal{B}$
\end_inset

 is over all the operators used to define the Galerkin form of the partial
 differential equations; the sum over 
\begin_inset Formula $K$
\end_inset

 is the sum over all the triangles of the triangulation.
 To compute the integral over 
\begin_inset Formula $K$
\end_inset

 we use rules for integration over the reference triangle 
\begin_inset Formula $\widehat{K}$
\end_inset

.
 
\end_layout

\begin_layout Standard
For the Petrov--Galerkin method, we can use different basis functions (and
 thus different element types), but they must be based on the same triangulation
:
\begin_inset Formula 
\[
b_{ij}=\sum_{K}\int_{K}\sum_{\mathcal{A},\mathcal{B}}c_{\mathcal{A},\mathcal{B}}(\mathbf{x})\,\mathcal{A}\psi_{i}(\mathbf{x})\,\mathcal{B}\phi_{j}(\mathbf{x})\, d\mathbf{x}.
\]

\end_inset

There are also matrix assembly routines for boundaries.
 Boundaries of two-dimensional regions are given as sets of edges (each
 edge being a pair of indexes into the point array 
\family typewriter
p
\family default
).
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:PDE-representation"

\end_inset

PDE representation
\begin_inset Index idx
status open

\begin_layout Plain Layout
PDE representation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The PDE itself is represented by 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
pde
\end_layout

\end_inset

pde
\family default
 structure, which is based on the Galerkin (or Galerkin--Petrov) method.
 If the weak form is of the Galerkin type:
\begin_inset Formula 
\[
\int_{\Omega}\sum_{\mathcal{A},\mathcal{B}}c_{\mathcal{A},\mathcal{B}}(\mathbf{x})\,\mathcal{A}v(\mathbf{x})\,\mathcal{B}u(\mathbf{x})\, d\mathbf{x}=\int_{\Omega}\sum_{\mathcal{A}}f_{\mathcal{A}}(\mathbf{x})\,\mathcal{A}v(\mathbf{x})\, d\mathbf{x}\qquad\mbox{for all }v\in\mbox{span}\left\{ \phi_{i}\right\} _{i=1}^{N},
\]

\end_inset

then 
\family typewriter
pde
\family default
 consists of the maximum order of the operators 
\begin_inset Formula $\mathcal{A}$
\end_inset

 and 
\begin_inset Formula $\mathcal{B}$
\end_inset

, together with the functions 
\begin_inset Formula $C\colon\Omega\to\R^{M\times M}$
\end_inset

 and 
\begin_inset Formula $\mathbf{f}\colon\Omega\to\R^{M}$
\end_inset

 where 
\begin_inset Formula $M$
\end_inset

 is the number of operators 
\begin_inset Formula $\mathcal{A}$
\end_inset

 considered.
 For example, for a scalar problem in two dimensions where the Galerkin
 form only involves function values and first derivatives, 
\begin_inset Formula $\mathcal{A}$
\end_inset

 can be 
\begin_inset Formula $I$
\end_inset

 (identity) for the function values, 
\begin_inset Formula $\partial/\partial x_{1}$
\end_inset

, or 
\begin_inset Formula $\partial/\partial x_{2}$
\end_inset

 for the first derivatives.
 Then 
\begin_inset Formula $M=3$
\end_inset

.
 
\end_layout

\begin_layout Standard
For the PDE 
\begin_inset Formula $-\Delta u=f(\mathbf{x})$
\end_inset

 with 
\begin_inset Formula $f(\mathbf{x})=x_{1}^{2}\,\exp(x_{2})$
\end_inset

, we use:
\end_layout

\begin_layout Scrap
<<pde-struct-eg>>=
\end_layout

\begin_layout Scrap
pde = struct('coeffs',@(x)diag([0,1,1]), ...
\end_layout

\begin_layout Scrap
        'rhs',@(x)[x(1)^2*exp(x(2));0;0],'order',1)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Usage"

\end_inset

Usage
\end_layout

\begin_layout Standard
Were we present an example of the solution of
\begin_inset Formula 
\begin{eqnarray*}
-\Delta u & = & f(\mathbf{x})\qquad\mbox{in }\Omega,\\
u(\mathbf{x}) & = & g(\mathbf{x})\qquad\mbox{on }\partial\Omega.
\end{eqnarray*}

\end_inset

As usual 
\begin_inset Formula $\partial\Omega$
\end_inset

 is the boundary of 
\begin_inset Formula $\Omega$
\end_inset

, and 
\begin_inset Formula $\Delta u=\partial^{2}u/\partial x_{1}^{2}+\partial^{2}u/\partial x_{2}^{2}$
\end_inset

 is the Laplacian operator.
 This is an elliptic partial differential operator of second order with
 Dirichlet (forced) boundary conditions.
\end_layout

\begin_layout Standard
The weak form of this PDE is
\begin_inset Formula 
\[
\int_{\Omega}\left[\frac{\partial u}{\partial x_{1}}\frac{\partial v}{\partial x_{1}}+\frac{\partial u}{\partial x_{2}}\frac{\partial v}{\partial x_{2}}\right]d\mathbf{x}=\int_{\Omega}\nabla u\cdot\nabla v\, d\mathbf{x}=\int_{\Omega}f(\mathbf{x})\, v(\mathbf{x})\, d\mathbf{x}
\]

\end_inset

for all 
\begin_inset Formula $v$
\end_inset

 that is 
\begin_inset Quotes eld
\end_inset

nice
\begin_inset Quotes erd
\end_inset

 and satisfies 
\begin_inset Formula $v(\mathbf{x})=0$
\end_inset

 for all 
\begin_inset Formula $\mathbf{x}\in\partial\Omega$
\end_inset

.
 Here 
\begin_inset Quotes eld
\end_inset

nice
\begin_inset Quotes erd
\end_inset

 can mean smooth, but it is also true when 
\begin_inset Formula $v$
\end_inset

 is a piecewise linear function over the triangulation with 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $v=0$
\end_inset

 on 
\begin_inset Formula $\partial\Omega$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
The domain 
\begin_inset Formula $\Omega$
\end_inset

 has to be defined according to the problem.
 An example is a square 
\begin_inset Formula $[-1,\,+1]\times[-1,\,+1]$
\end_inset

 with a circle center at the origin and radius 1/2 removed.
 A triangulation can be computed using 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
distmesh2d()
\end_layout

\end_inset

distmesh
\family default
 from Persson and Strang (URL 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://persson.berkeley.edu/distmesh/
\end_layout

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "ps:smgm"

\end_inset

 as follows:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
usage.m
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
usage.m 
\backslash

\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
fd = @(p)ddiff(drectangle(p,-1,1,-1,1),dcircle(p,0,0,0.5))
\end_layout

\begin_layout Scrap
fh = @(p)min(4*sqrt(sum(p.^2,2))-1,2)
\end_layout

\begin_layout Scrap
[p,t]=distmesh2d(fd,fh,0.1,[-1,-1;1,1],[-1,-1;-1,1;1,-1;1,1]);
\end_layout

\begin_layout Scrap
np = size(p,1)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The 
\family typewriter
fd
\family default
 function defines the region, while 
\family typewriter
fh
\family default
 is used to control the variation of the triangle sizes.
 Then 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
distmesh2d()
\end_layout

\end_inset

distmesh2d()
\family default
 itself creates the triangulation.
 See the documentation on
\family typewriter
 distmesh
\family default
 for more information.
 The last line just tells us the number of points in the triangulation.
 The triangulation is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Mesh-distmesh"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename usage-mesh.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Mesh-distmesh"

\end_inset

Mesh produced by 
\family typewriter
distmesh2d()
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the triangulation has been computed, we can create the element type
 (piecewise linear
\begin_inset Index idx
status open

\begin_layout Plain Layout
element!piecewise linear
\end_layout

\end_inset

):
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
lin2d = lin2d_elt()
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The triangulation and the element type together determine the variables:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
fht = create_fht(p,t,lin2d)
\end_layout

\begin_layout Scrap
nv = fht_num_vars(fht)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Here 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
fht
\end_layout

\end_inset

fht
\family default
 is the geometric feature hash table, which relates geometric features (triangle
s, edges, vertices) with variable indexes.
 The value of 
\family typewriter
nv
\family default
 is the number of variables in the system.
\end_layout

\begin_layout Standard
Since the weak form of the PDE is
\begin_inset Formula 
\[
\int_{\Omega}\left[\frac{\partial u}{\partial x_{1}}\frac{\partial v}{\partial x_{1}}+\frac{\partial u}{\partial x_{2}}\frac{\partial v}{\partial x_{2}}\right]d\mathbf{x}=\int_{\Omega}f(\mathbf{x})\, v(\mathbf{x})\, d\mathbf{x}
\]

\end_inset

where 
\begin_inset Formula $v=0$
\end_inset

 on 
\begin_inset Formula $\partial\Omega$
\end_inset

, the PDE structure representing this for 
\begin_inset Formula $f(\mathbf{x})=10x_{1}^{2}\exp(x_{2})$
\end_inset

 is
\begin_inset Index idx
status open

\begin_layout Plain Layout
PDE representation
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
f = @(x)(10*x(1)^2*exp(x(2)))
\end_layout

\begin_layout Scrap
pde = struct('coeffs',@(x)diag([0,1,1]),'rhs',@(x)[f(x);0;0],'order',1)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
coeffs
\end_layout

\end_inset

coeffs
\family default
 component is a function returning a matrix that represents the bilinear
 weak form above:
\begin_inset Formula 
\[
\frac{\partial u}{\partial x_{1}}\frac{\partial v}{\partial x_{1}}+\frac{\partial u}{\partial x_{2}}\frac{\partial v}{\partial x_{2}}=\left[\begin{array}{c}
v\\
\partial v/\partial x_{1}\\
\partial v/\partial x_{2}
\end{array}\right]^{T}\left[\begin{array}{ccc}
0 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{array}\right]\left[\begin{array}{c}
u\\
\partial u/\partial x_{1}\\
\partial u/\partial x_{2}
\end{array}\right].
\]

\end_inset

The 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
rhs
\end_layout

\end_inset

rhs
\family default
 component is a function returning a vector that represents the linear part
 of the weak form (on the right):
\begin_inset Formula 
\[
f(\mathbf{x})\, v(\mathbf{x})=\left[\begin{array}{c}
v(\mathbf{x})\\
\partial v/\partial x_{1}(\mathbf{x})\\
\partial v/\partial x_{2}(\mathbf{x})
\end{array}\right]^{T}\left[\begin{array}{c}
f(\mathbf{x})\\
0\\
0
\end{array}\right].
\]

\end_inset

The 
\family typewriter
order
\family default
 component is set to one to indicate that only function values and first
 order derivatives are needed.
 The maximum value of 
\family typewriter
order
\family default
 (in the current code) is two.
\end_layout

\begin_layout Standard
Now we need to create the matrix and right-hand side vector for the linear
 system to solve.
 First we assemble the matrix and right-hand side vector for the PDE.
 As yet, this does not deal with boundary values: 
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
% Initialize A and b 
\end_layout

\begin_layout Scrap
A = sparse(nv,nv); 
\end_layout

\begin_layout Scrap
b = zeros(nv,1); 
\end_layout

\begin_layout Scrap
% Assemble matrix and vector  
\end_layout

\begin_layout Scrap
[A,b] = assembly2d(A,b,pde,lin2d,p,t,fht,@int2d_radon7); 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that the matrix 
\begin_inset Formula $A$
\end_inset

 is created as a sparse matrix.
 It is not necessary to do so, but it is recommended as the systems created
 are generally very sparse.
 The vector 
\begin_inset Formula $\mathbf{b}$
\end_inset

 does not need to be created as a sparse vector.
 These are initialized to zero by the 
\family typewriter
sparse()
\family default
 and 
\family typewriter
zeros()
\family default
 functions.
 The 
\family typewriter
assembly2d()
\family default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
assembly2d()
\end_layout

\end_inset

function adds the assembled matrices and vectors to the pre-existing 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\mathbf{b}$
\end_inset

; this feature is useful if you are combining several different partial
 differential operators into one.
 An integration method needed to be selected: Radon's 7-point scheme for
 triangles is 5th order accurate, which is sufficient for our purposes.
\end_layout

\begin_layout Standard
Since we have 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Dirichlet boundary conditions
\end_layout

\end_inset

Dirichlet boundary conditions, we need to explicitly set the values of the
 variables of the boundary nodes according to 
\begin_inset Formula $g(\mathbf{x})$
\end_inset

.
 First we need to identify the boundary edges and nodes:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
[bedges,bnodes,t_index] = boundary2d(t);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
There are several ways of setting boundary values.
 The method presented here essentially solves a least squares problem to
 find the finite element function that best approximates the given 
\begin_inset Formula $g(\mathbf{x})$
\end_inset

.
 This shows another usage of the PDE data structure
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
pde
\end_layout

\end_inset

 as well as the boundary assembly function for 
\begin_inset Formula $g(\mathbf{x})=\cos(x_{1})\, x_{2}$
\end_inset

:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
g = @(x)(cos(x(1))*x(2))
\end_layout

\begin_layout Scrap
pde2 = struct('coeffs',@(x)[1],'rhs',@(x)g(x),'order',0)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that the 
\family typewriter
order
\family default
 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
order
\end_layout

\end_inset

parameter is set to zero to indicate that no derivatives are involved.
 Then we assemble the normal equations matrix and right-hand side for the
 least squares problem:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
[Ab,bb,bvlist] = assembly2dbdry(pde2,lin2d,p,t,bedges,t_index,fht,@int1d_gauss5)
;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Now we solve the linear system to obtain values of the boundary variables.
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
g1 = Ab(bvlist,bvlist) 
\backslash
 bb(bvlist);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Now we can solve the remainder of the system for the non-boundary variables.
 First, find the non-boundary variables (
\family typewriter
cbvlist
\family default
 means 
\begin_inset Quotes eld
\end_inset

complement of 
\family typewriter
bvlist
\family default

\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
% find non-boundary variables (cbvlist) 
\end_layout

\begin_layout Scrap
v_array = ones(nv,1); v_array(bvlist) = 0; 
\end_layout

\begin_layout Scrap
cbvlist = find(v_array ~= 0);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Now we solve the linear system for the non-boundary variables and insert
 the results into the vector 
\begin_inset Formula $\mathbf{u}$
\end_inset

; the boundary variables in 
\begin_inset Formula $\mathbf{u}$
\end_inset

 are in 
\family typewriter
g1
\family default
.
 
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
u_int = A(cbvlist,cbvlist) 
\backslash
 (b(cbvlist) - A(cbvlist,bvlist)*g1);
\end_layout

\begin_layout Scrap
u = zeros(nv,1); 
\end_layout

\begin_layout Scrap
u(cbvlist) = u_int; 
\end_layout

\begin_layout Scrap
u( bvlist) = g1; 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
We can plot the values of our numerical solution 
\begin_inset Formula $u(\mathbf{x})$
\end_inset

 at the vertices of the triangulation by means of 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
trimesh()
\end_layout

\end_inset

trimesh()
\family default
 and a helper routine 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
pvlist()
\end_layout

\end_inset

pvlist()
\family default
 that returns the variable indexes for the vertices of the triangulation.
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
pvlist = get_pvlist(fht,np); 
\end_layout

\begin_layout Scrap
figure(2)
\end_layout

\begin_layout Scrap
trimesh(t,p(:,1),p(:,2),u(pvlist))
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The result is illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Computed-solution1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename usage-soln1.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Computed-solution1"

\end_inset

Computed solution to PDE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To repeat the calculation using piecewise quadratic elements, we must first
 create the associated element type structure, and create the feature hash
 table for that element type.
\begin_inset Index idx
status open

\begin_layout Plain Layout
element!piecewise quadratic
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
quad2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
% Now using piecewise quadratic elements
\end_layout

\begin_layout Scrap
quad2d = quad2d_elt()
\end_layout

\begin_layout Scrap
fht2 = create_fht(p,t,quad2d)
\end_layout

\begin_layout Scrap
nv2 = fht_num_vars(fht2)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Then we need to assemble the matrix and right-hand side:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
assembly2d()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
% Initialize A2 and b2 
\end_layout

\begin_layout Scrap
A2 = sparse(nv2,nv2); 
\end_layout

\begin_layout Scrap
b2 = zeros(nv2,1); 
\end_layout

\begin_layout Scrap
% Assemble matrix and vector  
\end_layout

\begin_layout Scrap
[A2,b2] = assembly2d(A2,b2,pde,quad2d,p,t,fht2,@int2d_radon7); 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that the 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
pde
\end_layout

\end_inset

pde
\family default
 structure remains unchanged, as does the triangulation.
 While the boundary nodes remain unchanged, the boundary 
\emph on
variables
\emph default
 do not.
 We also use the least-squares approach to the Dirichlet boundary values,
 which works just as well for the case of piecewise quadratic elements as
 for piecewise linear elements.
 So we use the following code:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
[Ab2,bb2,bvlist2] = ...
\end_layout

\begin_layout Scrap
    assembly2dbdry(pde2,quad2d,p,t,bedges,t_index,fht2,@int1d_gauss5);
\end_layout

\begin_layout Scrap
% find non-boundary variables (cbvlist2) 
\end_layout

\begin_layout Scrap
v_array = ones(nv2,1); v_array(bvlist2) = 0; 
\end_layout

\begin_layout Scrap
cbvlist2 = find(v_array ~= 0);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
g2 = Ab2(bvlist2,bvlist2) 
\backslash
 bb2(bvlist2);
\end_layout

\begin_layout Scrap
u_int = A2(cbvlist2,cbvlist2) 
\backslash
 (b2(cbvlist2) - A2(cbvlist2,bvlist2)*g2);
\end_layout

\begin_layout Scrap
u2 = zeros(nv2,1); 
\end_layout

\begin_layout Scrap
u2(cbvlist2) = u_int; 
\end_layout

\begin_layout Scrap
u2( bvlist2) = g2; 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
To properly display the results, which are more accurate than the results
 of piecewise linear elements, we should use sub-meshes.
 First we create the sub-mesh for the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference element
\end_layout

\end_inset

reference element (which is the triangle with vertices 
\begin_inset Formula $(0,0)$
\end_inset

, 
\begin_inset Formula $(1,0)$
\end_inset

, and 
\begin_inset Formula $(0,1)$
\end_inset

):
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
[pr,tr] = ref_triangle_submesh(4);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The returned triangulation of the reference element has the edges of 4 small
 triangles on each coordinate axis.
 Then we can generate the values on a sub-mesh of the original triangulation,
 and plot the results.
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
[pv,tv,vals] = get_submesh_vals(p,t,fht2,quad2d,u2,pr,tr,0);
\end_layout

\begin_layout Scrap
figure(3)
\end_layout

\begin_layout Scrap
trimesh(tv,pv(:,1),pv(:,2),vals)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The last input to 
\family typewriter
get_submesh_vals()
\family default
 is the maximum order of the derivatives values generated.
 Since we just want to plot the values of the solution, this is set to zero.
 The result is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Results-quadratic-elt"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename usage-soln2.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Results-quadratic-elt"

\end_inset

Results of using quadratic elements (plotted using a sub-mesh)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Usage: a convection diffusion problem
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
convection--diffusion problem
\end_layout

\end_inset

This equation is more complex than the previous example, but on the same
 region:
\begin_inset Formula 
\begin{eqnarray*}
-\nabla\cdot\left[\alpha(\mathbf{x})\nabla u\right]+\mathbf{w}(\mathbf{x})\cdot\nabla u & = & f(\mathbf{x})\qquad\mbox{in }\Omega,\\
u(\mathbf{x}) & = & g(\mathbf{x})\qquad\mbox{on }\Gamma_{1},\\
\beta(\mathbf{x})u(\mathbf{x})+\alpha(\mathbf{x})\frac{\partial u}{\partial n}(\mathbf{x}) & = & h(\mathbf{x})\qquad\mbox{on }\Gamma_{2},
\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 is the outer boundary, and 
\begin_inset Formula $\Gamma_{2}$
\end_inset

 is the inner (circular) boundary.
 The boundary conditions over 
\begin_inset Formula $\Gamma_{2}$
\end_inset

 are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Robin boundary conditions
\end_layout

\end_inset

Robin boundary conditions.
 In the case where 
\begin_inset Formula $\beta(\mathbf{x})\equiv0$
\end_inset

, they are called 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Neumann boundary conditions
\end_layout

\end_inset

Neumann boundary conditions, or 
\begin_inset Index idx
status open

\begin_layout Plain Layout
natural boundary conditions
\end_layout

\end_inset

natural boundary conditions.
 To obtain the weak form, multiply by a function 
\begin_inset Formula $v(\mathbf{x})$
\end_inset

 with 
\begin_inset Formula $v=0$
\end_inset

 on 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 and integrate over 
\begin_inset Formula $\Omega$
\end_inset

:
\begin_inset Formula 
\[
\int_{\Omega}v\left(-\nabla\cdot\left[\alpha(\mathbf{x})\nabla u\right]+\mathbf{w}(\mathbf{x})\cdot\nabla u\right)d\mathbf{x}=\int_{\Omega}v\, f\, d\mathbf{x}.
\]

\end_inset

The left-hand side can be re-arranged using
\begin_inset Formula 
\begin{eqnarray*}
\int_{\Omega}v\nabla\cdot\left[\alpha\nabla u\right]\, d\mathbf{x} & = & \int_{\Omega}\left\{ \nabla\cdot\left(v\alpha\nabla u\right)-\alpha\nabla v\cdot\nabla u\right\} \, d\mathbf{x}\\
 & = & \int_{\partial\Omega}v\alpha\frac{\partial u}{\partial n}\, dS-\int_{\Omega}\alpha\nabla v\cdot\nabla u\, d\mathbf{x}\\
 & = & \int_{\Gamma_{2}}v\alpha\frac{\partial u}{\partial n}\, dS-\int_{\Omega}\alpha\nabla v\cdot\nabla u\, d\mathbf{x}
\end{eqnarray*}

\end_inset

since 
\begin_inset Formula $v=0$
\end_inset

 on 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 , 
\begin_inset Formula $\overline{\Gamma_{1}}\cup\overline{\Gamma_{2}}=\partial\Omega$
\end_inset

, and 
\begin_inset Formula $\Gamma_{1}\cap\Gamma_{2}=\emptyset$
\end_inset

.
 Now we can use the boundary conditions on 
\begin_inset Formula $\Gamma_{2}$
\end_inset

:
\begin_inset Formula 
\begin{eqnarray*}
\int_{\Gamma_{2}}v\alpha\frac{\partial u}{\partial n}\, dS & = & \int_{\Gamma_{2}}v\left[h-\beta u\right]\, dS.
\end{eqnarray*}

\end_inset

Combining, this gives the weak form
\begin_inset Formula 
\[
\int_{\Omega}\left[\alpha\nabla v\cdot\nabla u+v\,\mathbf{w}\cdot\nabla u\right]d\mathbf{x}+\int_{\Gamma_{2}}\beta uv\, dS=\int_{\Omega}f\, v\, d\mathbf{x}+\int_{\Gamma_{2}}h\, v\, dS,
\]

\end_inset

for all 
\begin_inset Formula $v$
\end_inset

 with 
\begin_inset Formula $v=0$
\end_inset

 on 
\begin_inset Formula $\Gamma_{1}$
\end_inset

, and 
\begin_inset Formula $u=g$
\end_inset

 on 
\begin_inset Formula $\Gamma_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
We need to define the 
\family typewriter
pde
\family default
 structures for the region and boundary integrals.
 
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
f = @(x)10;
\end_layout

\begin_layout Scrap
%g = @(x)(0.5*cos(x(1)));
\end_layout

\begin_layout Scrap
g = @(x)0;
\end_layout

\begin_layout Scrap
h = @(x)exp(x(2));
\end_layout

\begin_layout Scrap
w = @(x)[1; -2];
\end_layout

\begin_layout Scrap
alpha = @(x)1;
\end_layout

\begin_layout Scrap
beta  = @(x)10;
\end_layout

\begin_layout Scrap
pde  = struct('coeffs',@(x)[0,w(x)'; [0;0],alpha(x)*eye(2)], ...
\end_layout

\begin_layout Scrap
         'rhs',@(x)[f(x);0;0], 'order',1)
\end_layout

\begin_layout Scrap
pdeb = struct('coeffs',beta, 'rhs',h, 'order',0)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $f(\mathbf{x})$
\end_inset

, 
\begin_inset Formula $\mathbf{w}(\mathbf{x})$
\end_inset

, and 
\begin_inset Formula $\alpha(\mathbf{x})$
\end_inset

 are only evaluated once for each value of 
\begin_inset Formula $\mathbf{x}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We also need to separate out the edges on 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 and 
\begin_inset Formula $\Gamma_{2}$
\end_inset

.
 A simple way to separate them is that points 
\begin_inset Formula $\mathbf{x}$
\end_inset

 on 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 have 
\begin_inset Formula $\left\Vert \mathbf{x}\right\Vert _{2}>3/4$
\end_inset

 while points 
\begin_inset Formula $\mathbf{x}$
\end_inset

 on 
\begin_inset Formula $\Gamma_{2}$
\end_inset

 have 
\begin_inset Formula $\left\Vert \mathbf{x}\right\Vert _{2}<3/4$
\end_inset

.
 Fortunately in this case, there are no edges that intersect both 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 and 
\begin_inset Formula $\Gamma_{2}$
\end_inset

, although this may occur with other problems.
 
\end_layout

\begin_layout Standard
This task can be carried by starting with 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
bnodes
\end_layout

\end_inset

bnodes
\family default
, which contains the list of boundary vertices as indexes into the 
\family typewriter
p
\family default
 array.
 
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
in_gamma1_bnodes = (sqrt(p(bnodes,1).^2+p(bnodes,2).^2) > 3/4);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that 
\family typewriter
in_gamma1_bnodes(i)
\family default
 is true (1) or false (0) depending on whether the point indexed by 
\family typewriter
bnodes(i)
\family default
 is in 
\begin_inset Formula $\Gamma_{1}$
\end_inset

.
 We create a boolean (that is, zero--one) vector indicating whether a given
 point of the triangulation is in 
\begin_inset Formula $\Gamma_{1}$
\end_inset

:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
in_gamma1 = zeros(size(p,1),1);
\end_layout

\begin_layout Scrap
in_gamma1(bnodes) = in_gamma1_bnodes;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Then we can check the boundary edges to see which boundary edges are in
 
\begin_inset Formula $\Gamma_{1}$
\end_inset

:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
in_gamma1_bedges = in_gamma1(bedges(:,1)) & in_gamma1(bedges(:,2));
\end_layout

\begin_layout Scrap
bedges1  = bedges (find( in_gamma1_bedges),:);
\end_layout

\begin_layout Scrap
t_index1 = t_index(find( in_gamma1_bedges));
\end_layout

\begin_layout Scrap
bedges2  = bedges (find(~in_gamma1_bedges),:);
\end_layout

\begin_layout Scrap
t_index2 = t_index(find(~in_gamma1_bedges));
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The boundaries can be shown by means of the 
\family typewriter
triplot()
\family default
 function:
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
figure(4)
\end_layout

\begin_layout Scrap
triplot(t,p(:,1),p(:,2),'k') % plot triangulation
\end_layout

\begin_layout Scrap
% plot 
\backslash
Gamma_1 in blue and 
\backslash
Gamma_2 in red
\end_layout

\begin_layout Scrap
triplot([bedges1(:,1),bedges1(:,2),bedges1(:,2)],p(:,1),p(:,2),'b')
\end_layout

\begin_layout Scrap
triplot([bedges2(:,1),bedges2(:,2),bedges2(:,2)],p(:,1),p(:,2),'r')
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The result is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:two-boundaries"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename two-boundaries.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:two-boundaries"

\end_inset

Boundaries 
\begin_inset Formula $\Gamma_{1}$
\end_inset

 and 
\begin_inset Formula $\Gamma_{2}$
\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then to create the linear system to solve, we need to find all the variables
 associated with the Dirichlet boundary conditions; that is, we need to
 find all variables associated with 
\begin_inset Formula $\Gamma_{1}$
\end_inset

.
 The main matrix and right-hand side can be assembled independently.
 
\end_layout

\begin_layout Scrap
<<usage.m>>=
\end_layout

\begin_layout Scrap
intmethod = @int2d_radon7;
\end_layout

\begin_layout Scrap
[A,b,bvlist2] = assembly2dbdry(pdeb,lin2d,p,t, ...
\end_layout

\begin_layout Scrap
      bedges2,t_index2,fht,@int1d_gauss5);
\end_layout

\begin_layout Scrap
[A,b] = assembly2d(A,b,pde,lin2d,p,t,fht,intmethod);
\end_layout

\begin_layout Scrap
dir_bc_pde = struct('coeffs',@(x)[1],'rhs',@(x)g(x),'order',0)
\end_layout

\begin_layout Scrap
Ab = sparse(nv,nv);
\end_layout

\begin_layout Scrap
bb =  zeros(nv,1);
\end_layout

\begin_layout Scrap
[Ab,bb,dir_bc_vlist] = ...
 
\end_layout

\begin_layout Scrap
      assembly2dbdry(dir_bc_pde,lin2d,p,t, ...
\end_layout

\begin_layout Scrap
      bedges1,t_index1,fht,@int1d_gauss5);
\end_layout

\begin_layout Scrap
u1 = Ab(dir_bc_vlist,dir_bc_vlist) 
\backslash
 bb(dir_bc_vlist);
\end_layout

\begin_layout Scrap
% Get complement to dir_bc_vlist
\end_layout

\begin_layout Scrap
varray = zeros(nv,1);
\end_layout

\begin_layout Scrap
varray(dir_bc_vlist) = 1;
\end_layout

\begin_layout Scrap
cvlist = find(varray == 0);
\end_layout

\begin_layout Scrap
% Now solve linear system
\end_layout

\begin_layout Scrap
u2 = A(cvlist,cvlist) 
\backslash
 (b(cvlist) - A(cvlist,dir_bc_vlist)*u1);
\end_layout

\begin_layout Scrap
u = zeros(nv,1);
\end_layout

\begin_layout Scrap
u(dir_bc_vlist) = u1;
\end_layout

\begin_layout Scrap
u(cvlist)       = u2;
\end_layout

\begin_layout Scrap
figure(5)
\end_layout

\begin_layout Scrap
trimesh(t,p(:,1),p(:,2),u(pvlist))
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The result is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:convection-diffusion-robin-bc"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename conv-diff-eg.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:convection-diffusion-robin-bc"

\end_inset

Result for convection--diffusion problem with Robin boundary conditions
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Basic-assumptions"

\end_inset

Basic assumptions
\end_layout

\begin_layout Standard
There are a number of assumptions about the triangulation and the element
 types (which includes their basis functions) that are necessary for this
 code to work.
 It is important to be aware of these issues when, for example, creating
 new element types, or using different mesh generators.
\end_layout

\begin_layout Standard
The triangulation is represented by the pair of arrays (
\family typewriter
p
\family default
,
\family typewriter
t
\family default
) where rows of 
\family typewriter
p
\family default
 are the 
\begin_inset Formula $(x,y)$
\end_inset

 co-ordinates of the vertices (points) of the triangulation, and each row
 of 
\family typewriter
t
\family default
 contains the row indexes into 
\family typewriter
p
\family default
 for the vertices of that triangle.
 Thus 
\family typewriter
p
\family default
 is a floating point array with two columns and 
\family typewriter
t
\family default
 is an integer array with three columns.
 For three-dimensions, 
\family typewriter
p
\family default
 is a floating point array with three columns (for 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 coordinates) and 
\family typewriter
t
\family default
 is an integer array with four columns representing the vertices of tetrahedra.
\end_layout

\begin_layout Standard
The triangulation is assumed to be 
\emph on
conforming
\emph default
.
 That is, for any two triangles 
\begin_inset Formula $K_{1}$
\end_inset

 and 
\begin_inset Formula $K_{2}$
\end_inset

 in the triangulation, 
\begin_inset Formula $K_{1}\cap K_{2}$
\end_inset

 is either empty, or a common 
\emph on
geometric feature
\emph default
 (vertex, edge, or triangle).
 Vertices are represented by a single row index into 
\family typewriter
p
\family default
, edges by a pair of row indexes into 
\family typewriter
p
\family default
, and triangles by three row indexes into 
\family typewriter
p
\family default
.
\end_layout

\begin_layout Standard
Each triangle 
\begin_inset Formula $K$
\end_inset

 in the triangulation has a number of associated basis functions 
\begin_inset Formula $\phi_{i}(\mathbf{x})$
\end_inset

.
 These are basis functions are related to basis functions on the 
\emph on
reference element
\emph default
 
\begin_inset Formula $\widehat{K}$
\end_inset

.
 For this code, the reference element is the triangle with vertices 
\begin_inset Formula $(0,0)$
\end_inset

, 
\begin_inset Formula $(1,0)$
\end_inset

, and 
\begin_inset Formula $(0,1)$
\end_inset

.
 The basis functions on the reference element are fixed functions 
\begin_inset Formula $\widehat{\phi}_{j}(\widehat{\mathbf{x}})$
\end_inset

 for 
\begin_inset Formula $\widehat{\mathbf{x}}\in\widehat{K}$
\end_inset

.
 Each triangle 
\begin_inset Formula $K$
\end_inset

 in the triangulation is the image of the reference element under an affine
 transformation 
\begin_inset Formula $\widehat{K}\to K$
\end_inset

 given by 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

.
 Then each basis function 
\begin_inset Formula $\phi_{i}$
\end_inset

 that is non-zero on 
\begin_inset Formula $K$
\end_inset

 is related to some basis function 
\begin_inset Formula $\widehat{\phi}_{j}$
\end_inset

 on 
\begin_inset Formula $\widehat{K}$
\end_inset

 through 
\begin_inset Formula $\phi_{i}(\mathbf{x})=\widehat{\phi}_{j}(\widehat{\mathbf{x}})$
\end_inset

 where 
\begin_inset Formula $\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

.
 (This requirement is actually relaxed for some element types to requiring
 that 
\begin_inset Formula $\phi_{i}(\mathbf{x})=\sum_{j}c_{ij}\,\widehat{\phi}_{j}(\widehat{\mathbf{x}})$
\end_inset

 for some linear combination of basis functions on the reference element.)
\end_layout

\begin_layout Standard
Every basis function (or variable) on the reference element is associated
 with a unique geometric feature of the reference element.
 If 
\begin_inset Formula $\widehat{\mathbf{x}}$
\end_inset

 belongs to a geometric feature and 
\begin_inset Formula $\widehat{\phi}_{j}$
\end_inset

 is 
\emph on
not
\emph default
 associated with that geometric feature or any of its subfeatures, then
 
\begin_inset Formula $\widehat{\phi}_{j}(\widehat{\mathbf{x}})=0$
\end_inset

 if the basis functions are continuous across element boundaries.
 Piecewise constant elements are not continuous across element boundaries,
 and so do not have to satisfy this requirement.
\end_layout

\begin_layout Standard
Any permutation of the vertices of the reference triangle 
\begin_inset Formula $\widehat{K}$
\end_inset

 induces an affine transformation 
\begin_inset Formula $\widehat{K}\to\widehat{K}$
\end_inset

 given by 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\widehat{T}\widehat{\mathbf{x}}+\widehat{\mathbf{b}}$
\end_inset

.
 For each basis function 
\begin_inset Formula $\widehat{\phi}_{j}$
\end_inset

 and permutation of the vertices of 
\begin_inset Formula $\widehat{K}$
\end_inset

, 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\widehat{\phi}_{j}(\widehat{T}\widehat{\mathbf{x}}+\widehat{\mathbf{b}})$
\end_inset

 is a 
\begin_inset Formula $\widehat{\phi}_{k}$
\end_inset

 basis functions.
 That is, for some coefficients 
\begin_inset Formula $c_{k}$
\end_inset

,
\begin_inset Formula 
\[
\widehat{\phi}_{j}(\widehat{T}\widehat{\mathbf{x}}+\widehat{\mathbf{b}})=\sum_{k}c_{k}\,\widehat{\phi}_{k}(\widehat{\mathbf{x}})\qquad\mbox{for all }\widehat{\mathbf{x}}\in\widehat{K}.
\]

\end_inset


\end_layout

\begin_layout Standard
Very often we can write 
\begin_inset Formula $\widehat{\phi}_{j}(\widehat{T}\widehat{\mathbf{x}}+\widehat{\mathbf{b}})=\widehat{\phi}_{k}(\widehat{\mathbf{x}})$
\end_inset

 for all 
\begin_inset Formula $\widehat{\mathbf{x}}\in\widehat{K}$
\end_inset

 for some 
\begin_inset Formula $k$
\end_inset

.
 For example, consider the piecewise linear, quadratic and cubic Lagrange
 elements: using a nodal basis with nodes that are symmetrically placed
 with respect to permutations of the vertices means that 
\begin_inset Formula $\widehat{\phi}_{j}(\widehat{T}\widehat{\mathbf{x}}+\widehat{\mathbf{b}})=\widehat{\phi}_{k}(\widehat{\mathbf{x}})$
\end_inset

 for some 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Matrix-assembly-code"

\end_inset

Matrix assembly code
\end_layout

\begin_layout Standard
The main matrix assembly code 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
assembly2d()
\end_layout

\end_inset

assembly2d()
\family default
 is given below.
 The function adds values in the matrix 
\begin_inset Formula $A$
\end_inset

 and the vector 
\begin_inset Formula $\mathbf{b}$
\end_inset

.
 In this way, the full assembly process can be accomplished 
\begin_inset Quotes eld
\end_inset

in pieces
\begin_inset Quotes erd
\end_inset

, if needed.
 So, for stand-alone use, 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\mathbf{b}$
\end_inset

 must be initialized to zero.
 Note that 
\begin_inset Formula $A$
\end_inset

 can (and should) be a sparse matrix.
\end_layout

\begin_layout Standard
The PDE is represented by two functions which are in the 
\family typewriter
pde
\family default
 structure (see Subsection
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:PDE-representation"

\end_inset

).
\end_layout

\begin_layout Standard
The element type is defined by the 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
elt
\end_layout

\end_inset

elt
\family default
 structure (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Element-types"

\end_inset

).
\end_layout

\begin_layout Standard
The triangulation is given by the pair (
\family typewriter
p
\family default
,
\family typewriter
t
\family default
) as described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Overview"

\end_inset

.
 
\end_layout

\begin_layout Standard
The hash table for the map from geometric features (triangles, edges, and
 vertices) to variables is 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
fht
\end_layout

\end_inset

fht
\family default
 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Handling-geometric-features"

\end_inset

).
\end_layout

\begin_layout Standard
The points and weights for the integration method on the reference element
 are returned by the function 
\family typewriter
intmethod()
\family default
 (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Numerical-integration"

\end_inset

).
 These points and weights are computed in 
\emph on
assembly2d-init
\emph default
.
\end_layout

\begin_layout Standard
The line
\end_layout

\begin_layout LyX-Code
[vlist,slist] = get_var_triangle(t(i,:),fht,elt,np);
\end_layout

\begin_layout Standard
gets the list of (global) variables indexes (
\family typewriter
vlist
\family default
) associated with triangle 
\begin_inset Formula $i$
\end_inset

, along with the list of sign changes needed (
\family typewriter
slist
\family default
).
 
\end_layout

\begin_layout Subsection
Main two-dimensional assembly function
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
assembly2d.m 
\backslash

\end_layout

\begin_layout Scrap
<<assembly2d.m>>=
\end_layout

\begin_layout Scrap
function [A,b] = assembly2d(A,b,pde,elt,p,t,fht,intmethod)
\end_layout

\begin_layout Scrap
% function [A,b] = assembly2d(A,b,pde,elt,p,t,fht,intmethod)
\end_layout

\begin_layout Scrap
% Adds the assembled matrix and vector representing the
\end_layout

\begin_layout Scrap
% given PDE (pde) to the A matrix & b vector.
\end_layout

\begin_layout Scrap
% This uses a given element (elt) with the triangulation given by (p,t).
\end_layout

\begin_layout Scrap
% The feature hash table (fht) is used to obtain variable indexes
\end_layout

\begin_layout Scrap
% for given features.
 This is obtained by create_fht().
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% A must be nv x nv and b must be nv x 1 where nv is the total
\end_layout

\begin_layout Scrap
% number of variables (as returned by fht_num_vars()).
\end_layout

\begin_layout Scrap
% Reference triangle has vertices (0,0), (1,0), (0,1).
\end_layout

\begin_layout Scrap
<<assembly2d-init>>
\end_layout

\begin_layout Scrap
<<assembly2d-precompute-Aphihat>>
\end_layout

\begin_layout Scrap
for i = 1:size(t,1) % for all triangles ...
\end_layout

\begin_layout Scrap
    % obtain variable list and signs for this triangle
\end_layout

\begin_layout Scrap
    [vlist,slist] = get_var_triangle(t(i,:),fht,elt,np);
\end_layout

\begin_layout Scrap
    % set up affine transformation xhat :-> x = T.xhat + b0
\end_layout

\begin_layout Scrap
    i1 = t(i,1);  i2 = t(i,2);  i3 = t(i,3);
\end_layout

\begin_layout Scrap
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];
\end_layout

\begin_layout Scrap
    b0 = p(i1,:)';
\end_layout

\begin_layout Scrap
    % form weighted sum of integrand at integration points
\end_layout

\begin_layout Scrap
    intval1 = 0;
\end_layout

\begin_layout Scrap
    intval2 = 0;
\end_layout

\begin_layout Scrap
    for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
        Aphival = elt.trans_Aphihat(T,Aphihatvals{k},order);
\end_layout

\begin_layout Scrap
        Dmat    = pde.coeffs(T*p_int(k,:)'+b0);
\end_layout

\begin_layout Scrap
        rhsvec  = pde.rhs(T*p_int(k,:)'+b0);
\end_layout

\begin_layout Scrap
        integrand_val1 = Aphival*Dmat*Aphival';
\end_layout

\begin_layout Scrap
        integrand_val2 = Aphival*rhsvec;
\end_layout

\begin_layout Scrap
        intval1 = intval1 + w_int(k)*integrand_val1;
\end_layout

\begin_layout Scrap
        intval2 = intval2 + w_int(k)*integrand_val2;
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
    detT = abs(det(T));
\end_layout

\begin_layout Scrap
    intval1 = intval1*detT; % scale by Jacobian
\end_layout

\begin_layout Scrap
    intval2 = intval2*detT;
\end_layout

\begin_layout Scrap
    intval1 = diag(slist)*intval1*diag(slist); % change signs if needed
\end_layout

\begin_layout Scrap
    % intval2 = slist'.*intval2;
\end_layout

\begin_layout Scrap
    intval2 = bsxfun(@times,intval2,slist');
\end_layout

\begin_layout Scrap
    A(vlist,vlist) = A(vlist,vlist) + intval1; % add to matrix & vec
\end_layout

\begin_layout Scrap
    % b(vlist) = b(vlist) + intval2;
\end_layout

\begin_layout Scrap
    b(vlist,:) = b(vlist,:) + intval2;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Initialization for 
\emph on
assembly2d
\emph default
:
\end_layout

\begin_layout Scrap
<<assembly2d-init>>=
\end_layout

\begin_layout Scrap
[p_int,w_int] = intmethod(); % points and weights for reference triangle
\end_layout

\begin_layout Scrap
% np is the total number of points in the triangulation
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
% compute nv = total number of variables
\end_layout

\begin_layout Scrap
nv = fht_num_vars(fht);
\end_layout

\begin_layout Scrap
% nv_elt is the number of variables in one element
\end_layout

\begin_layout Scrap
nv_elt = sum(elt.nvars);
\end_layout

\begin_layout Scrap
% order is the order of derivatives used in the assembly;
\end_layout

\begin_layout Scrap
% we need 0 <= order <= 2
\end_layout

\begin_layout Scrap
order = pde.order;
\end_layout

\begin_layout Scrap
intval1 = zeros(nv_elt,nv_elt);
\end_layout

\begin_layout Scrap
% intval2 = zero(nv_elt,1);
\end_layout

\begin_layout Scrap
intval2 = zeros(nv_elt,size(b,2));
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
For efficiency, we precompute the values of 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}}_{j})$
\end_inset

 where 
\begin_inset Formula $\widehat{\mathbf{x}}_{j}$
\end_inset

 are the integration points on the reference triangle.
 These depend only on the element type and the reference element 
\begin_inset Formula $\widehat{K}$
\end_inset

.
 
\end_layout

\begin_layout Scrap
<<assembly2d-precompute-Aphihat>>=
\end_layout

\begin_layout Scrap
% Save Aphihat() values for all the integration points
\end_layout

\begin_layout Scrap
% on the reference element
\end_layout

\begin_layout Scrap
Aphihatvals = cell(length(w_int),1);
\end_layout

\begin_layout Scrap
for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
    Aphihatvals{k} = elt.Aphihat(p_int(k,:),order);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Petrov--Galerkin-method"

\end_inset

Petrov--Galerkin method
\end_layout

\begin_layout Standard
The Petrov--Galerkin method is supported through the 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
pgassembly2d()
\end_layout

\end_inset

pgassembly2d()
\family default
 function.
 Since there are potentially two different elements used (
\family typewriter
elt1
\family default
 and 
\family typewriter
elt2
\family default
), we need to pass two separate feature hash tables (
\family typewriter
fht1
\family default
 and 
\family typewriter
fht2
\family default
).
 Otherwise the inputs are identical to those for the standard Galerkin assembly
 function 
\family typewriter
assembly2d()
\family default
.
 Note that 
\family typewriter
assembly2d()
\family default
 is equivalent to 
\end_layout

\begin_layout LyX-Code
pgassembly2d(A,b,pde,p,t,elt,fht,elt,fht,intmethod)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{}
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
pgassembly2d.m 
\backslash

\end_layout

\begin_layout Scrap
<<pgassembly2d.m>>=
\end_layout

\begin_layout Scrap
function [A,b] = pgassembly2d(A,b,pde,p,t,elt1,fht1,elt2,fht2,intmethod)
\end_layout

\begin_layout Scrap
% function [A,b] = pgassembly2d(A,b,pde,p,t,elt1,fht1,elt2,fht2,intmethod)
\end_layout

\begin_layout Scrap
% 
\end_layout

\begin_layout Scrap
% Petrov-Galerkin matrix assembly.
\end_layout

\begin_layout Scrap
% Adds the assembled matrix and vector representing the
\end_layout

\begin_layout Scrap
% given PDE (pde) to the A matrix & b vector.
\end_layout

\begin_layout Scrap
% This uses a given elements (elt1, elt2) with the triangulation given by
 (p,t).
\end_layout

\begin_layout Scrap
% The feature hash tables (fht1 for elt1, fht2 for elt2) are used to obtain
 
\end_layout

\begin_layout Scrap
% variable indexes for given features.
 These are obtained by create_fht().
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% elt1 represents the test functions, while elt2 represents the basis
\end_layout

\begin_layout Scrap
% functions.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% The two elements can be quite independent, but the triangulation must
 be
\end_layout

\begin_layout Scrap
% the same for the two sets of variables.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% A must be nv1 x nv2 and b must be nv1 x 1 where nv1 is the total
\end_layout

\begin_layout Scrap
% number of variables for elt1 and nv2 is the total number of variables
\end_layout

\begin_layout Scrap
% for elt2 (as returned by fht_num_vars()).
\end_layout

\begin_layout Scrap
% Reference triangle has vertices (0,0), (1,0), (0,1).
\end_layout

\begin_layout Scrap
<<pgassembly2d-init>>
\end_layout

\begin_layout Scrap
<<pgassembly2d-precompute-Aphilist>>
\end_layout

\begin_layout Scrap
for i = 1:size(t,1) % for all triangles ...
\end_layout

\begin_layout Scrap
    % obtain variable list and signs for this triangle
\end_layout

\begin_layout Scrap
    [vlist1,slist1] = get_var_triangle(t(i,:),fht1,elt1,np);
\end_layout

\begin_layout Scrap
    [vlist2,slist2] = get_var_triangle(t(i,:),fht2,elt2,np);
\end_layout

\begin_layout Scrap
    % set up affine transformation xhat :-> x = T.xhat + b
\end_layout

\begin_layout Scrap
    i1 = t(i,1); i2 = t(i,2); i3 = t(i,3);
\end_layout

\begin_layout Scrap
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];
\end_layout

\begin_layout Scrap
    b0 = p(i1,:)';
\end_layout

\begin_layout Scrap
    % form weighted sum of integrand at integration points
\end_layout

\begin_layout Scrap
    intval1 = 0;
\end_layout

\begin_layout Scrap
    intval2 = 0;
\end_layout

\begin_layout Scrap
    for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
        Aphival1 = elt1.trans_Aphihat(T,Aphihatvals1{k},order);
\end_layout

\begin_layout Scrap
        Aphival2 = elt2.trans_Aphihat(T,Aphihatvals2{k},order);
\end_layout

\begin_layout Scrap
        Dmat   = pde.coeffs(T*p_int(k,:)'+b0);
\end_layout

\begin_layout Scrap
        rhsvec = pde.rhs(   T*p_int(k,:)'+b0);
\end_layout

\begin_layout Scrap
        integrand_val1 = Aphival1*Dmat*Aphival2';
\end_layout

\begin_layout Scrap
        integrand_val2 = Aphival1*rhsvec;
\end_layout

\begin_layout Scrap
        intval1 = intval1 + w_int(k)*integrand_val1;
\end_layout

\begin_layout Scrap
        intval2 = intval2 + w_int(k)*integrand_val2;
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
    detT = abs(det(T));
\end_layout

\begin_layout Scrap
    intval1 = intval1*detT; % scale by Jacobian
\end_layout

\begin_layout Scrap
    intval2 = intval2*detT;
\end_layout

\begin_layout Scrap
    intval1 = diag(slist1)*intval1*diag(slist2); % change signs if needed
\end_layout

\begin_layout Scrap
    intval2 = slist1'.*intval2;
\end_layout

\begin_layout Scrap
    A(vlist1,vlist2) = A(vlist1,vlist2) + intval1; % add to matrix & vec
\end_layout

\begin_layout Scrap
    b(vlist1)        = b(vlist1)        + intval2;
\end_layout

\begin_layout Scrap
end % for i
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The initialization code follows:
\end_layout

\begin_layout Scrap
<<pgassembly2d-init>>=
\end_layout

\begin_layout Scrap
[p_int,w_int] = intmethod(); % points and weights for reference triangle
\end_layout

\begin_layout Scrap
% np is the total number of points in the triangulation
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
% compute total numbers of variables
\end_layout

\begin_layout Scrap
nv1 = fht_num_vars(fht1);
\end_layout

\begin_layout Scrap
nv2 = fht_num_vars(fht2);
\end_layout

\begin_layout Scrap
% nv_elt is the number of variables in one element
\end_layout

\begin_layout Scrap
nv_elt1 = sum(elt1.nvars);
\end_layout

\begin_layout Scrap
nv_elt2 = sum(elt2.nvars);
\end_layout

\begin_layout Scrap
% order is the order of derivatives used in the assembly;
\end_layout

\begin_layout Scrap
% we need 0 <= order <= 2
\end_layout

\begin_layout Scrap
order = pde.order;
\end_layout

\begin_layout Scrap
intval1 = zeros(nv_elt1,nv_elt2);
\end_layout

\begin_layout Scrap
intval2 = zeros(nv_elt1,1);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
For efficiency we pre-compute the 
\family typewriter
Aphihat
\family default
 values at the integration points on the reference element.
\end_layout

\begin_layout Scrap
<<pgassembly2d-precompute-Aphilist>>=
\end_layout

\begin_layout Scrap
% Save Aphihat() values for all the integration points
\end_layout

\begin_layout Scrap
% on the reference element
\end_layout

\begin_layout Scrap
Aphihatvals1 = cell(length(w_int),1);
\end_layout

\begin_layout Scrap
Aphihatvals2 = cell(length(w_int),1);
\end_layout

\begin_layout Scrap
for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
    Aphihatvals1{k} = elt1.Aphihat(p_int(k,:),order);
\end_layout

\begin_layout Scrap
    Aphihatvals2{k} = elt2.Aphihat(p_int(k,:),order);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Re-factored two-dimensional assembly function
\end_layout

\begin_layout Standard
This is an attempt to re-factor and distill the essence of 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
assembly2d()
\end_layout

\end_inset

assembly2d()
\family default
, so that it can be easily extended.
 The interface differs from 
\family typewriter
assembly2d()
\family default
 in that the element type (
\family typewriter
elt
\family default
) is now together with the feature hash table (
\family typewriter
fht1
\family default
) in the argument list.
 These items really go together.
 
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
assembly2d-rf.m 
\backslash

\end_layout

\begin_layout Scrap
<<assembly2d-rf.m>>=
\end_layout

\begin_layout Scrap
function [A,b] = assembly2d_rf(A,b,pde,p,t,elt1,fht1,intmethod)
\end_layout

\begin_layout Scrap
% function [A,b] = assembly2d_rf(A,b,pde,p,t,elt1,fht1,intmethod)
\end_layout

\begin_layout Scrap
% Adds the assembled matrix and vector representing the
\end_layout

\begin_layout Scrap
% given PDE (pde) to the A matrix & b vector.
\end_layout

\begin_layout Scrap
% This uses a given element (elt1) with the triangulation given by (p,t).
\end_layout

\begin_layout Scrap
% The feature hash table (fht1) is used to obtain variable indexes
\end_layout

\begin_layout Scrap
% for given features.
 This is obtained by create_fht().
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% A must be nv1 x nv1 and b must be nv1 x 1 where nv1 is the total
\end_layout

\begin_layout Scrap
% number of variables (as returned by fht_num_vars(fht1)).
\end_layout

\begin_layout Scrap
% Reference triangle has vertices (0,0), (1,0), (0,1).
\end_layout

\begin_layout Scrap
<<assembly2d-rf-init>>
\end_layout

\begin_layout Scrap
<<assembly2d-rf-init-update>>
\end_layout

\begin_layout Scrap
<<precompute-rf-Aphihat>>
\end_layout

\begin_layout Scrap
for i = 1:size(t,1) % for all triangles ...
\end_layout

\begin_layout Scrap
    <<assembly-get-variable-list>>
\end_layout

\begin_layout Scrap
    <<assembly-set-affine-transformation>>
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
    % form weighted sum of integrand at integration points
\end_layout

\begin_layout Scrap
    update_mat = 0;
\end_layout

\begin_layout Scrap
    update_vec = 0;
\end_layout

\begin_layout Scrap
    for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
        <<assembly-transform-Aphihat>>
\end_layout

\begin_layout Scrap
        <<assembly-add-to-update-matrix>>
\end_layout

\begin_layout Scrap
        <<assembly-add-to-update-vector>>
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
    detT = abs(det(T));
\end_layout

\begin_layout Scrap
    <<assembly-scale-and-update-matrix>>
\end_layout

\begin_layout Scrap
    <<assembly-scale-and-update-vector>>
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
This initialization segment simply sets the integration points and weights,
 the variables 
\family typewriter
np
\family default
 (number of points), 
\family typewriter
nv1
\family default
 (total number of variables), 
\family typewriter
nv_elt1
\family default
 (number of variables in an element), and the creates space for the small
 update matrices and vectors (
\family typewriter
update_mat
\family default
 and 
\family typewriter
update_vec
\family default
 respectively).
\end_layout

\begin_layout Scrap
<<assembly2d-rf-init>>=
\end_layout

\begin_layout Scrap
[p_int,w_int] = intmethod(); % points and weights for reference triangle
\end_layout

\begin_layout Scrap
% np is the total number of points in the triangulation
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
% order is the order of derivatives used in the assembly;
\end_layout

\begin_layout Scrap
% we need 0 <= order <= 2
\end_layout

\begin_layout Scrap
order = pde.order;
\end_layout

\begin_layout Scrap
<<assembly2d-rf-init-update>>=
\end_layout

\begin_layout Scrap
% nv_elt1 is the number of variables in one element
\end_layout

\begin_layout Scrap
nv_elt1 = sum(elt1.nvars);
\end_layout

\begin_layout Scrap
update_mat = zeros(nv_elt1,nv_elt1);
\end_layout

\begin_layout Scrap
update_vec = zeros(nv_elt1,1);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Pre-computing the 
\begin_inset Formula $\mathcal{A}\widehat{\phi}(\widehat{\mathbf{x}})$
\end_inset

 values for the integration points in the reference element saves repeating
 this computation on each iteration through the loops over the elements
 and the integration points.
\end_layout

\begin_layout Scrap
<<precompute-rf-Aphihat>>=
\end_layout

\begin_layout Scrap
% Save Aphihat() values for all the integration points
\end_layout

\begin_layout Scrap
% on the reference element
\end_layout

\begin_layout Scrap
Aphihatvals = cell(length(w_int),1);
\end_layout

\begin_layout Scrap
for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
    Aphihatvals{k} = elt1.Aphihat(p_int(k,:),order);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
For each element we need to obtain the associated variable index list (
\family typewriter
vlist
\family default
) and sign list (
\family typewriter
slist
\family default
).
 The order of the indexes corresponds to the order of the basis functions
 as generated by 
\family typewriter
elt1.Aphihat()
\family default
.
 This must be done once for each element.
\end_layout

\begin_layout Scrap
<<assembly-get-variable-list>>=
\end_layout

\begin_layout Scrap
% obtain variable list and signs for this triangle
\end_layout

\begin_layout Scrap
[vlist,slist] = get_var_triangle(t(i,:),fht1,elt1,np);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
This is where the matrix 
\begin_inset Formula $T_{K}$
\end_inset

 and the vector 
\begin_inset Formula $\mathbf{b}_{K}$
\end_inset

 are set up for the triangle 
\begin_inset Formula $K$
\end_inset

 with vertices 
\family typewriter
p(i1,:)
\family default
, 
\family typewriter
p(i2,:)
\family default
, 
\family typewriter
p(i3,:)
\family default
.
 This must be done once for each triangle (= element).
\end_layout

\begin_layout Scrap
<<assembly-set-affine-transformation>>=
\end_layout

\begin_layout Scrap
% set up affine transformation xhat :-> x = T.xhat + b0
\end_layout

\begin_layout Scrap
i1 = t(i,1);  i2 = t(i,2);  i3 = t(i,3);
\end_layout

\begin_layout Scrap
T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];
\end_layout

\begin_layout Scrap
b0 = p(i1,:)';
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The following code segments are executed once for each combination of triangle
 and integration point.
 
\end_layout

\begin_layout Standard
We must transform the array of 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 values to obtain the 
\begin_inset Formula $\mathcal{A}\phi_{i}(\mathbf{x})$
\end_inset

 values, for 
\begin_inset Formula $\mathcal{A}$
\end_inset

 ranging over the operators as defined by the element and the order required.
\end_layout

\begin_layout Scrap
<<assembly-transform-Aphihat>>=
\end_layout

\begin_layout Scrap
Aphival = elt1.trans_Aphihat(T,Aphihatvals{k},order);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
We compute 
\begin_inset Formula 
\[
\sum_{\mathcal{A},\mathcal{B}}\int_{K}c_{\mathcal{A},\mathcal{B}}(\mathbf{x})\,\mathcal{A}\phi_{i}(\mathbf{x})\,\mathcal{B}\phi_{j}(\mathbf{x})\, d\mathbf{x}\approx\sum_{p}w_{p}\,\sum_{\mathcal{A},\mathcal{B}}c_{\mathcal{A},\mathcal{B}}(\widetilde{\mathbf{x}}_{p})\,\mathcal{A}\phi_{i}(\widetilde{\mathbf{x}}_{p})\,\mathcal{B}\phi_{j}(\widetilde{\mathbf{x}}_{p})\,\left|\det T_{K}\right|
\]

\end_inset

where 
\begin_inset Formula $\widetilde{\mathbf{x}}_{p}=T_{K}\widehat{\mathbf{x}}_{p}+\mathbf{b}_{K}$
\end_inset

 and 
\begin_inset Formula $\widehat{\mathbf{x}}_{p}$
\end_inset

 is the integration point in the reference element.
 The sum over the operators 
\begin_inset Formula $\mathcal{A}$
\end_inset

 and 
\begin_inset Formula $\mathcal{B}$
\end_inset

 is hidden in the matrix multiplications below.
 The multiplication by 
\begin_inset Formula $\left|\det T_{K}\right|$
\end_inset

 is performed after the loop over integration points.
 A similar operation is carried out for the right-hand side vector.
 So far, these operations are carried out on the small update matrices and
 vectors, which will then be added to main matrix and vector.
\end_layout

\begin_layout Scrap
<<assembly-add-to-update-matrix>>=
\end_layout

\begin_layout Scrap
Dmat    = pde.coeffs(T*p_int(k,:)'+b0);
\end_layout

\begin_layout Scrap
update_mat = update_mat + w_int(k)*(Aphival*Dmat*Aphival');
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<assembly-add-to-update-vector>>=
\end_layout

\begin_layout Scrap
rhsvec  = pde.rhs(T*p_int(k,:)'+b0);
\end_layout

\begin_layout Scrap
update_vec = update_vec + w_int(k)*(Aphival*rhsvec);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
After the loop over integration points, but before adding the update matrices
 and vectors to the main matrix and vector, we need to scale by 
\begin_inset Formula $\left|\det T_{K}\right|$
\end_inset

 and apply any sign changes required by the element type.
 We then use 
\family typewriter
vlist
\family default
 to determine the place in the main matrix and vector to update.
\end_layout

\begin_layout Scrap
<<assembly-scale-and-update-matrix>>=
\end_layout

\begin_layout Scrap
update_mat = update_mat*detT;                    % scale by Jacobian
\end_layout

\begin_layout Scrap
update_mat = diag(slist)*update_mat*diag(slist); % change signs if needed
\end_layout

\begin_layout Scrap
A(vlist,vlist) = A(vlist,vlist) + update_mat;    % add to matrix
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<assembly-scale-and-update-vector>>=
\end_layout

\begin_layout Scrap
update_vec = update_vec*detT;                    % scale by Jacobian
\end_layout

\begin_layout Scrap
update_vec = slist'.*update_vec;                 % change signs if needed
\end_layout

\begin_layout Scrap
b(vlist)   = b(vlist)           + update_vec;    % add to vector
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Mesh-based-functions"

\end_inset

Mesh-based functions and nonlinear problems
\end_layout

\begin_layout Standard
Mesh-based functions are needed for handling nonlinear PDEs.
 These functions have the form
\begin_inset Formula 
\[
g(\mathbf{x})=\sum_{i=1}^{N}g_{i}\,\phi_{i}(\mathbf{x});
\]

\end_inset


\begin_inset Formula $g$
\end_inset

 itself may be a solution of a PDE, or a function of one (or more) such
 solutions.
 The assembly routine still produces a matrix and right-hand side for a
 linear system, but the linear system itself depends on a mesh-based function.
 This makes it easy to implement (for example), Newton's method for nonlinear
 PDEs.
 As with the Petrov--Galerkin assembly routine, it is important that 
\begin_inset Formula $g$
\end_inset

 is defined using the same triangulation as we are going to use for the
 assembly of the linear system.
 However, the element type used does not need to be the same as for the
 remainder of the linear system.
 (This can also be used in a Petrov--Galerkin way, but this has not been
 implemented as yet.)
\end_layout

\begin_layout Standard
The differences in the code with 
\family typewriter
assembly2d()
\family default
 can be easily identified: the 
\family typewriter
pde.coeffs()
\family default
 and 
\family typewriter
pde.rhs()
\family default
 functions have an extra input for the 
\begin_inset Formula $\mathcal{A}g(\mathbf{x})$
\end_inset

 values (
\begin_inset Formula $\mathcal{A}$
\end_inset

 represents one of the operators 
\begin_inset Formula $I$
\end_inset

, 
\begin_inset Formula $\partial/\partial x_{1}$
\end_inset

, 
\begin_inset Formula $\partial/\partial x_{2}$
\end_inset

, etc.).
 Note that 
\begin_inset Formula $g(\mathbf{x})$
\end_inset

 can have vector values if desired.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
assembly2d_nl()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
assembly2d-nl.m 
\backslash

\end_layout

\begin_layout Scrap
<<assembly2d-nl.m>>=
\end_layout

\begin_layout Scrap
function [A,b] = assembly2d_nl(A,b,pde,elt,p,t,fht,intmethod,elt_nl,fht_nl,g_nl)
\end_layout

\begin_layout Scrap
% function [A,b] = assembly2d_nl(A,b,pde,elt,p,t,fht,intmethod,elt_nl,fht_nl,g_n
l)
\end_layout

\begin_layout Scrap
% Adds the assembled matrix and vector representing the
\end_layout

\begin_layout Scrap
% given PDE (pde) to the A matrix & b vector.
\end_layout

\begin_layout Scrap
% This uses a given element (elt) with the triangulation given by (p,t).
\end_layout

\begin_layout Scrap
% The feature hash table (fht) is used to obtain variable indexes
\end_layout

\begin_layout Scrap
% for given features.
 This is obtained by create_fht().
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% A must be nv x nv and b must be nv x 1 where nv is the total
\end_layout

\begin_layout Scrap
% number of variables (as returned by fht_num_vars()).
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% The last three inputs (elt_nl, fht_nl, g_nl) represent an additional
\end_layout

\begin_layout Scrap
% function defined over the triangulation (this will typically be a
\end_layout

\begin_layout Scrap
% solution of this or some other PDE over the same domain).
\end_layout

\begin_layout Scrap
% elt_nl is the element type for the additional function
\end_layout

\begin_layout Scrap
% fht_nl is the feature hashtable for elt_nl 
\end_layout

\begin_layout Scrap
% g_nl is the vector where variable index i for this element has value g_nl(i)
\end_layout

\begin_layout Scrap
% The pde.coeffs() & pde.rhs() functions will now have the interfaces
\end_layout

\begin_layout Scrap
% pde.coeffs(x,g_val)
\end_layout

\begin_layout Scrap
% pde.rhs(x,g_val)
\end_layout

\begin_layout Scrap
% where g_val is the (row) vector of A.g(x) values where A is one of the
 standard
\end_layout

\begin_layout Scrap
% sets of operators (see elt.Aphihat()).
\end_layout

\begin_layout Scrap
% Reference triangle has vertices (0,0), (1,0), (0,1).
\end_layout

\begin_layout Scrap
[p_int,w_int] = intmethod(); % points and weights for reference triangle
\end_layout

\begin_layout Scrap
% np is the total number of points in the triangulation
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
% compute nv = total number of variables
\end_layout

\begin_layout Scrap
nv = fht_num_vars(fht);
\end_layout

\begin_layout Scrap
nv_nl = fht_num_vars(fht_nl);
\end_layout

\begin_layout Scrap
% nv_elt is the number of variables in one element
\end_layout

\begin_layout Scrap
nv_elt = sum(elt.nvars);
\end_layout

\begin_layout Scrap
nv_nl_elt = sum(elt_nl.nvars);
\end_layout

\begin_layout Scrap
% order is the order of derivatives used in the assembly;
\end_layout

\begin_layout Scrap
% we need 0 <= order <= 2
\end_layout

\begin_layout Scrap
order = pde.order;
\end_layout

\begin_layout Scrap
intval1 = zeros(nv_elt,nv_elt);
\end_layout

\begin_layout Scrap
intval2 = zeros(nv_elt,1);
\end_layout

\begin_layout Scrap
% Save Aphihat() values for all the integration points
\end_layout

\begin_layout Scrap
% on the reference element
\end_layout

\begin_layout Scrap
Aphihatvals = cell(length(w_int),1);
\end_layout

\begin_layout Scrap
Aphihatvals_nl = cell(length(w_int),1);
\end_layout

\begin_layout Scrap
for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
    Aphihatvals{k}    = elt.Aphihat(p_int(k,:),order);
\end_layout

\begin_layout Scrap
    Aphihatvals_nl{k} = elt.Aphihat(p_int(k,:),order);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
for i = 1:size(t,1) % for all triangles ...
\end_layout

\begin_layout Scrap
    % obtain variable list and signs for this triangle
\end_layout

\begin_layout Scrap
    [vlist,   slist]    = get_var_triangle(t(i,:),fht,   elt,   np);
\end_layout

\begin_layout Scrap
    [vlist_nl,slist_nl] = get_var_triangle(t(i,:),fht_nl,elt_nl,np);
\end_layout

\begin_layout Scrap
    % set up affine transformation xhat :-> x = T.xhat + b0
\end_layout

\begin_layout Scrap
    i1 = t(i,1); i2 = t(i,2); i3 = t(i,3);
\end_layout

\begin_layout Scrap
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];
\end_layout

\begin_layout Scrap
    b0 = p(i1,:)';
\end_layout

\begin_layout Scrap
    % form weighted sum of integrand at integration points
\end_layout

\begin_layout Scrap
    intval1 = 0;
\end_layout

\begin_layout Scrap
    intval2 = 0;
\end_layout

\begin_layout Scrap
    % Compute element integral
\end_layout

\begin_layout Scrap
    for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
        Aphival    = elt.trans_Aphihat(T,Aphihatvals{k},   order);
\end_layout

\begin_layout Scrap
        Aphival_nl = elt.trans_Aphihat(T,Aphihatvals_nl{k},order);
\end_layout

\begin_layout Scrap
        Dmat = pde.coeffs(T*p_int(k,:)'+b0, ...
\end_layout

\begin_layout Scrap
            (g_nl(vlist_nl).*slist_nl')'*Aphival_nl);
\end_layout

\begin_layout Scrap
        rhsvec = pde.rhs(T*p_int(k,:)'+b0, ...
\end_layout

\begin_layout Scrap
            (g_nl(vlist_nl).*slist_nl')'*Aphival_nl);
\end_layout

\begin_layout Scrap
        integrand_val1 = Aphival*Dmat*Aphival';
\end_layout

\begin_layout Scrap
        integrand_val2 = Aphival*rhsvec;
\end_layout

\begin_layout Scrap
        intval1 = intval1 + w_int(k)*integrand_val1;
\end_layout

\begin_layout Scrap
        intval2 = intval2 + w_int(k)*integrand_val2;
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
    detT = abs(det(T));
\end_layout

\begin_layout Scrap
    intval1 = intval1*detT; % scale by Jacobian
\end_layout

\begin_layout Scrap
    intval2 = intval2*detT;
\end_layout

\begin_layout Scrap
    intval1 = diag(slist)*intval1*diag(slist); % change signs if needed
\end_layout

\begin_layout Scrap
    intval2 = slist'.*intval2;
\end_layout

\begin_layout Scrap
    A(vlist,vlist) = A(vlist,vlist) + intval1; % add to matrix & vec
\end_layout

\begin_layout Scrap
    b(vlist)       = b(vlist) + intval2;
\end_layout

\begin_layout Scrap
end % for
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Boundary-assembly"

\end_inset

Boundary assembly
\end_layout

\begin_layout Standard
Assembling a matrix and vector using integration over the boundary, or part
 of it, can be useful for dealing with boundary conditions.
 The main difference with the other assembly routines is that we need to
 input the relevant boundary edges as a list of pairs of indexes into 
\family typewriter
p
\family default
, and to use 
\family typewriter
get_edge_vars()
\family default
 to obtain the list of relevant variables.
 The integration routine 
\family typewriter
intmethod()
\family default
 used must also be a one-dimensional integration method such as 
\family typewriter
int1d_gauss5()
\family default
.
 At the end there is some extra code to 
\begin_inset Quotes eld
\end_inset

trim
\begin_inset Quotes erd
\end_inset

 the matrix and vector assembled to be zero for variables not associated
 with the boundary.
\end_layout

\begin_layout Standard
There is an implicit assumption in this code that values on the boundary
 are not affected by variables not associated with a geometric feature of
 the boundary.
 For example, with piecewise linear elements, we need the value on an edge
 not to be affected by the value at the opposite vertex.
 This holds, as it should.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
assembly2dbdry()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
assembly2dbdry.m 
\backslash

\end_layout

\begin_layout Scrap
<<assembly2dbdry.m>>=
\end_layout

\begin_layout Scrap
function [A,b,bvlist] = assembly2dbdry(pde,elt,p,t,bedges,tidx,fht,intmethod)
\end_layout

\begin_layout Scrap
% function [A,b,bvlist] = assembly2dbdry(pde,elt,p,t,bedges,tidx,fht,intmethod)
\end_layout

\begin_layout Scrap
% Adds the assembled matrix and vector representing the
\end_layout

\begin_layout Scrap
% given PDE (pde) to the A matrix & b vector.
\end_layout

\begin_layout Scrap
% This uses a given element (elt) with the triangulation given by (p,t,bedges,ti
dx)
\end_layout

\begin_layout Scrap
% for the boundary.
 Note that bedges(i,:) is in triangle t(tidx(i),:).
\end_layout

\begin_layout Scrap
% The feature hash table (fht) is used to obtain variable indexes
\end_layout

\begin_layout Scrap
% for given features.
 This is obtained by create_fht().
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% A must be nv x nv and b must be nv x 1 where nv is the total
\end_layout

\begin_layout Scrap
% number of variables (as returned by fht_num_vars()).
\end_layout

\begin_layout Scrap
% Reference edge has vertices 0 and 1.
\end_layout

\begin_layout Scrap
[p_int,w_int] = intmethod(); % points and weights for reference triangle
\end_layout

\begin_layout Scrap
% np is the total number of points in the triangulation
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
% compute nv = total number of variables
\end_layout

\begin_layout Scrap
nv = fht_num_vars(fht);
\end_layout

\begin_layout Scrap
% nv_edge is the number of variables in one edge (and associated points)
\end_layout

\begin_layout Scrap
%nv_elt = sum(elt.nvars);
\end_layout

\begin_layout Scrap
nv_edge = 0;
\end_layout

\begin_layout Scrap
for i = 1:size(elt.flist,1)
\end_layout

\begin_layout Scrap
    if sum(elt.flist(i,:) ~= 0) <= 2
\end_layout

\begin_layout Scrap
        nv_edge = nv_edge + elt.nvars(i);
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
end % for
\end_layout

\begin_layout Scrap
% order is the order of differentiation used in the "PDE"
\end_layout

\begin_layout Scrap
order = pde.order;
\end_layout

\begin_layout Scrap
A = sparse(nv,nv);
\end_layout

\begin_layout Scrap
b = zeros(nv,1);
\end_layout

\begin_layout Scrap
bvlist = [];
\end_layout

\begin_layout Scrap
for i = 1:size(bedges,1) % for all boundary edges ...
\end_layout

\begin_layout Scrap
    % obtain variable list and signs for this triangle & boundary edge
\end_layout

\begin_layout Scrap
    bedge = bedges(i,:);
\end_layout

\begin_layout Scrap
    triangle = t(tidx(i),:);
\end_layout

\begin_layout Scrap
    [tvlist,slist] = get_var_triangle(t(tidx(i),:),fht,elt,np);
\end_layout

\begin_layout Scrap
    bvlist1 = get_var_edge(bedges(i,:),fht,np);
\end_layout

\begin_layout Scrap
    bvlist  = [bvlist,bvlist1];
\end_layout

\begin_layout Scrap
    match = match_edge_triangle(bedges(i,:),t(tidx(i),:));
\end_layout

\begin_layout Scrap
    % set up affine transformation xhat :-> x = T.xhat + b0
\end_layout

\begin_layout Scrap
    i1 = t(tidx(i),1); i2 = t(tidx(i),2); i3 = t(tidx(i),3);
\end_layout

\begin_layout Scrap
    T = [p(i2,:)'-p(i1,:)', p(i3,:)'-p(i1,:)'];
\end_layout

\begin_layout Scrap
    b0 = p(i1,:)';
\end_layout

\begin_layout Scrap
    % Turn p_int on the interval [0,1] to points on the appropriate
\end_layout

\begin_layout Scrap
    % edge of the reference triangle
\end_layout

\begin_layout Scrap
    p_ref = [0 0; 1 0; 0 1];
\end_layout

\begin_layout Scrap
    p_ref0 = p_ref(match(1),:);
\end_layout

\begin_layout Scrap
    p_ref1 = p_ref(match(2),:);
\end_layout

\begin_layout Scrap
    % form weighted sum of integrand at integration points
\end_layout

\begin_layout Scrap
    intval1 = zeros(length(tvlist),length(tvlist));
\end_layout

\begin_layout Scrap
    intval2 = zeros(length(tvlist),1);
\end_layout

\begin_layout Scrap
    for k = 1:length(w_int)
\end_layout

\begin_layout Scrap
        p_int_ref = (1-p_int(k))*p_ref0+p_int(k)*p_ref1;
\end_layout

\begin_layout Scrap
        % p_int_val = T*p_int_ref'+b0;
\end_layout

\begin_layout Scrap
        Aphivalhat = elt.Aphihat(p_int_ref,order);
\end_layout

\begin_layout Scrap
        Aphival = elt.trans_Aphihat(T,Aphivalhat,order);
\end_layout

\begin_layout Scrap
        Dmat = pde.coeffs(T*p_int_ref'+b0);
\end_layout

\begin_layout Scrap
        rhsvec = pde.rhs(T*p_int_ref'+b0);
\end_layout

\begin_layout Scrap
        integrand_val1 = Aphival*Dmat*Aphival';
\end_layout

\begin_layout Scrap
        integrand_val2 = Aphival*rhsvec;
\end_layout

\begin_layout Scrap
        intval1 = intval1 + w_int(k)*integrand_val1;
\end_layout

\begin_layout Scrap
        intval2 = intval2 + w_int(k)*integrand_val2;
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
    detT = norm(p(t(tidx(i),match(1)),:)-p(t(tidx(i),match(2)),:),2);
\end_layout

\begin_layout Scrap
    intval1 = intval1*detT;
\end_layout

\begin_layout Scrap
    intval2 = intval2*detT;
\end_layout

\begin_layout Scrap
    intval1 = diag(slist)*intval1*diag(slist); % change signs if needed
\end_layout

\begin_layout Scrap
    intval2 = slist'.*intval2;
\end_layout

\begin_layout Scrap
    A(tvlist,tvlist) = A(tvlist,tvlist) + intval1; % add to matrix & vec
\end_layout

\begin_layout Scrap
    b(tvlist)        = b(tvlist) + intval2;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
bvlist = unique(sort(bvlist));
\end_layout

\begin_layout Scrap
v_array = ones(nv,1);
\end_layout

\begin_layout Scrap
v_array(bvlist) = 0;
\end_layout

\begin_layout Scrap
cbvlist = find(v_array ~= 0);
\end_layout

\begin_layout Scrap
Ab(cbvlist,:) = 0;
\end_layout

\begin_layout Scrap
Ab(:,cbvlist) = 0;
\end_layout

\begin_layout Scrap
b(cbvlist) = 0;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Handling-geometric-features"

\end_inset

Handling geometric features
\end_layout

\begin_layout Standard
Geometric features are triangles, edges, and points (vertices) of the triangulat
ion.
 Each variable is associated with a single geometric feature: if several
 seem possible, then we choose the one of lowest dimension.
 For example, if we use a piecewise linear finite element space over a given
 triangulation, then each variable is associated with a vertex of a triangle
 in the triangulation.
 Then each vertex has one variable whose value is the same for all the triangles
 sharing that vertex.
 This ensures that at any edge shared between two triangles, the value of
 a piecewise linear function is the same at the ends of the edge and so
 is the same along the entire edge.
 This ensures continuity of the piecewise linear function.
\end_layout

\begin_layout Standard
A function in the piecewise linear finite element space will have the form
\begin_inset Formula 
\[
v_{h}(\mathbf{x})=\sum_{i=1}^{N}v_{i}\,\phi_{i}(\mathbf{x})
\]

\end_inset

where 
\begin_inset Formula $v_{i}$
\end_inset

 are the values associated with the vertices of the triangulation; for each
 triangle 
\begin_inset Formula $K$
\end_inset

 in the triangulation, 
\begin_inset Formula $\phi_{i}|K$
\end_inset

 is a linear (actually, affine) function.
 When we assemble the part of a matrix for triangle 
\begin_inset Formula $K$
\end_inset

, we need to ensure that the same 
\begin_inset Formula $v_{i}$
\end_inset

 is used.
 To do this, we have a list of all the variables (in order) associated with
 a given vertex.
 
\end_layout

\begin_layout Standard
Similarly, for a quadratic Lagrange basis, we typically use a nodal basis
 using values at the vertices of a triangle, and the values at the midpoints
 of the edges of the triangle.
 A function in the finite element space generated by these nodal basis functions
 must have the same values at every point on an edge shared between two
 elements.
 It is sufficient if the values at the shared vertices and shared edge's
 midpoint are equal: two quadratic functions of one variable that are equal
 at three points must be the same.
 The basis functions 
\begin_inset Formula $\phi_{i}$
\end_inset

 have an associated value or variable 
\begin_inset Formula $v_{i}$
\end_inset

 for representing a function in the finite element space
\begin_inset Formula 
\[
v_{h}(\mathbf{x})=\sum_{i=1}^{N}v_{i}\,\phi_{i}(\mathbf{x}).
\]

\end_inset

If 
\begin_inset Formula $\phi_{i}$
\end_inset

 is a nodal basis function for a vertex then 
\begin_inset Formula $v_{i}$
\end_inset

 is associated with that vertex; if it is associated with a midpoint of
 an edge, it is associated with that edge.
 
\end_layout

\begin_layout Standard
For a cubic Lagrange basis, we use a nodal basis using values at the vertices,
 values at points along each edge at the 1/3 and 2/3 positions, and one
 at the centroid of the triangle.
 This time there is one variables associated with each vertex, one with
 each triangle, but two with each edge.
 It is important to distinguish between the two variables associated with
 a given edge, because they correspond to different basis functions.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Feature-hash-tables"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
feature hash table
\end_layout

\end_inset

Feature hash tables
\end_layout

\begin_layout Standard
Each geometric feature then has an associated ordered list of variables.
 To store these we use a hash table.
 Matlab's 
\family typewriter
container.Map
\family default
, however, allows only string or integer keys, so we need to convert a feature
 (given as a list of indexes into the 
\family typewriter
p
\family default
 array) into an integer.
 This is done as follows:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
get_feature_ref()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
get-feature-ref.m 
\backslash

\end_layout

\begin_layout Scrap
<<get-feature-ref.m>>=
\end_layout

\begin_layout Scrap
function ref = get_feature_ref(f,np)
\end_layout

\begin_layout Scrap
% function ref = get_feature_ref(f,np)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Return a unique integer for the given feature, for
\end_layout

\begin_layout Scrap
% use in the feature hashtable.
\end_layout

\begin_layout Scrap
% np is the number of points in the triangulation.
\end_layout

\begin_layout Scrap
ref = sum(int64(f) .* int64(np).^int64(0:length(f)-1));
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
From the triangulation and the element type we can create the entire hash
 table (see 
\emph on
create-fht.m
\emph default
).
 Note that we need certain information from the element type (
\family typewriter
elt
\family default
): 
\family typewriter
elt.flist
\family default
 is a list of geometric features to which variables are associated for the
 reference element.
 Note that these are lists of integers in the set 
\begin_inset Formula $\left\{ 1,2,3\right\} $
\end_inset

; these integers refer to the vertices of the reference element: vertex
 1 is 
\begin_inset Formula $(0,0)$
\end_inset

, vertex 2 is 
\begin_inset Formula $(1,0)$
\end_inset

, and vertex 3 is 
\begin_inset Formula $(0,1)$
\end_inset

.
 The number of variables associated with the feature 
\family typewriter
elt.flist(i,:)
\family default
 is 
\family typewriter
elt.nvars(i)
\family default
.
 For more details, see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Element-types"

\end_inset

.
 Variables are numbered sequentially as they are discovered.
 Note that if a geometric feature has already been found, then it is skipped.
\end_layout

\begin_layout Standard
It should be noted that all geometric features entered into 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
fht
\end_layout

\end_inset

fht
\family default
 must be 
\emph on
normalized
\emph default
; that is, they must be an increasing list of indexes into the 
\family typewriter
p
\family default
 array.
 Zero padding at the end should be stripped.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
create_fht()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
create-fht.m 
\backslash

\end_layout

\begin_layout Scrap
<<create-fht.m>>=
\end_layout

\begin_layout Scrap
function [fht,v2tnum,v2fnum,v2fidx] = create_fht(p,t,elt)
\end_layout

\begin_layout Scrap
% function [fht,v2tnum,v2fnum,v2fidx] = create_fht(p,t,elt)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Create feature hash table (fht) which shows what variables
\end_layout

\begin_layout Scrap
% are associated with which geometric features.
\end_layout

\begin_layout Scrap
% The geometric features inserted into fht must be
\end_layout

\begin_layout Scrap
% in normalized form (that is, a sorted vector of point indexes).
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% This routine also returns a variable-to-triangle-number array (v2tnum)
\end_layout

\begin_layout Scrap
% a variable-to-feature-number array (v2fnum), and a variable-to-feature-index
\end_layout

\begin_layout Scrap
% array (v2fidx).
\end_layout

\begin_layout Scrap
% The variable (or basis function) with global index k is the v2fidx(k)'th
\end_layout

\begin_layout Scrap
% basis function associated with the v2fnum(k)'th geometric feature of 
\end_layout

\begin_layout Scrap
% triangle v2tnum(k).
\end_layout

\begin_layout Scrap
fht = containers.Map('KeyType','int64','ValueType','any');
\end_layout

\begin_layout Scrap
nvars = elt.nvars;
\end_layout

\begin_layout Scrap
flist = elt.flist; % list of features with associated variables
\end_layout

\begin_layout Scrap
v2tnum = [];
\end_layout

\begin_layout Scrap
v2fnum = [];
\end_layout

\begin_layout Scrap
v2fidx = [];
\end_layout

\begin_layout Scrap
% flist is assumed normalized except for trailing zeros
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
counter = 0;
\end_layout

\begin_layout Scrap
for i = 1:size(t,1) % for each triangle ...
\end_layout

\begin_layout Scrap
    triangle = [0, t(i,:)];
\end_layout

\begin_layout Scrap
    tflist = triangle(flist+1);
\end_layout

\begin_layout Scrap
    for j = 1:size(flist,1)
\end_layout

\begin_layout Scrap
        % for each feature ...
\end_layout

\begin_layout Scrap
        f = tflist(j,:);
\end_layout

\begin_layout Scrap
        f = f(find(f ~= 0));
\end_layout

\begin_layout Scrap
        f = sort(f);
\end_layout

\begin_layout Scrap
        % Is this feature already in fht? If not add its variables.
\end_layout

\begin_layout Scrap
        ref = get_feature_ref(f,np);
\end_layout

\begin_layout Scrap
        if ~ isKey(fht,ref)
\end_layout

\begin_layout Scrap
            fht(ref) = [(counter+1):(counter + nvars(j))];
\end_layout

\begin_layout Scrap
            counter = counter + nvars(j);
\end_layout

\begin_layout Scrap
            v2tnum = [v2tnum, i*ones(1,nvars(j))];
\end_layout

\begin_layout Scrap
            v2fnum = [v2fnum, j*ones(1,nvars(j))];
\end_layout

\begin_layout Scrap
            v2fidx = [v2fidx, 1:nvars(j)];
\end_layout

\begin_layout Scrap
        end
\end_layout

\begin_layout Scrap
    end % for each feature
\end_layout

\begin_layout Scrap
    size_fht = size(fht);
\end_layout

\begin_layout Scrap
end % for each triangle
\end_layout

\begin_layout Scrap
end % function create_fht
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Using the feature hash table (
\family typewriter
fht
\family default
) can be done through a number of functions; the main one (used by the assembly
 functions) is 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
get
\family typewriter
_var_triangle()
\end_layout

\end_inset

get_var_triangle()
\family default
.
 This finds all variables associated with any geometric feature (triangle,
 edge, vertex) of the triangle.
 This triangle is represented as a triple of indexes into the 
\family typewriter
p
\family default
 array.
 
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
get-var-triangle.m 
\backslash

\end_layout

\begin_layout Scrap
<<get-var-triangle.m>>=
\end_layout

\begin_layout Scrap
function [vlist,slist] = get_var_triangle(tri,fht,elt,np)
\end_layout

\begin_layout Scrap
% function [vlist,slist] = get_var_triangle(tri,fht,elt,np)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Get the list of variables (vlist) and the list of sign changes (slist)
\end_layout

\begin_layout Scrap
% for a given triangle tri using the feature ahstable (fht) for
\end_layout

\begin_layout Scrap
% the given element type (see elt data structure).
\end_layout

\begin_layout Scrap
% Note that np is the number of points.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% tri is a 1 x 3 array of indexes into the p array of points in the
\end_layout

\begin_layout Scrap
% triangulation
\end_layout

\begin_layout Scrap
tri2 = [0,tri];
\end_layout

\begin_layout Scrap
flist = elt.flist;
\end_layout

\begin_layout Scrap
flist = tri2(flist+1); % use point indexes
\end_layout

\begin_layout Scrap
vlist = [];
\end_layout

\begin_layout Scrap
slist = [];
\end_layout

\begin_layout Scrap
for i = 1:size(flist,1) % for each feature
\end_layout

\begin_layout Scrap
f = flist(i,:);
\end_layout

\begin_layout Scrap
f = f(find(f ~= 0)); % strip zeros from f
\end_layout

\begin_layout Scrap
[fn,px] = sort(f); % normalize f: fn(px) == f
\end_layout

\begin_layout Scrap
ref = get_feature_ref(fn,np);
\end_layout

\begin_layout Scrap
if ~ isKey(fht,ref)
\end_layout

\begin_layout Scrap
    error('flexPDE:missing value','get_var_triangle: Missing feature',fn,ref)
\end_layout

\begin_layout Scrap
return
\end_layout

\begin_layout Scrap
else
\end_layout

\begin_layout Scrap
    fvlist = fht(ref);
\end_layout

\begin_layout Scrap
    [pxvars,fslist] = elt.pxfeature(px);
\end_layout

\begin_layout Scrap
    fvlist = fvlist(pxvars);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
% concatenate the list of variable indexes & signs
\end_layout

\begin_layout Scrap
vlist = [vlist,fvlist];
\end_layout

\begin_layout Scrap
slist = [slist,fslist];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
For performing boundary integrals we use the corresponding function for
 edges:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
get_var_edge()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
get-var-edge.m 
\backslash

\end_layout

\begin_layout Scrap
<<get-var-edge.m>>=
\end_layout

\begin_layout Scrap
function [vlist] = get_var_edge(edge,fht,np)
\end_layout

\begin_layout Scrap
% function [vlist] = get_var_edge(edge,fht,np)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns list of variable indexes for given edge (including end-point
\end_layout

\begin_layout Scrap
% variables).
 The feature hash table (fht) is used to look up variable
\end_layout

\begin_layout Scrap
% lists.
 Also np is the number of points in the triangulation.
\end_layout

\begin_layout Scrap
vlist = [];
\end_layout

\begin_layout Scrap
ref = get_feature_ref(sort(edge),np);
\end_layout

\begin_layout Scrap
if isKey(fht,ref)
\end_layout

\begin_layout Scrap
    vlist = [vlist, fht(ref)];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
ref = get_feature_ref(edge(1),np);
\end_layout

\begin_layout Scrap
if isKey(fht,ref)
\end_layout

\begin_layout Scrap
    vlist = [vlist, fht(ref)];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
ref = get_feature_ref(edge(2),np);
\end_layout

\begin_layout Scrap
if isKey(fht,ref)
\end_layout

\begin_layout Scrap
    vlist = [vlist, fht(ref)];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The total number of variables can be found using the following routine,
 which simply adds the lengths of all the lists of variables in 
\family typewriter
fht
\family default
.
 Note that this assumes that every variable is associated with exactly one
 geometric feature.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
fht_num_vars()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
fht-num-vars.m 
\backslash

\end_layout

\begin_layout Scrap
<<fht-num-vars.m>>=
\end_layout

\begin_layout Scrap
function nvars = fht_num_vars(fht)
\end_layout

\begin_layout Scrap
% function nvars = fht_num_vars(fht)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the total number of variables for a discretization
\end_layout

\begin_layout Scrap
% based on the feature hash table (fht), which stores
\end_layout

\begin_layout Scrap
% variable index lists for each geometric feature.
\end_layout

\begin_layout Scrap
nvars = 0;
\end_layout

\begin_layout Scrap
vals = values(fht);
\end_layout

\begin_layout Scrap
for i = 1:length(vals)
\end_layout

\begin_layout Scrap
    nvars = nvars + length(vals{i});
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Geometric-utilities"

\end_inset

Geometric utilities
\end_layout

\begin_layout Subsubsection
Find boundary
\end_layout

\begin_layout Standard
Finding boundary edges can be done directly from the 
\family typewriter
t
\family default
 array: a boundary edge is an edge of exactly one triangle.
 The basic code is here:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
boundary2d()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
boundary2d.m 
\backslash

\end_layout

\begin_layout Scrap
<<boundary2d.m>>=
\end_layout

\begin_layout Scrap
function [bedges,bnodes,t_index] = boundary2d(t)
\end_layout

\begin_layout Scrap
% function [bedges,bnodes,t_index] = boundary2d(t)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Construct boundary edge list from triangle list t
\end_layout

\begin_layout Scrap
% t is ntriangles x 3, bedges = nedges x 2
\end_layout

\begin_layout Scrap
% Edge k joins points bd(k,1) and bd(k,2).
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Simply check when edges only appear once in the triangle list.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Also returns the triangle index for each boundary edge
\end_layout

\begin_layout Scrap
t = sort(t,2); % sort each row of t
\end_layout

\begin_layout Scrap
bd1 = sortrows([t(:,1),t(:,2),(1:size(t,1))';
\end_layout

\begin_layout Scrap
                t(:,2),t(:,3),(1:size(t,1))';
\end_layout

\begin_layout Scrap
                t(:,1),t(:,3),(1:size(t,1))']);
\end_layout

\begin_layout Scrap
[bd2,idx1] = unique(bd1(:,1:2),'rows','first');
\end_layout

\begin_layout Scrap
[bd2,idx2] = unique(bd1(:,1:2),'rows','last');
\end_layout

\begin_layout Scrap
eqlist = find(idx1 == idx2);
\end_layout

\begin_layout Scrap
bedges = bd1(idx1(eqlist),1:2);
\end_layout

\begin_layout Scrap
t_index = bd1(idx1(eqlist),3);
\end_layout

\begin_layout Scrap
bnodes = unique(sort(bedges(:)));
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that this routine also returns 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
bnodes
\end_layout

\end_inset

bnodes
\family default
, a list of all vertices in the boundary, and 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
t_index
\end_layout

\end_inset

t_index
\family default
 where 
\family typewriter
t_index(i)
\family default
 is the row index into 
\family typewriter
t
\family default
 for the edge 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
bedges
\end_layout

\end_inset

bedges(i,:)
\family default
.
 
\end_layout

\begin_layout Subsubsection
Matching edges to triangles
\end_layout

\begin_layout Standard
This returns a two-integer vector matching a single given edge to a single
 given triangle.
 It is assumed that the edge is an edge of the triangle.
 All objects given as lists of indexes into 
\family typewriter
p
\family default
.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
match_edge_triangle()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
match-edge-triangle.m 
\backslash

\end_layout

\begin_layout Scrap
<<match-edge-triangle.m>>=
\end_layout

\begin_layout Scrap
function match = match_edge_triangle(edge,triangle)
\end_layout

\begin_layout Scrap
% function match = match_edge_triangle(edge,triangle)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns index vector (2 elements) match so that
\end_layout

\begin_layout Scrap
% edge(i) = triangle(match(i)), i = 1, 2.
\end_layout

\begin_layout Scrap
for i = 1:2
\end_layout

\begin_layout Scrap
    for j = 1:3
\end_layout

\begin_layout Scrap
        if edge(i) == triangle(j)
\end_layout

\begin_layout Scrap
            match(i) = j;
\end_layout

\begin_layout Scrap
        end
\end_layout

\begin_layout Scrap
    end % for j
\end_layout

\begin_layout Scrap
end % for i
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
The reference element
\end_layout

\begin_layout Standard
This returns the triangulation for the reference element.
 This is a convenience as well as a benchmark.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
ref-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<ref-elt.m>>=
\end_layout

\begin_layout Scrap
function [p,t] = ref_elt()
\end_layout

\begin_layout Scrap
% function [p,t] = ref_elt()
\end_layout

\begin_layout Scrap
% 
\end_layout

\begin_layout Scrap
% Returns the triangulation of the reference element.
\end_layout

\begin_layout Scrap
% This is a trivial task, but provides a convenient
\end_layout

\begin_layout Scrap
% benchmark for other tasks.
\end_layout

\begin_layout Scrap
p = [0 0; 1 0; 0 1];
\end_layout

\begin_layout Scrap
t = [1 2 3];
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Generating transformation for an element
\end_layout

\begin_layout Standard
Given the points of a triangle as rows of a 
\begin_inset Formula $3\times2$
\end_inset

 array, compute the matrix 
\begin_inset Formula $T$
\end_inset

 and vector 
\begin_inset Formula $\mathbf{b}$
\end_inset

 so that 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto T\widehat{\mathbf{x}}+\mathbf{b}$
\end_inset

 maps the reference triangle (vertices at 
\begin_inset Formula $(0,0)$
\end_inset

, 
\begin_inset Formula $(1,0)$
\end_inset

 and 
\begin_inset Formula $(0,1)$
\end_inset

) to the triangle given.
 Note that the ordering of the vertices is respected.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
gen-transform2d.m 
\backslash

\end_layout

\begin_layout Scrap
<<gen-transform2d.m>>=
\end_layout

\begin_layout Scrap
function [T,b] = gen_transform2d(p)
\end_layout

\begin_layout Scrap
% function [T,b] = gen_transform2d(p)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns T, b so that x 
\backslash
mapsto T*x+b maps
\end_layout

\begin_layout Scrap
% the reference triangle co{(0,0),(1,0),(0,1)} to
\end_layout

\begin_layout Scrap
% the given triangle, mapping (0,0) to p(1,:)',
\end_layout

\begin_layout Scrap
% (1,0) to p(2,:)' and (0,1) to p(3,:)'
\end_layout

\begin_layout Scrap
b = p(1,:)';
\end_layout

\begin_layout Scrap
T = [p(2,:)' - p(1,:)', p(3,:)' - p(1,:)'];
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Element-types"

\end_inset

Element types
\end_layout

\begin_layout Standard
Each element type is represented by a corresponding data structure.
 An element type must provide the basis functions 
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

 on the reference element and the various functions 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}$
\end_inset

 for 
\begin_inset Formula $\mathcal{A}=I$
\end_inset

, 
\begin_inset Formula $\partial/\partial x_{1}$
\end_inset

, 
\begin_inset Formula $\partial/\partial x_{2}$
\end_inset

 etc., and it must also provide the information as to which basis functions
 
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

 are associated with which geometric feature.
 The reference element has the basis functions ordered in a specific way.
 For a real element 
\begin_inset Formula $K$
\end_inset

, there must be an identification of the geometric features (triangle, edges,
 vertices) of 
\begin_inset Formula $K$
\end_inset

 with the corresponding geometric features of the reference element 
\begin_inset Formula $\widehat{K}$
\end_inset

.
\end_layout

\begin_layout Standard
For a description of the different components of the element type data structure
, see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piecewise-linear-elements"

\end_inset

.
\end_layout

\begin_layout Standard
Each element type structure contains the following fields: 
\family typewriter
Aphihat()
\family default
, 
\family typewriter
nvars
\family default
, 
\family typewriter
flist
\family default
, 
\family typewriter
pxfeature()
\family default
, 
\family typewriter
vnodes
\family default
 and 
\family typewriter
trans_Aphihat()
\family default
.
 The fields with 
\begin_inset Quotes eld
\end_inset


\family typewriter
()
\family default

\begin_inset Quotes erd
\end_inset

 are functions.
 The call 
\family typewriter
Aphihatvals = Aphihat(xhat,order)
\family default
 computes the values of 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 for all reference element basis functions 
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

, and various operators 
\begin_inset Formula $\mathcal{A}$
\end_inset

 (including the identity operator).
 Specifically, 
\family typewriter
Aphihatvals(i,j)
\family default
 is
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 where 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is the 
\begin_inset Formula $j$
\end_inset

th operator in the list of applicable operators (
\begin_inset Formula $\mathcal{A}$
\end_inset

 is the identity if 
\begin_inset Formula $j=1$
\end_inset

).
 The value 
\family typewriter
nvars(k)
\family default
 is the number of variables (or basis functions) associated with geometric
 feature 
\family typewriter
flist(k,:)
\family default
 of the reference element.
 The call 
\family typewriter
pxvars = pxfeature(px)
\family default
 returns the permutation of the variables (or basis functions) for a geometric
 feature of dimension 
\family typewriter
length(px)-1
\family default
.
 The point 
\family typewriter
vnodes(i,:)
\family default
 is the co-ordinate vector for the 
\begin_inset Formula $i$
\end_inset

th basis function's node.
 (Basis functions do not necessarily need to be nodal, but this gives a
 useful point associated with a given basis function.) The call 
\family typewriter
Aphivals = trans_Aphihat(T,Aphihatvals,order)
\family default
 computes the values 
\begin_inset Formula $\mathcal{A}\phi_{k}(\mathbf{x})$
\end_inset

 where 
\begin_inset Formula $\phi_{k}$
\end_inset

 is the actual basis function.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Piecewise-linear-elements"

\end_inset

Piecewise linear elements
\end_layout

\begin_layout Standard
First we consider 
\begin_inset Index idx
status open

\begin_layout Plain Layout
element!piecewise linear
\end_layout

\end_inset

piecewise linear elements.
 The main function called is 
\family typewriter
lin2d_elt()
\family default
.
 It creates a structure which contains the other routines needed to properly
 define the element type.
 The component 
\family typewriter
flist
\family default
 lists the geometric features of the reference element to which variables
 (or basis functions) are associated.
 A geometric feature is here described by a list or row of non-zero vertex
 indices for the reference element.
 The number of variables associated with geometric feature 
\family typewriter
flist(i)
\family default
 is 
\family typewriter
nvars(i)
\family default
.
 Thus the row 
\family typewriter
[1, 0, 0]
\family default
 of 
\family typewriter
flist
\family default
 shows that that variables are associated with vertex
\begin_inset space ~
\end_inset

1 of the reference element.
 Indeed, for the piecewise linear element here, all variables are associated
 with vertices.
 
\end_layout

\begin_layout Standard
On the other hand, for the piecewise cubic element, one row of 
\family typewriter
flist
\family default
 is 
\family typewriter
[1, 2, 0]
\family default
, indicating that the edge joining vertices one and two of the reference
 element has variables associated with it.
 The corresponding entry of 
\family typewriter
nvars
\family default
 is 2, showing that there are exactly two variables associated with this
 edge.
 Another row of 
\family typewriter
flist
\family default
 is 
\family typewriter
[1, 2, 3]
\family default
, and the corresponding entry of 
\family typewriter
nvars
\family default
 is 1, indicating that exactly one variable is associated with the triangle
 (and not any sub-feature).
 
\end_layout

\begin_layout Standard
Note that each variables is associated with 
\emph on
exactly one
\emph default
 geometric feature; for a nodal basis, a variable or basis function is associate
d with the geometric feature (triangle, edge, vertex) of lowest dimension
 that contains the nodal point.
\end_layout

\begin_layout Standard
The order of the geometric features in 
\family typewriter
flist
\family default
 must correspond to the order in which the basis functions occur in the
 
\family typewriter
elt.Aphihat()
\family default
 function.
 
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
lin2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
lin2d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<lin2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = lin2d_elt()
\end_layout

\begin_layout Scrap
% function elt = lin2d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the linear 2-D (3-point) element data structure.
\end_layout

\begin_layout Scrap
nvars = [1;1;1];
\end_layout

\begin_layout Scrap
flist = [1 0 0;
\end_layout

\begin_layout Scrap
         2 0 0;
\end_layout

\begin_layout Scrap
         3 0 0]; % the three vertices
\end_layout

\begin_layout Scrap
vnodes = [0 0;
\end_layout

\begin_layout Scrap
          1 0;
\end_layout

\begin_layout Scrap
          0 1];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@lin2d_Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
    'pxfeature',@lin2d_pxfeature,'vnodes',vnodes, ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',@trans2d_Aphilist);
\end_layout

\begin_layout Scrap
end
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Piecewise linear elements: Aphihat()
\end_layout

\begin_layout Standard
The first component of the structure is 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
Aphihat
\family typewriter
()
\end_layout

\end_inset

Aphihat
\family default
, which is set to be the function 
\family typewriter
lin2d_Aphihat()
\family default
.
 This computes 
\begin_inset Formula $\mathcal{A}\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 for 
\begin_inset Formula $i=1,\,2,\,\ldots,\, M$
\end_inset

, where 
\begin_inset Formula $M$
\end_inset

 is the number of basis functions for the reference element:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
lin2d_Aphihat()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<lin2d-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphilist = lin2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
% Aphilist = lin2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns array of basis function values, their gradient and Hessian entries
\end_layout

\begin_layout Scrap
% for linear (affine) basis functions on a 2-D reference triangle at xhat.
\end_layout

\begin_layout Scrap
% The vertices of the reference triangle are (0,0), (1,0), and (0,1).
\end_layout

\begin_layout Scrap
% Aphilist(i,j) is the value of the j'th operator on phi_i at xhat.
\end_layout

\begin_layout Scrap
% Here phi_i is the affine function where phi_i(xhat_j) == 1
\end_layout

\begin_layout Scrap
% if i == j, and zero otherwise; xhat_i is the i'th vertex listed above.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Order of operators: Aphi(xhat) = phi(xhat), d/dx1 phi(xhat),
\end_layout

\begin_layout Scrap
% d/dx2 phi(xhat), d^2/dx1^2 phi(xhat), d^2/dx1.dx2 phi(xhat),
\end_layout

\begin_layout Scrap
% d^2/dx2^2 phi(xhat).
  Note that x1 = x and x2 = y.
\end_layout

\begin_layout Scrap
x = xhat(1);  y = xhat(2);
\end_layout

\begin_layout Scrap
% Basis function values
\end_layout

\begin_layout Scrap
Aphilist0 = [1-x-y; 
\end_layout

\begin_layout Scrap
             x; 
\end_layout

\begin_layout Scrap
             y];
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    % Basis gradient values (along rows)
\end_layout

\begin_layout Scrap
    Aphilist1 = [-1 -1;
\end_layout

\begin_layout Scrap
                  1  0;
\end_layout

\begin_layout Scrap
                  0  1];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % Basis hessian values (along rows: dx1^2, dx1.dx2, dx2^2)
\end_layout

\begin_layout Scrap
    Aphilist2 = [0 0 0;
\end_layout

\begin_layout Scrap
                 0 0 0;
\end_layout

\begin_layout Scrap
                 0 0 0];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order == 0
\end_layout

\begin_layout Scrap
    Aphilist = Aphilist0;
\end_layout

\begin_layout Scrap
elseif order == 1
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1];
\end_layout

\begin_layout Scrap
elseif order == 2
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1,Aphilist2];
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
This is the main workhorse of the element type; it is the function that
 is called the most of all of the functions in the structure.
\end_layout

\begin_layout Subsubsection
Piecewise linear elements: pxfeature()
\end_layout

\begin_layout Standard
In addition, when a geometric feature is found as part of some element,
 the orientation of the element may result in certain variables being permuted.
 In the case of piecewise linear elements, the geometric features are vertices,
 which do not have an orientation.
 Consequently this code is essentially trivial.
 This component of the element type structure becomes important for certain
 other more complex elements.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
pxfeature()
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
lin2d_pxfeature()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<lin2d-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_vars,signs] = lin2d_pxfeature(px)
\end_layout

\begin_layout Scrap
% function [px_vars,signs] = lin2d_pxfeature(px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the permutation of the variables (px_vars),
\end_layout

\begin_layout Scrap
% and the sign changes (signs) resulting from a permutation (px)
\end_layout

\begin_layout Scrap
% applied to a feature of the appropriate dimension (== length(px)).
\end_layout

\begin_layout Scrap
% This is for the linear (or affine) 2-D triangle elements.
\end_layout

\begin_layout Scrap
dimp1 = sum(px ~= 0);  % dimp1 == dimension plus 1
\end_layout

\begin_layout Scrap
switch dimp1
\end_layout

\begin_layout Scrap
    case 1 % points
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    otherwise % not a valid feature
\end_layout

\begin_layout Scrap
        px_vars = []; signs = [];
\end_layout

\begin_layout Scrap
end % switch
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Transformation-scalar-Lagrange-elements"

\end_inset

Transformation routines: scalar Lagrange elements
\end_layout

\begin_layout Standard
The last component is the transformation routine to transform the basis
 functions and their derivatives from the reference triangle to a given
 real triangle using the map 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
trans2d_Aphilist()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basis function on the reference element
\begin_inset Index idx
status open

\begin_layout Plain Layout
reference element
\end_layout

\end_inset

 
\begin_inset Formula $\widehat{K}$
\end_inset

 is 
\begin_inset Formula $\widehat{\phi}$
\end_inset

, while the basis function on the real element 
\begin_inset Formula $K$
\end_inset

 is 
\begin_inset Formula $\phi$
\end_inset

 where 
\begin_inset Formula $\phi(\mathbf{x})=\widehat{\phi}(\widehat{\mathbf{x}})$
\end_inset

 provided 
\begin_inset Formula $\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

.
 The chain rule then says that 
\begin_inset Formula 
\begin{eqnarray*}
\frac{\partial\phi}{\partial x_{i}}(\mathbf{x}) & = & \frac{\partial}{\partial x_{i}}\widehat{\phi}(\widehat{\mathbf{x}})\\
 & = & \sum_{p}\frac{\partial\widehat{x}_{p}}{\partial x_{i}}\,\frac{\partial\widehat{\phi}}{\partial\widehat{x}_{p}}(\widehat{\mathbf{x}}).
\end{eqnarray*}

\end_inset

Now 
\begin_inset Formula $\widehat{\mathbf{x}}=T_{K}^{-1}(\mathbf{x}-\mathbf{b}_{K})$
\end_inset

, so if we write 
\begin_inset Formula $S_{K}=T_{K}^{-1}$
\end_inset

, then 
\begin_inset Formula 
\[
\frac{\partial\widehat{x}_{p}}{\partial x_{i}}=s_{pi}=(S_{K})_{pi}.
\]

\end_inset

In terms of the gradient vector,
\begin_inset Formula 
\[
\nabla\phi(\mathbf{x})=S_{K}^{T}\,\nabla\widehat{\phi}(\widehat{\mathbf{x}}).
\]

\end_inset

Since the gradient vectors below are given as 
\emph on
row
\emph default
 vectors, we do not need the transpose.
 
\end_layout

\begin_layout Standard
For second derivatives,
\begin_inset Formula 
\begin{eqnarray*}
\frac{\partial^{2}\phi}{\partial x_{i}\,\partial x_{j}}(\mathbf{x}) & = & \frac{\partial}{\partial x_{i}}\sum_{p}s_{pj}\,\frac{\partial\widehat{\phi}}{\partial\widehat{x}_{p}}(\widehat{\mathbf{x}})\\
 & = & \sum_{q}s_{qi}\frac{\partial}{\partial\widehat{x}_{q}}\sum_{p}s_{pj}\,\frac{\partial\widehat{\phi}}{\partial\widehat{x}_{p}}(\widehat{\mathbf{x}})\\
 & = & \sum_{p,q}s_{qi}s_{pj}\frac{\partial^{2}\widehat{\phi}}{\partial\widehat{x}_{q}\,\partial\widehat{x}_{p}}(\widehat{\mathbf{x}})\;=\;\sum_{p,q}s_{qi}\frac{\partial^{2}\widehat{\phi}}{\partial\widehat{x}_{q}\,\partial\widehat{x}_{p}}(\widehat{\mathbf{x}})s_{pj}.
\end{eqnarray*}

\end_inset

If 
\begin_inset Formula $\mbox{Hess}\,\psi$
\end_inset

is the usual Hessian matrix of 2nd derivatives, this can be written in the
 form
\begin_inset Formula 
\[
\mbox{Hess}\,\phi(\mathbf{x})=S^{T}\,\mbox{Hess}\,\widehat{\phi}(\widehat{\mathbf{x}})\, S.
\]

\end_inset

If 
\begin_inset Formula $H=\left[\begin{array}{cc}
h_{11} & h_{12}\\
h_{12} & h_{22}
\end{array}\right]$
\end_inset

 (symmetric) and 
\begin_inset Formula $S=\left[\begin{array}{cc}
s_{11} & s_{12}\\
s_{21} & s_{22}
\end{array}\right]$
\end_inset

 (which is usually not symmetric), we can easily verify that
\begin_inset Formula 
\[
S^{T}HS=\left[\begin{array}{cc}
\left(h_{11}s_{11}^{2}+2h_{12}s_{11}s_{21}+h_{22}s_{21}^{2}\right) & \left(h_{11}s_{11}s_{12}+h_{12}(s_{11}s_{22}+s_{12}s_{21})+h_{22}s_{21}s_{22}\right)\\
\left(\mbox{symmetric}\right) & \left(h_{11}s_{12}^{2}+2h_{12}s_{12}s_{22}+h_{22}s_{22}^{2}\right)
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
trans2d-Aphilist.m 
\backslash

\end_layout

\begin_layout Scrap
<<trans2d-Aphilist.m>>=
\end_layout

\begin_layout Scrap
function Aphilist2 = trans2d_Aphilist(T,Aphilist,order)
\end_layout

\begin_layout Scrap
% function Aphilist2 = trans2d_Aphilist(T,Aphilist,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Transforms Aphilist into Aphilist2 according to matrix T (2 x 2)
\end_layout

\begin_layout Scrap
% Note: Order of colums is [val, d/dx1, d/dx2, d^2/dx1^2, d^2/dx1.dx2, d^2/dx2^2]
\end_layout

\begin_layout Scrap
Aphilist2 = zeros(size(Aphilist));
\end_layout

\begin_layout Scrap
Aphilist2(:,1) = Aphilist(:,1); % values unchanged
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    S = inv(T);
\end_layout

\begin_layout Scrap
    Aphilist2(:,2:3) = Aphilist(:,2:3)*S; % chain rule for 1st derivatives
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % chain rule for 2nd derivatives (affine transformation)
\end_layout

\begin_layout Scrap
    Aphilist2(:,4) = Aphilist(:,4)*(S(1,1)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,5)*(2*S(2,1)*S(1,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(S(2,1)^2);
\end_layout

\begin_layout Scrap
    Aphilist2(:,5) = Aphilist(:,4)*(S(1,1)*S(1,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,5)*(S(1,1)*S(2,2)+S(1,2)*S(2,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(S(2,2)*S(2,1));
\end_layout

\begin_layout Scrap
    Aphilist2(:,6) = Aphilist(:,4)*(S(1,2)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,5)*(2*S(1,2)*S(2,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(S(2,2)^2);
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The 
\family typewriter
Aphilist_trans2d()
\family default
 function is common to all scalar Lagrange elements.
 However, for vector-valued elements or for certain 
\begin_inset Formula $C^{1}$
\end_inset

 elements (such as Bell's triangle or the Argyris element), this needs to
 be modified.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Piecewise-quadratic-elements"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
element!piecewise quadratic
\end_layout

\end_inset

Piecewise quadratic elements
\end_layout

\begin_layout Standard
Piecewise quadratic elements are based on nodal interpolation at the vertices
 and the midpoints of the edges, as illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Quadratic-Lagrange-element"

\end_inset

.
 It is important to use the midpoint as when two elements share a common
 edge, it is important that the nodal points are the same for both elements.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename quadratic-elt.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Quadratic-Lagrange-element"

\end_inset

Quadratic Lagrange element
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function that creates the element type data structure for piecewise
 quadratic elements is very similar to that for piecewise linear elements.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
quad2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
quad2d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<quad2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = quad2d_elt() 
\end_layout

\begin_layout Scrap
% function elt = quad2d_elt() 
\end_layout

\begin_layout Scrap
% 
\end_layout

\begin_layout Scrap
% Returns the quadratic 2-D (6-point) element data structure 
\end_layout

\begin_layout Scrap
nvars = [1;1;1;1;1;1]; 
\end_layout

\begin_layout Scrap
flist = [1 0 0;
\end_layout

\begin_layout Scrap
         2 0 0;
\end_layout

\begin_layout Scrap
         3 0 0;
\end_layout

\begin_layout Scrap
         1 2 0;
\end_layout

\begin_layout Scrap
         1 3 0;
\end_layout

\begin_layout Scrap
         2 3 0]; 
\end_layout

\begin_layout Scrap
vnodes = [0   0;
\end_layout

\begin_layout Scrap
          1   0;
\end_layout

\begin_layout Scrap
          0   1;
\end_layout

\begin_layout Scrap
          1/2 0;
\end_layout

\begin_layout Scrap
          0   1/2;
\end_layout

\begin_layout Scrap
          1/2 1/2];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@quad2d_Aphihat, ...
\end_layout

\begin_layout Scrap
     'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
     'pxfeature',@quad2d_pxfeature,'vnodes',vnodes, ...
\end_layout

\begin_layout Scrap
     'trans_Aphihat',@trans2d_Aphilist); 
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Piecewise quadratic elements: Aphihat()
\end_layout

\begin_layout Standard
This is the main workhorse of the quadratic element data structure:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
quad2d_Aphihat()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<quad2d-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphilist = quad2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
% function Aphilist = quad2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns array of basis functions, their gradient and Hessian entries
\end_layout

\begin_layout Scrap
% for quadratic basis functions on a 2-D reference triangle at xhat.
\end_layout

\begin_layout Scrap
% The vertices of the reference triangle are (0,0), (1,0), and (0,1).
\end_layout

\begin_layout Scrap
% Aphilist(i,j) is the value of the j'th operator on phi_i at xhat.
\end_layout

\begin_layout Scrap
% Here phi_i is the affine function where phi_i(xhat_j) == 1
\end_layout

\begin_layout Scrap
% if i == j, and zero otherwise; xhat_i is the i'th vertex listed above.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% order is the maximum order of derivatives considered (order <= 2)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Order of operators: Aphi(xhat) = phi(xhat), d/dx1 phi(xhat),
\end_layout

\begin_layout Scrap
% d/dx2 phi(xhat), d^2/dx1^2 phi(xhat), d^2/dx1.dx2 phi(xhat),
\end_layout

\begin_layout Scrap
% d^2/dx2^2 phi(xhat).
\end_layout

\begin_layout Scrap
x = xhat(1);  y = xhat(2);
\end_layout

\begin_layout Scrap
% basis function values
\end_layout

\begin_layout Scrap
Aphilist = [2*(1-x-y)*(0.5-x-y);
\end_layout

\begin_layout Scrap
            2*x*(x-0.5);
\end_layout

\begin_layout Scrap
            2*y*(y-0.5);
\end_layout

\begin_layout Scrap
            4*x*(1-x-y);
\end_layout

\begin_layout Scrap
            4*y*(1-x-y);
\end_layout

\begin_layout Scrap
            4*x*y];
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    % gradients (rows) of basis functions
\end_layout

\begin_layout Scrap
    Aphilist1 = [2*(2*(x+y)-1.5), 2*(2*(x+y)-1.5);
\end_layout

\begin_layout Scrap
                 4*x-1,           0;
\end_layout

\begin_layout Scrap
                 0,               4*y-1;
\end_layout

\begin_layout Scrap
                 4*(1-y)-8*x,     -4*x;
\end_layout

\begin_layout Scrap
                 -4*y,            4*(1-x)-8*y;
\end_layout

\begin_layout Scrap
                 4*y,             4*x];
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist, Aphilist1];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % Hessian matrix entries of basis functions: dx1^2, dx1.dx2, dx2^2
\end_layout

\begin_layout Scrap
    Aphilist2 = [4,  4,  4;
\end_layout

\begin_layout Scrap
                 4,  0,  0;
\end_layout

\begin_layout Scrap
                 0,  0,  4;
\end_layout

\begin_layout Scrap
                -8, -4,  0;
\end_layout

\begin_layout Scrap
                 0, -4, -8;
\end_layout

\begin_layout Scrap
                 0,  4,  0];
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist, Aphilist2];
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Piecewise quadratic elements: pxfeature()
\end_layout

\begin_layout Standard
Again this code is essentially trivial, even though we now have variables
 associated with edges rather than only with vertices as in the piecewise
 linear case.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
quad2d_pxfeature()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<quad2d-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_vars,signs] = quad2d_pxfeature(px)
\end_layout

\begin_layout Scrap
% function [px_vars,signs] = quad2d_pxfeature(px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the permutation of the variables (px_vars),
\end_layout

\begin_layout Scrap
% and the sign changes (signs) resulting from a permutation (px)
\end_layout

\begin_layout Scrap
% applied to a feature of the appropriate dimension (== length(px)).
\end_layout

\begin_layout Scrap
% This is for the quadratic 2-D triangle elements.
\end_layout

\begin_layout Scrap
dim = sum(px ~= 0)-1;
\end_layout

\begin_layout Scrap
switch dim
\end_layout

\begin_layout Scrap
    case 0 % points
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    case 1 % edges
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    otherwise % not a valid feature
\end_layout

\begin_layout Scrap
        px_vars = []; signs = [];
\end_layout

\begin_layout Scrap
end % switch
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Piecewise-cubic-elements"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
element!piecewise cubic
\end_layout

\end_inset

Piecewise cubic elements
\end_layout

\begin_layout Standard
These elements have a nodal basis with nodes at the vertices, at the 1/3
 and 2/3 points on each edge, and the centroid of the triangle.
 Because they have two node points on each edge, there may need to be some
 permutations to ensure correct references to variables (see 
\family typewriter
pxfeature()
\family default
 below).
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
cub2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
cub2d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<cub2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = cub2d_elt()
\end_layout

\begin_layout Scrap
% function elt = cub2d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns cubic 2-D (10-point) element data structure
\end_layout

\begin_layout Scrap
nvars = [1;1;1;2;2;2;1];
\end_layout

\begin_layout Scrap
flist = [1 0 0;
\end_layout

\begin_layout Scrap
         2 0 0;
\end_layout

\begin_layout Scrap
         3 0 0;
\end_layout

\begin_layout Scrap
         1 2 0;
\end_layout

\begin_layout Scrap
         1 3 0;
\end_layout

\begin_layout Scrap
         2 3 0;
\end_layout

\begin_layout Scrap
         1 2 3];
\end_layout

\begin_layout Scrap
vnodes = [0   0;
\end_layout

\begin_layout Scrap
          1   0;
\end_layout

\begin_layout Scrap
          0   1;
\end_layout

\begin_layout Scrap
          0   1/3;
\end_layout

\begin_layout Scrap
          0   2/3;
\end_layout

\begin_layout Scrap
          1/3 0;
\end_layout

\begin_layout Scrap
          2/3 0;
\end_layout

\begin_layout Scrap
          1/3 2/3;
\end_layout

\begin_layout Scrap
          2/3 1/3;
\end_layout

\begin_layout Scrap
          1/3 1/3];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@cub2d_Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
    'pxfeature',@cub2d_pxfeature,'vnodes',vnodes, ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',@trans2d_Aphilist);
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Piecewise cubic elements: Aphihat
\end_layout

\begin_layout Standard
There are six basis functions on the reference element.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
cub2d_Aphihat()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<cub2d-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphihat = cub2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
% function Aphihat = cub2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns basis function values, gradients and Hessian
\end_layout

\begin_layout Scrap
% entries for Lagrangian cubic basis functions on the
\end_layout

\begin_layout Scrap
% reference triangle with vertices (0,0), (1,0), and (0,1).
\end_layout

\begin_layout Scrap
% Each row contains the value, 1st derivatives, and 2nd derivatives 
\end_layout

\begin_layout Scrap
% of the corresponding basis function on the reference element.
\end_layout

\begin_layout Scrap
x = xhat(1);
\end_layout

\begin_layout Scrap
y = xhat(2);
\end_layout

\begin_layout Scrap
Aphihat0 = [(9/2)*(1-x-y)*(2/3-x-y)*(1/3-x-y);
\end_layout

\begin_layout Scrap
    (9/2)*x*(x-1/3)*(x-2/3);
\end_layout

\begin_layout Scrap
    (9/2)*y*(y-1/3)*(y-2/3);
\end_layout

\begin_layout Scrap
    (27/2)*x*(2/3-x-y)*(1-x-y);
\end_layout

\begin_layout Scrap
    (27/2)*x*(x-1/3)*(1-x-y);
\end_layout

\begin_layout Scrap
    (27/2)*y*(2/3-x-y)*(1-x-y);
\end_layout

\begin_layout Scrap
    (27/2)*y*(y-1/3)*(1-x-y);
\end_layout

\begin_layout Scrap
    (27/2)*x*y*(x-1/3);
\end_layout

\begin_layout Scrap
    (27/2)*x*y*(y-1/3);
\end_layout

\begin_layout Scrap
    27*x*y*(1-x-y)];
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    Aphihat1 = [ ...
\end_layout

\begin_layout Scrap
      18*x + 18*y - 27*x*y - (27*x^2)/2 - (27*y^2)/2 - 11/2, 18*x + 18*y
 - 27*x*y - (27*x^2)/2 - (27*y^2)/2 - 11/2;
\end_layout

\begin_layout Scrap
      (27*x^2)/2 - 9*x + 1, 0;
\end_layout

\begin_layout Scrap
      0, (27*y^2)/2 - 9*y + 1;
\end_layout

\begin_layout Scrap
      (81*x^2)/2 + 54*x*y - 45*x + (27*y^2)/2 - (45*y)/2 + 9, (9*x*(6*x
 + 6*y - 5))/2;
\end_layout

\begin_layout Scrap
      36*x + (9*y)/2 - 27*x*y - (81*x^2)/2 - 9/2, -(27*x*(x - 1/3))/2;
\end_layout

\begin_layout Scrap
      (9*y*(6*x + 6*y - 5))/2, (27*x^2)/2 + 54*x*y - (45*x)/2 + (81*y^2)/2
 - 45*y + 9;
\end_layout

\begin_layout Scrap
      -(27*y*(y - 1/3))/2, (9*x)/2 + 36*y - 27*x*y - (81*y^2)/2 - 9/2;
\end_layout

\begin_layout Scrap
      (9*y*(6*x - 1))/2, (27*x*(x - 1/3))/2;
\end_layout

\begin_layout Scrap
      (27*y*(y - 1/3))/2, (9*x*(6*y - 1))/2;
\end_layout

\begin_layout Scrap
      -27*y*(2*x + y - 1), -27*x*(x + 2*y - 1)];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    Aphihat2 = [ ...
\end_layout

\begin_layout Scrap
      18 - 27*y - 27*x, 18 - 27*y - 27*x, 18 - 27*y - 27*x;
\end_layout

\begin_layout Scrap
      27*x - 9, 0, 0;
\end_layout

\begin_layout Scrap
      0, 0, 27*y - 9;
\end_layout

\begin_layout Scrap
      81*x + 54*y - 45, 54*x + 27*y - 45/2, 27*x;
\end_layout

\begin_layout Scrap
      36 - 27*y - 81*x, 9/2 - 27*x, 0;
\end_layout

\begin_layout Scrap
      27*y, 27*x + 54*y - 45/2, 54*x + 81*y - 45;
\end_layout

\begin_layout Scrap
      0, 9/2 - 27*y, 36 - 81*y - 27*x;
\end_layout

\begin_layout Scrap
      27*y, 27*x - 9/2, 0;
\end_layout

\begin_layout Scrap
      0, 27*y - 9/2, 27*x;
\end_layout

\begin_layout Scrap
      -54*y, 27 - 54*y - 54*x, -54*x];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order == 0
\end_layout

\begin_layout Scrap
    Aphihat = Aphihat0;
\end_layout

\begin_layout Scrap
elseif order == 1
\end_layout

\begin_layout Scrap
    Aphihat = [Aphihat0, Aphihat1];
\end_layout

\begin_layout Scrap
elseif order == 2
\end_layout

\begin_layout Scrap
    Aphihat = [Aphihat0, Aphihat1, Aphihat2];
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Piecewise cubic elements: pxfeature()
\end_layout

\begin_layout Standard
Here we need to permute the two edge variables.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
cub2d_pxfeature()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<cub2d-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_vars,signs] = cub2d_pxfeature(px)
\end_layout

\begin_layout Scrap
% function [px_vars,signs] = cub2d_pxfeature(px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the permutation of the variables (px_vars),
\end_layout

\begin_layout Scrap
% and the sign changes (signs) resulting from a permutation (px)
\end_layout

\begin_layout Scrap
% applied to a feature of the appropriate dimension (== length(px)).
\end_layout

\begin_layout Scrap
% This is for the quadratic 2-D triangle elements.
\end_layout

\begin_layout Scrap
dim = sum(px ~= 0)-1;
\end_layout

\begin_layout Scrap
switch dim
\end_layout

\begin_layout Scrap
    case 0 % points
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    case 1 % edges
\end_layout

\begin_layout Scrap
        px_vars = px; signs = [1 1];
\end_layout

\begin_layout Scrap
    case 2 % triangles
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    otherwise % not a valid feature
\end_layout

\begin_layout Scrap
        px_vars = []; signs = [];
\end_layout

\begin_layout Scrap
end % switch
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Piecewise-constant-elements"

\end_inset

Piecewise constant elements
\end_layout

\begin_layout Standard
Piecewise constant functions are either completely constant, or are discontinuou
s.
 This limits their applicability, but they can still be useful.
 Their definition for this system follows.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
const2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
const2d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<const2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = const2d_elt()
\end_layout

\begin_layout Scrap
% function elt = const2d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns constant 2-D triangle element
\end_layout

\begin_layout Scrap
nvars  = [1];
\end_layout

\begin_layout Scrap
flist  = [1 2 3];
\end_layout

\begin_layout Scrap
vnodes = [1/3, 1/3];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@const2d_Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
    'pxfeature',@const2d_pxfeature,'vnodes',vnodes, ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',@trans2d_Aphilist);
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The basis functions are easy to compute:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
const2d_Aphihat()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<const2d-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphilist = const2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
% function Aphilist = const2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns array of basis function values, their gradient and Hessian entries
\end_layout

\begin_layout Scrap
% for constant basis functions on a 2-D reference triangle at xhat.
\end_layout

\begin_layout Scrap
% Basis function values
\end_layout

\begin_layout Scrap
Aphilist0 = [1];
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    % Basis gradient values (along rows)
\end_layout

\begin_layout Scrap
    Aphilist1 = [0 0];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % Basis hessian values (along rows: d1^2, d1.d2, d2^2)
\end_layout

\begin_layout Scrap
    Aphilist2 = [0 0 0];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order == 0
\end_layout

\begin_layout Scrap
    Aphilist = Aphilist0;
\end_layout

\begin_layout Scrap
elseif order == 1
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1];
\end_layout

\begin_layout Scrap
elseif order == 2
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1,Aphilist2];
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
There is only one variable so changing the orientation does not do much
 to the variables.
\end_layout

\begin_layout Scrap
<<const2d-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_vars,signs] = const2d_pxfeature(px)
\end_layout

\begin_layout Scrap
% function [px_vars,signs] = const2d_pxfeature(px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the permutation of the variables (px_vars),
\end_layout

\begin_layout Scrap
% and the sign changes (signs) resulting from a permutation (px)
\end_layout

\begin_layout Scrap
% applied to a feature of the appropriate dimension (== length(px)).
\end_layout

\begin_layout Scrap
% This is for the quadratic 2-D triangle elements.
\end_layout

\begin_layout Scrap
dim = sum(px ~= 0)-1;
\end_layout

\begin_layout Scrap
switch dim
\end_layout

\begin_layout Scrap
    case 2 % triangles
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    otherwise % not a valid feature
\end_layout

\begin_layout Scrap
        px_vars = []; signs = [];
\end_layout

\begin_layout Scrap
end % switch
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Vector-elements"

\end_inset

Vector elements
\end_layout

\begin_layout Standard
Rather than create a vector element type separately for each scalar element
 type, we can create them automatically from the scalar element type.
 There is a new transformation routine, and it is here that the vector character
 is made apparent.
 The final result after the transformation has the columns of the output
 ordered as 
\begin_inset Formula $\mathbf{e}_{1}\cdot\phi_{i}(\mathbf{x})$
\end_inset

, 
\begin_inset Formula $\mathbf{e}_{2}\cdot\phi_{i}(\mathbf{x})$
\end_inset

, 
\begin_inset Formula $\mathbf{e}_{1}\cdot\partial\phi_{i}/\partial x_{1}(\mathbf{x})$
\end_inset

, 
\begin_inset Formula $\mathbf{e}_{2}\cdot\partial\phi_{i}/\partial x_{1}(\mathbf{x})$
\end_inset

, etc.
 That is, the components alternate.
 
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
eltx2_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
eltx2-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<eltx2-elt.m>>=
\end_layout

\begin_layout Scrap
function eltx2 = eltx2_elt(elt)
\end_layout

\begin_layout Scrap
% function eltx2 = eltx2_elt(elt)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns element data structure with the same basis
\end_layout

\begin_layout Scrap
% functions as defined by elt, but with 2 components for
\end_layout

\begin_layout Scrap
% each component of elt.
\end_layout

\begin_layout Scrap
nvars = elt.nvars;
\end_layout

\begin_layout Scrap
nvarsx2 = 2*nvars;
\end_layout

\begin_layout Scrap
flist = elt.flist;
\end_layout

\begin_layout Scrap
flistx2 = flist;
\end_layout

\begin_layout Scrap
trans_Aphihat = @(T,Aphilist,order)(transx2(elt.trans_Aphihat,T,Aphilist,order));
\end_layout

\begin_layout Scrap
pxfeature = @(px)(pxfeaturex2(elt.pxfeature,px));
\end_layout

\begin_layout Scrap
vnodes = elt.vnodes();
\end_layout

\begin_layout Scrap
vnodesx2 = zeros(2*size(vnodes,1),size(vnodes,2));
\end_layout

\begin_layout Scrap
vnodesx2(2*(1:size(vnodes,1))-1,:) = vnodes;
\end_layout

\begin_layout Scrap
vnodesx2(2*(1:size(vnodes,1)) ,:) = vnodes;
\end_layout

\begin_layout Scrap
eltx2 = struct('Aphihat',elt.Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvarsx2,'flist',flistx2, ...
\end_layout

\begin_layout Scrap
    'pxfeature',pxfeature,'vnodes',vnodesx2, ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',trans_Aphihat);
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that the original 
\family typewriter
Aphihat()
\family default
 function is used.
 But we need new permutation and transformation functions based on the originals.
\end_layout

\begin_layout Subsubsection
Vector elements: pxfeature()
\end_layout

\begin_layout Scrap
<<eltx2-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_varsx2,signsx2] = pxfeaturex2(base_pxfeature,px)
\end_layout

\begin_layout Scrap
% function [px_varsx2,signsx2] = pxfeaturex2(base_pxfeature,px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Uses base_pxfeature to create pxfeature() function for the "x2" element
\end_layout

\begin_layout Scrap
[px_vars,signs] = base_pxfeature(px);
\end_layout

\begin_layout Scrap
px_varsx2 = zeros(1,2*length(px_vars));
\end_layout

\begin_layout Scrap
signsx2   = zeros(1,2*length(px_vars));
\end_layout

\begin_layout Scrap
px_varsx2(2*(1:length(px_vars))-1) = 2*px_vars-1;
\end_layout

\begin_layout Scrap
signsx2(2*(1:length(px_vars))-1)   = signs;
\end_layout

\begin_layout Scrap
px_varsx2(2*(1:length(px_vars)) )  = 2*px_vars;
\end_layout

\begin_layout Scrap
signsx2(2*(1:length(px_vars)) )    = signs;
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Vector elements: trans_Aphilist()
\end_layout

\begin_layout Scrap
<<eltx2-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphilistx2 = transx2(base_trans,T,Aphilist,order)
\end_layout

\begin_layout Scrap
% function Aphilistx2 = transx2(base_trans,T,Aphilist,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Uses base_trans to create trans_Aphilist function for the "x2" element
\end_layout

\begin_layout Scrap
Aphilist = base_trans(T,Aphilist,order);
\end_layout

\begin_layout Scrap
nb = size(Aphilist,1);
\end_layout

\begin_layout Scrap
Aphilistx2 = zeros(2*nb,size(Aphilist,2));
\end_layout

\begin_layout Scrap
Aphilistx2(2*(1:nb)-1,1) = Aphilist(:,1);
\end_layout

\begin_layout Scrap
Aphilistx2(2*(1:nb) ,2) = Aphilist(:,1);
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    Aphilistx2(2*(1:nb)-1,3:4) = Aphilist(:,2:3);
\end_layout

\begin_layout Scrap
    Aphilistx2(2*(1:nb) ,5:6) = Aphilist(:,2:3);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    Aphilistx2(2*(1:nb)-1,7:9) = Aphilist(:,4:6);
\end_layout

\begin_layout Scrap
    Aphilistx2(2*(1:nb) ,10:12) = Aphilist(:,4:6);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset Formula $C^{1}$
\end_inset

 elements: Bell's triangle
\end_layout

\begin_layout Standard
Work in progress.
\end_layout

\begin_layout Subsection
Stokes' equations: the Arnold--Brezzi--Fortin elements
\end_layout

\begin_layout Standard
Work in progress.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
Stokes' equation
\end_layout

\end_inset

Stokes' equations have the form
\begin_inset Formula 
\begin{eqnarray*}
-\mu\Delta\mathbf{u}+\left(\mathbf{w}\cdot\nabla\right)\mathbf{u} & = & -\nabla p+\mathbf{f}(\mathbf{x}),\\
\nabla\cdot\mathbf{u} & = & 0.
\end{eqnarray*}

\end_inset

This is a natural template for the Navier--Stokes equations for incompressible
 Newtonian fluidswhere 
\begin_inset Formula $\mathbf{u}$
\end_inset

 is the velocity field, and 
\begin_inset Formula $p$
\end_inset

 is the pressure field.
 For 
\begin_inset Formula $\mathbf{w}=0$
\end_inset

, the Stokes equations can be treated as a constrained optimization problem:
\begin_inset Formula 
\begin{eqnarray*}
 &  & \min\int_{\Omega}\left[\frac{1}{2}\mu\left|\nabla\mathbf{u}\right|^{2}-\mathbf{f}\cdot\mathbf{u}\right]d\mathbf{x}\qquad\mbox{subject to}\\
 &  & \qquad\nabla\cdot\mathbf{u}=0,
\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $p$
\end_inset

 takes the role of Lagrange multiplier.
 A global condition has to be placed on 
\begin_inset Formula $p$
\end_inset

 as otherwise replacing 
\begin_inset Formula $p$
\end_inset

 with 
\begin_inset Formula $p+c$
\end_inset

 for any constant 
\begin_inset Formula $c$
\end_inset

 gives a new solution.
 For uniqueness we typically require that 
\begin_inset Formula $\int_{\Omega}p\, d\mathbf{x}=0$
\end_inset

.
\end_layout

\begin_layout Standard
The weak form of Stokes' equations are: for all suitable 
\begin_inset Formula $\mathbf{v}$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

,
\begin_inset Formula 
\begin{eqnarray*}
\int_{\Omega}\left[\mu\nabla\mathbf{v}:\nabla\mathbf{u}+\mathbf{v}\cdot\left(\left(\mathbf{w}\cdot\nabla\right)\mathbf{u}\right)-\left(\nabla\cdot\mathbf{v}\right)p\right]d\mathbf{x} & = & \int_{\Omega}\mathbf{v}\cdot\mathbf{f}\, d\mathbf{x}+(\mbox{boundary integrals}),\\
\int_{\Omega}q\left(\nabla\cdot\mathbf{u}\right)\, d\mathbf{x} & = & 0.
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This can be dealt with in separate ways.
 We can create separate elements for 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

, and use 
\family typewriter
pgassembly()
\family default
 to combine them, or we can create a single element for both together.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
element!Arnold--Brezzi--Fortin
\end_layout

\end_inset

Arnold--Brezzi--Fortin (ABF) finite element method for this problem involves
 using an enriched piecewise linear element for each component of 
\begin_inset Formula $\mathbf{u}$
\end_inset

 and piecewise linear elements for 
\begin_inset Formula $p$
\end_inset

.
 The additional basis function for each 
\begin_inset Formula $u_{i}$
\end_inset

 has the form 
\begin_inset Formula $\lambda_{1}\lambda_{2}\lambda_{3}$
\end_inset

 in barycentric coordinates, or in standard coordinates for the reference
 triangle, 
\begin_inset Formula $27xy(1-x-y)$
\end_inset

.
 We can create a scalar ABF element which contains just the four basis functions
 necessary, and then use 
\family typewriter
eltx2_elt()
\family default
 to create the vector element for 
\begin_inset Formula $\mathbf{u}$
\end_inset

.
\end_layout

\begin_layout Standard
The vector element for 
\begin_inset Formula $\mathbf{u}$
\end_inset

 is simply the ABF scalar element 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\times2$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
abf2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
abf2d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<abf2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = abf2d_elt()
\end_layout

\begin_layout Scrap
% function elt = abf2d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% ABF vector element for velocity field.
\end_layout

\begin_layout Scrap
% This is the ABF scalar element "x2".
\end_layout

\begin_layout Scrap
% The rationale for using this set of basis functions is
\end_layout

\begin_layout Scrap
% given in Arnold, Brezzi and Fortin, 
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
elt = eltx2_elt(abfs2d_elt());
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The scalar element is defined below.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
abfs2d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<abf2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = abfs2d_elt()
\end_layout

\begin_layout Scrap
% function elt = abfs2d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the ABF scalar 2-D (3-point) element data structure.
\end_layout

\begin_layout Scrap
% The basis functions for this element are the same as for
\end_layout

\begin_layout Scrap
% the piecewise linear element, plus the "bubble" function
\end_layout

\begin_layout Scrap
% 
\backslash
phi_4(x,y) = 27xy(1-x-y).
 
\end_layout

\begin_layout Scrap
nvars = [1;1;1;1]
\end_layout

\begin_layout Scrap
flist = [1 0 0
\end_layout

\begin_layout Scrap
         2 0 0
\end_layout

\begin_layout Scrap
         3 0 0
\end_layout

\begin_layout Scrap
         1 2 3];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@abfs2d_Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
    'pxfeature',@abfs2d_pxfeature,'vnodes',abfs2d_vnodes(), ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',@trans2d_Aphilist);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that the first three basis functions are associated with the vertices
 of the triangle; these are linear basis functions.
 The fourth is the 
\begin_inset Quotes eld
\end_inset

bubble
\begin_inset Quotes erd
\end_inset

 function, which is associated with the interior of the triangle.
 The basis functions are given below:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
abfs2d_Aphihat()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<abf2d-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphilist = abfs2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
% Aphilist = abfs2d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% ABF scalar element: linear basis functions plus "bubble" function
\end_layout

\begin_layout Scrap
% 
\backslash
lambda_1
\backslash
lambda_2
\backslash
lambda_3 in barycentric coordinates.
\end_layout

\begin_layout Scrap
x = xhat(1);  y = xhat(2);
\end_layout

\begin_layout Scrap
% Basis function values
\end_layout

\begin_layout Scrap
Aphilist0 = [1-x-y; 
\end_layout

\begin_layout Scrap
             x; 
\end_layout

\begin_layout Scrap
             y
\end_layout

\begin_layout Scrap
             27*x*y*(1-x-y)];
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    % Basis gradient values (along rows)
\end_layout

\begin_layout Scrap
    Aphilist1 = [-1 -1;
\end_layout

\begin_layout Scrap
                  1  0;
\end_layout

\begin_layout Scrap
                  0  1;
\end_layout

\begin_layout Scrap
                 27*y*(1-y-2*x), 27*x*(1-x-2*y)];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % Basis hessian values (along rows: dx1^2, dx1.dx2, dx2^2)
\end_layout

\begin_layout Scrap
    Aphilist2 = [0 0 0;
\end_layout

\begin_layout Scrap
                 0 0 0;
\end_layout

\begin_layout Scrap
                 0 0 0;
\end_layout

\begin_layout Scrap
                 -54*y, 27 - 54*y - 54*x, -54*x];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order == 0
\end_layout

\begin_layout Scrap
    Aphilist = Aphilist0;
\end_layout

\begin_layout Scrap
elseif order == 1
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1];
\end_layout

\begin_layout Scrap
elseif order == 2
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1,Aphilist2];
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Permutations of the geometric features do not change the ordering (or signs)
 of the variables.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
abfs2d_pxfeature()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<abf2d-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_vars,signs] = abfs2d_pxfeature(px)
\end_layout

\begin_layout Scrap
% function [px_vars,signs] = abfs2d_pxfeature(px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the permutation of the variables (px_vars),
\end_layout

\begin_layout Scrap
% and the sign changes (signs) resulting from a permutation (px)
\end_layout

\begin_layout Scrap
% applied to a feature of the appropriate dimension (== length(px)).
\end_layout

\begin_layout Scrap
% This is for the linear (or affine) 2-D triangle elements.
\end_layout

\begin_layout Scrap
dimp1 = sum(px ~= 0);  % dimp1 == dimension plus 1
\end_layout

\begin_layout Scrap
switch dimp1
\end_layout

\begin_layout Scrap
    case 1 % points
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    case 3 % triangles
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    otherwise % not a valid feature
\end_layout

\begin_layout Scrap
        px_vars = []; signs = [];
\end_layout

\begin_layout Scrap
end % switch
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The basis is a nodal basis with nodes at the vertices and the centroid of
 the triangle, except that 
\begin_inset Formula $\phi_{i}$
\end_inset

 are not zero at the centroid for 
\begin_inset Formula $i=1,\,2,\,3$
\end_inset

.
\end_layout

\begin_layout Scrap
<<abf2d-elt.m>>=
\end_layout

\begin_layout Scrap
function vnodes = abfs2d_vnodes()
\end_layout

\begin_layout Scrap
% function vnodes = abfs2d_vnodes()
\end_layout

\begin_layout Scrap
% 
\end_layout

\begin_layout Scrap
% Returns the positions of the variable nodes
\end_layout

\begin_layout Scrap
% with respect to the reference element.
\end_layout

\begin_layout Scrap
% Same format as p (2 x m)
\end_layout

\begin_layout Scrap
vnodes = [0   0;
\end_layout

\begin_layout Scrap
          1   0;
\end_layout

\begin_layout Scrap
          0   1;
\end_layout

\begin_layout Scrap
          1/3 1/3];
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
We need to compute the integrals 
\begin_inset Formula $\int_{\Omega}q\,\nabla\cdot\mathbf{u}\, d\mathbf{x}$
\end_inset

 for 
\begin_inset Formula $q$
\end_inset

 piecewise linear and 
\begin_inset Formula $\mathbf{u}$
\end_inset

 formed using the ABF vector element, which can be achieved using the following
 PDE data structure:
\end_layout

\begin_layout LyX-Code
qdiv_form = struct('coeffs',@(x)[0,0,1,0,0,1;zeros(2,6)], ...
\end_layout

\begin_layout LyX-Code
    'rhs',@(x)zeros(6,1), 'order',1);
\end_layout

\begin_layout Subsection
Hsieh--Clough--Tocher 
\begin_inset Formula $C^{1}$
\end_inset

 element
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Hsieh--Clough--Tocher (HCT) element
\end_layout

\end_inset

This is a 
\begin_inset Formula $C^{1}$
\end_inset

 
\begin_inset Quotes eld
\end_inset

macro
\begin_inset Quotes erd
\end_inset

 element with piecewise cubic basis functions; these basis functions are
 cubic on subtriangles.
 This element involves normal derivatives at the midpoints of the edges.
 Affine transformations do not preserve normal derivatives, so there is
 an additional complication in the computation of the transformation of
 the basis functions so that the nodal basis property is preserved in the
 basis functions on the real elements.
\end_layout

\begin_layout Standard
The element is illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Hsieh--Clough--Tocher-elem"

\end_inset

.
 At each vertex, there are three variables: one for the value at the point,
 and two for the two partial derivatives (
\begin_inset Formula $\partial\phi/\partial x_{1}$
\end_inset

, 
\begin_inset Formula $\partial\phi/\partial x_{2}$
\end_inset

).
 Also, at the midpoint of each edge there is the normal derivative.
 This gives a total of 12 nodal basis functions for this element.
 Integration over these elements should be done using a composite integration
 method: the basis functions are cubic over the sub-triangles formed by
 an edge and the centroid (
\begin_inset Formula $\mathbf{x}_{c}=(\mathbf{x}_{1}+\mathbf{x}_{2}+\mathbf{x}_{3})/3$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename hct-elt.eps
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Hsieh--Clough--Tocher-elem"

\end_inset

Hsieh--Clough--Tocher (HCT) element
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
hct2d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<hct2d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = hct2d_elt()
\end_layout

\begin_layout Scrap
% function elt = hct2d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Hsieh-Clough-Tocher element in two dimensions.
\end_layout

\begin_layout Scrap
nvars = [3;3;3;1;1;1];
\end_layout

\begin_layout Scrap
flist = [1 0 0;  1 0 0;  1 0 0;
\end_layout

\begin_layout Scrap
         2 0 0;  2 0 0;  2 0 0;
\end_layout

\begin_layout Scrap
         3 0 0;  3 0 0;  3 0 0;
\end_layout

\begin_layout Scrap
         1 2 0;
\end_layout

\begin_layout Scrap
         1 3 0;
\end_layout

\begin_layout Scrap
         2 3 0];
\end_layout

\begin_layout Scrap
vnodes = [0 0;  0 0;  0 0;
\end_layout

\begin_layout Scrap
          1 0;  1 0;  1 0;
\end_layout

\begin_layout Scrap
          0 1;  0 1;  0 1;
\end_layout

\begin_layout Scrap
          1/2 0; 0 1/2; 1/2 1/2];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@hct2d_Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
    'pxfeature',@hct2d_pxfeature,'vnodes',vnodes, ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',@hct2d_trans_Aphilist);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
There are twelve basis functions for one HCT element, but the formula used
 depends on which part of the reference triangle needs to be evaluated.
\end_layout

\begin_layout Scrap
<<hct2d-elt.m>>=
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Three-dimensional elements
\end_layout

\begin_layout Subsubsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
element!piecewise linear (3D)
\end_layout

\end_inset

Piecewise linear three-dimensional elements
\end_layout

\begin_layout Standard
This is the simplest useful three-dimensional element.
 Assembly routines for three-dimensional problems need to be written.
 (See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Matrix-assembly-code"

\end_inset

.) See Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piecewise-linear-elements"

\end_inset

 for the two-dimensional piecewise linear element.
 
\end_layout

\begin_layout Standard
Note that the order of the operators for scalar three-dimensional elements
 is 
\begin_inset Formula $\mathcal{A}=I$
\end_inset

 (identity), 
\begin_inset Formula $\partial/\partial x_{1}$
\end_inset

, 
\begin_inset Formula $\partial/\partial x_{2}$
\end_inset

, 
\begin_inset Formula $\partial/\partial x_{3}$
\end_inset

, 
\begin_inset Formula $\partial^{2}/\partial x_{1}^{2}$
\end_inset

, 
\begin_inset Formula $\partial^{2}/\partial x_{1}\partial x_{2}$
\end_inset

, 
\begin_inset Formula $\partial^{2}/\partial x_{1}\partial x_{3}$
\end_inset

, 
\begin_inset Formula $\partial^{2}/\partial x_{2}^{2}$
\end_inset

, 
\begin_inset Formula $\partial^{2}/\partial x_{2}\partial x_{3}$
\end_inset

, 
\begin_inset Formula $\partial^{2}/\partial x_{3}^{2}$
\end_inset

.
 We often use the notation 
\begin_inset Formula $x=x_{1}$
\end_inset

, 
\begin_inset Formula $y=x_{2}$
\end_inset

 and 
\begin_inset Formula $z=x_{3}$
\end_inset

 for convenience.
\end_layout

\begin_layout Standard
Note that all basis functions are associated with vertices of the tetrahedron.
 We also need a new transformation routines for transforming from the reference
 element in three dimensions (which is the tetrahedron with the vertices
 
\begin_inset Formula $(0,0,0)$
\end_inset

, 
\begin_inset Formula $(1,0,0)$
\end_inset

, 
\begin_inset Formula $(0,1,0)$
\end_inset

, and 
\begin_inset Formula $(0,0,1)$
\end_inset

) to the actual element (with vertices 
\begin_inset Formula $\mathbf{p}_{1}$
\end_inset

, 
\begin_inset Formula $\mathbf{p}_{2}$
\end_inset

, 
\begin_inset Formula $\mathbf{p}_{3}$
\end_inset

 and 
\begin_inset Formula $\mathbf{p}_{4}$
\end_inset

).
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
lin3d_elt()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
lin3d-elt.m 
\backslash

\end_layout

\begin_layout Scrap
<<lin3d-elt.m>>=
\end_layout

\begin_layout Scrap
function elt = lin3d_elt()
\end_layout

\begin_layout Scrap
% function elt = lin3d_elt()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the linear 3-D (4-point) element data structure.
\end_layout

\begin_layout Scrap
nvars = [1;1;1;1];
\end_layout

\begin_layout Scrap
flist = [1 0 0 0;
\end_layout

\begin_layout Scrap
         2 0 0 0;
\end_layout

\begin_layout Scrap
         3 0 0 0;
\end_layout

\begin_layout Scrap
         4 0 0 0];
\end_layout

\begin_layout Scrap
vnodes = [0 0 0;
\end_layout

\begin_layout Scrap
          1 0 0;
\end_layout

\begin_layout Scrap
          0 1 0;
\end_layout

\begin_layout Scrap
          0 0 1];
\end_layout

\begin_layout Scrap
elt = struct('Aphihat',@lin3d_Aphihat, ...
\end_layout

\begin_layout Scrap
    'nvars',nvars,'flist',flist, ...
\end_layout

\begin_layout Scrap
    'pxfeature',@lin3d_pxfeature,'vnodes',vnodes, ...
\end_layout

\begin_layout Scrap
    'trans_Aphihat',@trans3d_Aphilist);
\end_layout

\begin_layout Scrap
end
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The basis functions are easily computed.
 Note that the first derivatives are constant, and the second derivatives
 are all zero.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
lin3d_Aphihat()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<lin3d-elt.m>>=
\end_layout

\begin_layout Scrap
function Aphilist = lin3d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
% Aphilist = lin3d_Aphihat(xhat,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns array of basis function values, their gradient and Hessian entries
\end_layout

\begin_layout Scrap
x = xhat(1);  y = xhat(2);  z = xhat(3);
\end_layout

\begin_layout Scrap
% Basis function values
\end_layout

\begin_layout Scrap
Aphilist0 = [1-x-y-z; 
\end_layout

\begin_layout Scrap
             x; 
\end_layout

\begin_layout Scrap
             y;
\end_layout

\begin_layout Scrap
             z];
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    % Basis gradient values (along rows)
\end_layout

\begin_layout Scrap
    Aphilist1 = [-1 -1 -1;
\end_layout

\begin_layout Scrap
                  1  0  0;
\end_layout

\begin_layout Scrap
                  0  1  0;
\end_layout

\begin_layout Scrap
                  0  0  1];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % Basis Hessian values (along rows: dx1^2, dx1.dx2, dx1.dx3, dx2^2, dx2.dx3,
 dx3^2)
\end_layout

\begin_layout Scrap
    Aphilist2 = [0 0 0 0 0 0;
\end_layout

\begin_layout Scrap
                 0 0 0 0 0 0;
\end_layout

\begin_layout Scrap
                 0 0 0 0 0 0];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
if order == 0
\end_layout

\begin_layout Scrap
    Aphilist = Aphilist0;
\end_layout

\begin_layout Scrap
elseif order == 1
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1];
\end_layout

\begin_layout Scrap
elseif order == 2
\end_layout

\begin_layout Scrap
    Aphilist = [Aphilist0,Aphilist1,Aphilist2];
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Permutation of the geometric features does not change the order of the variables
 since there is only one variable for each vertex, just as for the two-dimension
al piecewise linear element.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
lin3d_pxfeature()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<lin3d-elt.m>>=
\end_layout

\begin_layout Scrap
function [px_vars,signs] = lin3d_pxfeature(px)
\end_layout

\begin_layout Scrap
% function [px_vars,signs] = lin3d_pxfeature(px)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the permutation of the variables (px_vars),
\end_layout

\begin_layout Scrap
% and the sign changes (signs) resulting from a permutation (px)
\end_layout

\begin_layout Scrap
% applied to a feature of the appropriate dimension (== length(px)).
\end_layout

\begin_layout Scrap
% This is for the linear (or affine) 3-D tetrahedral elements.
\end_layout

\begin_layout Scrap
dimp1 = sum(px ~= 0);  % dimp1 == dimension plus 1
\end_layout

\begin_layout Scrap
switch dimp1
\end_layout

\begin_layout Scrap
    case 1 % points
\end_layout

\begin_layout Scrap
        px_vars = [1]; signs = [1];
\end_layout

\begin_layout Scrap
    otherwise % not a valid feature
\end_layout

\begin_layout Scrap
        px_vars = []; signs = [];
\end_layout

\begin_layout Scrap
end % switch
\end_layout

\begin_layout Scrap
end % function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Three-dimensional scalar transformations
\end_layout

\begin_layout Standard
The affine transformation in three dimensions 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\mathbf{x}=T\widehat{\mathbf{x}}+\mathbf{b}$
\end_inset

 must modify the derivative values.
 For derivation of the basic equations, see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transformation-scalar-Lagrange-elements"

\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
trans3d_Aphilist()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
trans3d-Aphilist.m 
\backslash

\end_layout

\begin_layout Scrap
<<trans3d-Aphilist.m>>=
\end_layout

\begin_layout Scrap
function Aphilist2 = trans3d_Aphilist(T,Aphilist,order)
\end_layout

\begin_layout Scrap
% function Aphilist2 = trans3d_Aphilist(T,Aphilist,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Transforms Aphilist into Aphilist2 according to matrix T (3 x 3)
\end_layout

\begin_layout Scrap
% Note: Order of colums is [val, d/dx1, d/dx2, d/dx3, d^2/dx1^2, d^2/dx1.dx2,
 d^2/dx1.dx3, d^2/dx2^2, d^2/dx2.dx3, d^2/dx3^2]
\end_layout

\begin_layout Scrap
Aphilist2 = zeros(size(Aphilist));
\end_layout

\begin_layout Scrap
Aphilist2(:,1) = Aphilist(:,1); % values unchanged
\end_layout

\begin_layout Scrap
if order >= 1
\end_layout

\begin_layout Scrap
    S = inv(T);
\end_layout

\begin_layout Scrap
    Aphilist2(:,2:4) = Aphilist(:,2:4)*S; % chain rule for 1st derivatives
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
if order >= 2
\end_layout

\begin_layout Scrap
    % chain rule for 2nd derivatives (affine transformation)
\end_layout

\begin_layout Scrap
    Aphilist2(:,5)  = Aphilist(:,5)*(S(1,1)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(2*S(2,1)*S(1,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,7)*(2*S(3,1)*S(1,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,8)*(S(2,1)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,9)*(2*S(3,1)*S(2,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,10)*(S(3,1)^2);
\end_layout

\begin_layout Scrap
    Aphilist2(:,6)  = Aphilist(:,5)*(S(1,1)*S(1,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(S(1,1)*S(2,2)+S(1,2)*S(2,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,7)*(S(3,1)*S(1,2)+S(1,1)*S(3,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,8)*(S(2,2)*S(2,1))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,9)*(S(3,1)*S(2,2)+S(2,1)*S(3,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,10)*(S(3,1)*S(3,2));
\end_layout

\begin_layout Scrap
    Aphilist2(:,7)  = Aphilist(:,5)*(S(1,1)*S(1,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(S(2,1)*S(1,3)+S(1,1)*S(2,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,7)*(S(3,1)*S(1,3)+S(1,1)*S(3,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,8)*(S(2,1)*S(2,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,9)*(S(3,1)*S(2,3)+S(2,1)*S(3,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,10)*(S(3,1)*S(3,3));
\end_layout

\begin_layout Scrap
    Aphilist2(:,8)  = Aphilist(:,5)*(S(1,2)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(2*S(2,2)*S(1,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,7)*(2*S(3,2)*S(1,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,8)*(S(2,2)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,9)*(2*S(3,2)*S(2,2))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,10)*(S(3,2)^2);
\end_layout

\begin_layout Scrap
    Aphilist2(:,9)  = Aphilist(:,5)*(S(1,2)*S(1,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(S(2,2)*S(1,3)+S(1,2)*S(2,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,7)*(S(3,2)*S(1,3)+S(1,2)*S(3,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,8)*(S(2,2)*S(2,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,9)*(S(3,2)*S(2,3)+S(2,2)*S(3,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,10)*(S(3,2)*S(3,3));
\end_layout

\begin_layout Scrap
    Aphilist2(:,10) = Aphilist(:,5)*(S(1,3)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,6)*(2*S(2,3)*S(1,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,7)*(2*S(3,3)*S(1,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,8)*(S(2,3)^2)+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,9)*(2*S(3,3)*S(2,3))+ ...
\end_layout

\begin_layout Scrap
           Aphilist(:,10)*(S(3,3)^2);
\end_layout

\begin_layout Scrap
end % if
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Numerical-integration"

\end_inset

Numerical integration
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Numerical integration is basic to the assembly process.
 The numerical integration routine should be exact for products of the basis
 functions that are used.
 Since the assembly routines perform the transformation from reference elements,
 these routines just need to return the points and weights for the method
 on a reference element, which is the triangle with vertices 
\begin_inset Formula $(0,0)$
\end_inset

, 
\begin_inset Formula $(1,0)$
\end_inset

, and 
\begin_inset Formula $(0,1)$
\end_inset

.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Two-dimensional-integration"

\end_inset

Two-dimensional integration methods
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Centroid-method"

\end_inset

Centroid method
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!centroid method
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a one-point method with order 1.
 (That is, it is exact for all polynomials of order 
\begin_inset Formula $\leq1$
\end_inset

.)
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
int2d_centroid1()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int2d-centroid1.m 
\backslash

\end_layout

\begin_layout Scrap
<<int2d-centroid1.m>>=
\end_layout

\begin_layout Scrap
function [p,w] = int2d_centroid1()
\end_layout

\begin_layout Scrap
% function [p,w] = int2d_centroid1()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% This is the simplest triangle integration method.
\end_layout

\begin_layout Scrap
p = [1/3, 1/3];
\end_layout

\begin_layout Scrap
w = 1/2;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Radon-method"

\end_inset

Radon's method
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!Radon's method
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a 7-point method with order 5 
\begin_inset CommandInset citation
LatexCommand cite
key "rad:zmk"

\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
int2d_radon7()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int2d-radon7.m 
\backslash

\end_layout

\begin_layout Scrap
<<int2d-radon7.m>>=
\end_layout

\begin_layout Scrap
function [p,w] = int2d_radon7()
\end_layout

\begin_layout Scrap
% function [p,w] = int2d_radon7()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the points (p) and weights (w) of J.
 Radon's 7-point
\end_layout

\begin_layout Scrap
% integration formula for the triangle with vertices (0,0), (1,0), (0,1).
\end_layout

\begin_layout Scrap
% This formula is exact for polynomials up to degree 5.
\end_layout

\begin_layout Scrap
% Points are the rows of p.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Reference: J.
 Radon, Zur mechanischen Kubatur.
 (German)
\end_layout

\begin_layout Scrap
% Monatsh.
 Math.
 52, (1948), pp.
 286-300.
\end_layout

\begin_layout Scrap
p = [1/3,              1/3;
\end_layout

\begin_layout Scrap
    (6+sqrt(15))/21,   (9-2*sqrt(15))/21;
\end_layout

\begin_layout Scrap
    (9-2*sqrt(15))/21, (6+sqrt(15))/21;
\end_layout

\begin_layout Scrap
    (6+sqrt(15))/21,   (6+sqrt(15))/21;
\end_layout

\begin_layout Scrap
    (6-sqrt(15))/21,   (9+2*sqrt(15))/21;
\end_layout

\begin_layout Scrap
    (9+2*sqrt(15))/21, (6-sqrt(15))/21;
\end_layout

\begin_layout Scrap
    (6-sqrt(15))/21,   (6-sqrt(15))/21];
\end_layout

\begin_layout Scrap
w = [9/80;
\end_layout

\begin_layout Scrap
    (155+sqrt(15))/2400;
\end_layout

\begin_layout Scrap
    (155+sqrt(15))/2400;
\end_layout

\begin_layout Scrap
    (155+sqrt(15))/2400;
\end_layout

\begin_layout Scrap
    (155-sqrt(15))/2400;
\end_layout

\begin_layout Scrap
    (155-sqrt(15))/2400;
\end_layout

\begin_layout Scrap
    (155-sqrt(15))/2400];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Gatermann-method"

\end_inset

Gatermann's method
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!Gatermann's method
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a 12-point method with order 7 
\begin_inset CommandInset citation
LatexCommand cite
key "gat:cscfst"

\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
int2d_gatermann12()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int2d-gatermann12.m 
\backslash

\end_layout

\begin_layout Scrap
<<int2d-gatermann12.m>>=
\end_layout

\begin_layout Scrap
function [p,w] = int2d_gatermann12()
\end_layout

\begin_layout Scrap
% function [p,w] = int2d_gatermann12()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the points (p) and weights (w) of K.
 Gatermann's 12-point
\end_layout

\begin_layout Scrap
% integration formula for the triangle with vertices (0,0), (1,0), (0,1).
\end_layout

\begin_layout Scrap
% This formula is exact for polynomials up to degree 7.
\end_layout

\begin_layout Scrap
% Points are the rows of p.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Reference: The Construction of Symmetric Cubature Formulas
\end_layout

\begin_layout Scrap
% for the Square and the Triangle, Computing 40, 229 - 240 (1988)
\end_layout

\begin_layout Scrap
p = [0.06751786707392436, 0.8700998678316848;  % 1
\end_layout

\begin_layout Scrap
     0.06238226509439084, 0.06751786707392436; % 2
\end_layout

\begin_layout Scrap
     0.8700998678316848,  0.06238226509439084; % 3
\end_layout

\begin_layout Scrap
     0.3215024938520156,  0.6232720494910644;  % 4
\end_layout

\begin_layout Scrap
     0.05522545665692000, 0.3215024938520156;  % 5
\end_layout

\begin_layout Scrap
     0.6232720494910644,  0.05522545665692000; % 6
\end_layout

\begin_layout Scrap
     0.6609491961867980,  0.3047265008681072;  % 7
\end_layout

\begin_layout Scrap
     0.03432430294509488, 0.6609491961867980;  % 8
\end_layout

\begin_layout Scrap
     0.3047265008681072,  0.03432430294509488; % 9
\end_layout

\begin_layout Scrap
     0.2777161669764050,  0.2064414986699949;  % 10
\end_layout

\begin_layout Scrap
     0.5158423343536001,  0.2777161669764050;  % 11
\end_layout

\begin_layout Scrap
     0.2064414986699949,  0.5158423343536001]; % 12
\end_layout

\begin_layout Scrap
w = [0.02651702815743450;
\end_layout

\begin_layout Scrap
     0.02651702815743450;
\end_layout

\begin_layout Scrap
     0.02651702815743450;
\end_layout

\begin_layout Scrap
     0.04388140871444811;
\end_layout

\begin_layout Scrap
     0.04388140871444811;
\end_layout

\begin_layout Scrap
     0.04388140871444811;
\end_layout

\begin_layout Scrap
     0.02877504278497528;
\end_layout

\begin_layout Scrap
     0.02877504278497528;
\end_layout

\begin_layout Scrap
     0.02877504278497528;
\end_layout

\begin_layout Scrap
     0.06749318700980879;
\end_layout

\begin_layout Scrap
     0.06749318700980879;
\end_layout

\begin_layout Scrap
     0.06749318700980879];
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:integration-Dunavant"

\end_inset

A method of Dunavant
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!Dunavant method
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a 33-point method with order 12 
\begin_inset CommandInset citation
LatexCommand cite
key "dun:hdesgqrt"

\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
int2d_dunavant33()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int2d-dunavant33.m 
\backslash

\end_layout

\begin_layout Scrap
<<int2d-dunavant33.m>>=
\end_layout

\begin_layout Scrap
function [p,w] = int2d_dunavant33()
\end_layout

\begin_layout Scrap
% function [p,w] = int2d_dunavant33()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns points and weights for Dunavant (1978)'s 
\end_layout

\begin_layout Scrap
% 12th order 33 point triangle integration method.
\end_layout

\begin_layout Scrap
% Values taken directly from Dunavant's paper:
\end_layout

\begin_layout Scrap
% "High degree efficient symmetrical Gaussian quadrature rules for the
\end_layout

\begin_layout Scrap
% triangle", Internat.
 J.
 Numer.
 Methods Eng.
 vol 21, pp.
 1129-1148 (1985)
\end_layout

\begin_layout Scrap
% p=12 ng=33 nsige17.8 ssqa9.d-58 error= 1.d-27 ifn= 2439 infers1 time= 74
\end_layout

\begin_layout Scrap
% weight alpha beta gamma
\end_layout

\begin_layout Scrap
% 0.025731066440455 0.023565220452390 0.488217389773805 0.488217389773805
\end_layout

\begin_layout Scrap
% 0.043692544538038 0.120551215411079 0.439724392294460 0.439724392294460
\end_layout

\begin_layout Scrap
% 0.062858224217885 0.457579229975768 0.271210385012116 0.271210385012116
\end_layout

\begin_layout Scrap
% 0.034796112930709 0.744847708916828 0.127576145541586 0.127576145541586
\end_layout

\begin_layout Scrap
% 0.006166261051559 0.957365299093579 0.021317350453210 0.021317350453210
\end_layout

\begin_layout Scrap
% 0.040371557766381 0.115343494534698 0.275713269685514 0.608943235779788
\end_layout

\begin_layout Scrap
% 0.022356773202303 0.022838332222257 0.281325580989940 0.695836086787803
\end_layout

\begin_layout Scrap
% 0.017316231108659 0.025734050548330 0.116251915907597 0.858014033544073
\end_layout

\begin_layout Scrap
table = [...
\end_layout

\begin_layout Scrap
0.025731066440455 0.023565220452390 0.488217389773805 0.488217389773805
\end_layout

\begin_layout Scrap
0.043692544538038 0.120551215411079 0.439724392294460 0.439724392294460
\end_layout

\begin_layout Scrap
0.062858224217885 0.457579229975768 0.271210385012116 0.271210385012116
\end_layout

\begin_layout Scrap
0.034796112930709 0.744847708916828 0.127576145541586 0.127576145541586
\end_layout

\begin_layout Scrap
0.006166261051559 0.957365299093579 0.021317350453210 0.021317350453210
\end_layout

\begin_layout Scrap
0.040371557766381 0.115343494534698 0.275713269685514 0.608943235779788
\end_layout

\begin_layout Scrap
0.022356773202303 0.022838332222257 0.281325580989940 0.695836086787803
\end_layout

\begin_layout Scrap
0.017316231108659 0.025734050548330 0.116251915907597 0.858014033544073];
\end_layout

\begin_layout Scrap
idx = 1; t_idx = 1;
\end_layout

\begin_layout Scrap
p = zeros(33,2); w = zeros(32,1);
\end_layout

\begin_layout Scrap
for t_idx = 1:size(table,1)
\end_layout

\begin_layout Scrap
    if table(t_idx,3) == table(t_idx,4)
\end_layout

\begin_layout Scrap
        % 3 entries
\end_layout

\begin_layout Scrap
        w(idx:(idx+2)) = table(t_idx,1);
\end_layout

\begin_layout Scrap
        p(idx+0,:) = table(t_idx,[2,3]);
\end_layout

\begin_layout Scrap
        p(idx+1,:) = table(t_idx,[3,2]);
\end_layout

\begin_layout Scrap
        p(idx+2,:) = table(t_idx,[3,4]);
\end_layout

\begin_layout Scrap
        idx = idx+3;
\end_layout

\begin_layout Scrap
    else
\end_layout

\begin_layout Scrap
        % 6 entries
\end_layout

\begin_layout Scrap
        w(idx:(idx+5)) = table(t_idx,1);
\end_layout

\begin_layout Scrap
        p(idx+0,:) = table(t_idx,[2,3]);
\end_layout

\begin_layout Scrap
        p(idx+1,:) = table(t_idx,[2,4]);
\end_layout

\begin_layout Scrap
        p(idx+2,:) = table(t_idx,[3,2]);
\end_layout

\begin_layout Scrap
        p(idx+3,:) = table(t_idx,[3,4]);
\end_layout

\begin_layout Scrap
        p(idx+4,:) = table(t_idx,[4,2]);
\end_layout

\begin_layout Scrap
        p(idx+5,:) = table(t_idx,[4,3]);
\end_layout

\begin_layout Scrap
        idx = idx+6;
\end_layout

\begin_layout Scrap
    end % if
\end_layout

\begin_layout Scrap
end % for
\end_layout

\begin_layout Scrap
w = w/2;
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:One-dimensional-integration"

\end_inset

One-dimensional integration methods
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Gauss--Legendre-quadrature"

\end_inset

Gauss--Legendre quadrature
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!Gauss--Legendre quadrature
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we use the 5-point Gauss--Legendre quadrature method which is a 9th
 order method 
\begin_inset CommandInset citation
LatexCommand cite
key "atk:ina"

\end_inset

.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
int1d_gauss5()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int1d-gauss5.m 
\backslash

\end_layout

\begin_layout Scrap
<<int1d-gauss5.m>>=
\end_layout

\begin_layout Scrap
function [p,w] = int1d_gauss5()
\end_layout

\begin_layout Scrap
% function [p,w] = int1d_gauss5()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns points and weights for a 5-point Gauss rule
\end_layout

\begin_layout Scrap
% in 1-D for the interval [0,1]
\end_layout

\begin_layout Scrap
p = [1/2; (1+sqrt(5-2*sqrt(10/7))/3)/2; (1-sqrt(5-2*sqrt(10/7))/3)/2; ...
\end_layout

\begin_layout Scrap
     (1+sqrt(5+2*sqrt(10/7))/3)/2; (1-sqrt(5+2*sqrt(10/7))/3)/2];
\end_layout

\begin_layout Scrap
w = 0.5*[128/225; (322+13*sqrt(70))/900; (322+13*sqrt(70))/900; ...
\end_layout

\begin_layout Scrap
     (322-13*sqrt(70))/900; (322-13*sqrt(70))/900];
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Three-dimensional-integration"

\end_inset

Three-dimensional integration
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!three-dimensional
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!centroid method
\end_layout

\end_inset

Centroid method
\end_layout

\begin_layout Standard
This integration method is exact for 1st order polynomials (affine functions),
 and uses one point.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
int3d_centroid1()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int3d-centroid1.m 
\backslash

\end_layout

\begin_layout Scrap
<<int3d-centroid1.m>>=
\end_layout

\begin_layout Scrap
function [p,w] = int3d_centroid1()
\end_layout

\begin_layout Scrap
% function [p,w] = int3d_centroid1()
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% This is the simplest triangle integration method.
\end_layout

\begin_layout Scrap
p = [1/4, 1/4, 1/4];
\end_layout

\begin_layout Scrap
w = 1/6;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Composite-integration-rules"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
integration!composite
\end_layout

\end_inset

Composite integration rules
\end_layout

\begin_layout Standard
Composite integration rules allow the same integration rule to be replicated
 across a collection of sub-triangles.
 These are particularly useful for 
\begin_inset Quotes eld
\end_inset

macro
\begin_inset Quotes erd
\end_inset

 elements, that are formed by piecewise polynomial functions on sub-triangles
 of the reference triangle, such as the HCT element
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Hsieh--Clough--Tocher (HCT) element
\end_layout

\end_inset

.
 In the same way, we can create composite rules that replicate a pre-existing
 two-dimensional rule (
\family typewriter
intmethod
\family default
) across a triangulation (
\family typewriter
pr
\family default
,
\family typewriter
tr
\family default
) of the reference element.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
int2d-comp.m 
\backslash

\end_layout

\begin_layout Scrap
<<int2d-comp.m>>=
\end_layout

\begin_layout Scrap
function compmethod = int2d_comp(pr,tr,intmethod)
\end_layout

\begin_layout Scrap
% function compmethod = int2d_comp(pr,tr,intmethod)
\end_layout

\begin_layout Scrap
% 
\end_layout

\begin_layout Scrap
% Returns function handle for composite integration
\end_layout

\begin_layout Scrap
% method that uses intmethod() as the basic method.
\end_layout

\begin_layout Scrap
% replicated across all triangles of the triangulation
\end_layout

\begin_layout Scrap
% (pr,tr) of the reference element.
\end_layout

\begin_layout Scrap
compmethod = @int2d_comp_func(pr,tr,intmethod);
\end_layout

\begin_layout Scrap
end function
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
function [p_int,w_int] = int2d_comp_function(pr,tr,intmethod)
\end_layout

\begin_layout Scrap
% function [p_int,w_int] = int2d_comp_function(pr,tr,intmethod)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Internal function for int2d_comp().
\end_layout

\begin_layout Scrap
% This is where the work gets done.
\end_layout

\begin_layout Scrap
[p_base,w_base] = intmethod(); % base method points & weights
\end_layout

\begin_layout Scrap
base_len = size(p_base,1);
\end_layout

\begin_layout Scrap
p_int = zeros(size(tr,1)*base_len,2);
\end_layout

\begin_layout Scrap
w_int = zeros(size(tr,1)*base_len,1);
\end_layout

\begin_layout Scrap
for j = 1:size(tr,1)
\end_layout

\begin_layout Scrap
    % For sub-triangle j...
\end_layout

\begin_layout Scrap
    % Create affine transformation
\end_layout

\begin_layout Scrap
    i1 = tr(i,1);  i2 = tr(i,2);  i3 = tr(i,3);
\end_layout

\begin_layout Scrap
    T = [pr(i2,:)'-pr(i1,:)', pr(i3,:)'-pr(i1,:)'];
\end_layout

\begin_layout Scrap
    b0 = pr(i1,:)';
\end_layout

\begin_layout Scrap
    % transform weights and points and add to list
\end_layout

\begin_layout Scrap
    detT = abs(det(T));
\end_layout

\begin_layout Scrap
    p_int(((j-1)*base_len+1):(j*base_len),:) = p_base*T'+b0';
\end_layout

\begin_layout Scrap
    w_int(((j-1)*base_len+1):(j*base_len))   = w_int*detT;
\end_layout

\begin_layout Scrap
end % for
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
For the HCT element
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Hsieh--Clough--Tocher (HCT) element
\end_layout

\end_inset

, the appropriate integration method can be created using something like:
\end_layout

\begin_layout Scrap
<<HCT integrator>>=
\end_layout

\begin_layout Scrap
pr = [0,0; 1,0; 0,1; 1/3,1/3];
\end_layout

\begin_layout Scrap
tr = [1 2 4; 1 3 4; 2 3 4];
\end_layout

\begin_layout Scrap
int2d_hct = int2d_comp(pr,tr,@int2d_radon7);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
Adaptation
\end_layout

\begin_layout Standard
Adaptation of the mesh is a very useful technique to improve accuracy at
 minimal cost.
 There are two parts to this: one is to use 
\emph on
a posteriori
\emph default
 error estimation to identify triangles that should be refined; the other
 is to solve the refined system of equations.
 Simple adaptation techniques result in non-conforming triangulations.
 This is illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:mesh-adaptation"

\end_inset

, which shows hanging nodes from the refined triangles that do not match
 nodes in the unrefined triangles on the upper-left.
\end_layout

\begin_layout Standard
The fact that we have a non-conforming mesh means that we cannot use the
 output of assembly routines 
\begin_inset Quotes eld
\end_inset

as is
\begin_inset Quotes erd
\end_inset

.
 The variables associated with the non-conforming part of the mesh need
 to be represented in terms of variables in the unrefined triangles.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename adaptation-mesh.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:mesh-adaptation"

\end_inset

Adaptation of mesh showing hanging nodes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The approach we take to mesh refinement starts with the refinement for the
 reference element; we take this to be the 
\emph on
reference refinement
\emph default
.
 This reference refinement is a triangulation of the reference element.
 The basic assumption is that the basis functions on the reference element
 
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

 can be represented as linear combinations of the basis functions of the
 reference refinement.
 This is clearly the case for piecewise polynomial Lagrange elements, since
 on each triangle all polynomials up to a specified degree can be represented.
 This is not so for Bell's triangle, since in that element, the basis functions
 are 5th order polynomials where the normal derivatives on the boundaries
 are cubic.
 Thus for a non-trivial refinement of the reference element, the edges of
 the triangles in the interior of the reference element will not typically
 have cubic normal derivatives.
 
\end_layout

\begin_layout Standard
The basic idea in this code is to represent variables in the refined triangles
 in terms of the variables in the unrefined triangles where they meet.
 Thus we only need to consider the variables associated with the edges common
 to both refined and unrefined triangle.
 We assume that every basis function on the reference element is a linear
 combination of basis functions for the reference refinement:
\begin_inset Formula 
\[
\widehat{\phi}_{i}=\sum_{j}b_{ij}\,\widetilde{\phi}_{j},
\]

\end_inset

where 
\begin_inset Formula $\widetilde{\phi}_{j}$
\end_inset

 are the basis functions on the reference refinement.
\end_layout

\begin_layout Standard
Assuming that the corresponding basis function on the real element is 
\begin_inset Formula $\phi_{k}(\mathbf{x})=\widehat{\phi}_{i}(\widehat{\mathbf{x}})$
\end_inset

 where 
\begin_inset Formula $\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

, this relation between 
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

 and 
\begin_inset Formula $\widetilde{\phi}_{j}$
\end_inset

 can be transformed from the reference element to the real unrefined and
 real refined elements.
 
\end_layout

\begin_layout Standard
The refined and unrefined triangles are then treated as logically separated
 (and the assembly is performed on them that way) until they are 
\begin_inset Quotes eld
\end_inset

glued
\begin_inset Quotes erd
\end_inset

 together using sparse matrix-matrix multiplication with the 
\begin_inset Formula $b_{ij}$
\end_inset

 matrices.
 Note that the computational cost of this extra work depends on the number
 of basis functions associated with the common boundary between the refined
 and unrefined triangles.
 It is desirable to keep this from growing too large, especially after many
 steps of adaptation.
 The following approach is taken to prevent excessively large boundaries:
 the original triangulation is kept, and each triangle, even if refined
 many times, has a link to its 
\begin_inset Quotes eld
\end_inset

parent
\begin_inset Quotes erd
\end_inset

 triangle at the next coarser level.
 A group of refined triangles can be unrefined whenever desired.
 Thus there can be a hierarchy of levels of refinement.
 This is illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Refinement-levels"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename refinement-levels2.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Refinement-levels"

\end_inset

Refinement levels
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Identifying triangles for refinement is done using a residual-based error
 estimation method 
\begin_inset CommandInset citation
LatexCommand cite
after "Chap.~9"
key "bs:mtfem"

\end_inset

.
 If the problem is to solve 
\begin_inset Formula $\mathcal{L}u=b$
\end_inset

 where 
\begin_inset Formula $\mathcal{L}$
\end_inset

 is a linear differential operator 
\begin_inset Formula $V\to V'$
\end_inset

, 
\begin_inset Formula $V$
\end_inset

 a Hilbert space (typically a Sobolev space), then we need to estimate the
 norm of 
\begin_inset Formula $\mathcal{L}u-b$
\end_inset

 in 
\begin_inset Formula $V'$
\end_inset

 (the dual space of 
\begin_inset Formula $V$
\end_inset

).
 This in turn involves estimating 
\begin_inset Formula 
\[
\sup_{w\in V}\frac{\left\langle \mathcal{L}u-b,\, w\right\rangle _{V\times V'}}{\left\Vert w\right\Vert _{V}}.
\]

\end_inset

Since differential operators are local operators (that is, if 
\begin_inset Formula $u(\mathbf{x})=v(\mathbf{x})$
\end_inset

 for all 
\begin_inset Formula $\mathbf{x}$
\end_inset

 near 
\begin_inset Formula $\mathbf{x}^{*}$
\end_inset

, then 
\begin_inset Formula $\mathcal{L}u(\mathbf{x}^{*})=\mathcal{L}v(\mathbf{x}^{*})$
\end_inset

), this residual can be estimated on each element and its boundary.
 If 
\begin_inset Formula $V_{h}$
\end_inset

 is the finite element space (generated by all basis functions over all
 elements in the triangulation), then the Galerkin method already implies
 that 
\begin_inset Formula $\left\langle \mathcal{L}u-b,\, w\right\rangle _{V\times V'}=0$
\end_inset

 for all 
\begin_inset Formula $w\in V_{h}$
\end_inset

.
 So we need to go beyond just the basis functions of 
\begin_inset Formula $V_{h}$
\end_inset

 in order to estimate the error in the solution.
 For the problem
\begin_inset Formula 
\begin{eqnarray*}
-\nabla\cdot\left(\alpha\nabla u\right) & = & f\qquad\mbox{in }\Omega,\\
u & = & g\qquad\mbox{on }\partial\Omega,
\end{eqnarray*}

\end_inset

for example, 
\begin_inset CommandInset citation
LatexCommand cite
after "Chap.~9"
key "bs:mtfem"

\end_inset

 develops the 
\emph on
a posteriori
\emph default
 residual estimate 
\begin_inset Formula 
\[
\left\Vert e_{h}\right\Vert _{H^{-1}(\Omega)}\leq\mbox{constant}\,\left[\sum_{K}\left\Vert \nabla\cdot\left(\alpha\nabla u_{h}\right)+f\right\Vert _{L^{2}(K)}^{2}h_{K}^{2}+\sum_{e}\left\Vert \left[\alpha\mathbf{n}\cdot\nabla u_{h}\right]_{\mathbf{n}}\right\Vert _{L^{2}(e)}^{2}h_{e}\right]^{1/2}
\]

\end_inset

where 
\begin_inset Formula $K$
\end_inset

 ranges over all triangles in the triangulation, and 
\begin_inset Formula $e$
\end_inset

 ranges over all edges in the triangulation in the interior of the domain
 
\begin_inset Formula $\Omega$
\end_inset

.
 The quantity 
\begin_inset Formula $\left[\alpha\mathbf{n}\cdot\nabla u_{h}\right]_{\mathbf{n}}$
\end_inset

 is the jump in the value of 
\begin_inset Formula $\alpha\mathbf{n}\cdot\nabla u_{h}$
\end_inset

 between the values in the two elements incident to the edge 
\begin_inset Formula $e$
\end_inset

; 
\begin_inset Formula $\mathbf{n}$
\end_inset

 is the unit normal vector to the edge 
\begin_inset Formula $e$
\end_inset

.
 Note that it does not matter which sign is chosen for 
\begin_inset Formula $\mathbf{n}$
\end_inset

 in determining 
\begin_inset Formula $\left\Vert \left[\alpha\mathbf{n}\cdot\nabla u_{h}\right]_{\mathbf{n}}\right\Vert _{L^{2}(e)}^{2}$
\end_inset

.
 Also note that 
\begin_inset Formula $h_{K}$
\end_inset

 is the diameter of triangle 
\begin_inset Formula $K$
\end_inset

, which is equal to the length of the longest edge; 
\begin_inset Formula $h_{e}$
\end_inset

 is the length of edge 
\begin_inset Formula $e$
\end_inset

.
 
\end_layout

\begin_layout Standard
For a triangle 
\begin_inset Formula $K$
\end_inset

 in the triangulation, we can use 
\begin_inset Formula 
\[
\left[\left\Vert \nabla\cdot\left(\alpha\nabla u_{h}\right)+f\right\Vert _{L^{2}(K)}^{2}h_{K}^{2}+\sum_{e}\left\Vert \left[\alpha\mathbf{n}\cdot\nabla u_{h}\right]_{\mathbf{n}}\right\Vert _{L^{2}(e)}^{2}h_{e}\right]^{1/2}
\]

\end_inset

where 
\begin_inset Formula $e$
\end_inset

 ranges over the edges of 
\begin_inset Formula $K$
\end_inset

 as an estimate of the error due to the triangle 
\begin_inset Formula $K$
\end_inset

.
 If this exceeds a threshold, then that triangle should be marked for refinement.
 Since the basis functions of refined triangles associated with the common
 boundary between refined and unrefined triangles must be made 
\begin_inset Quotes eld
\end_inset

slaves
\begin_inset Quotes erd
\end_inset

 to the basis functions on the adjacent unrefined triangles, we should create
 an additional 
\begin_inset Quotes eld
\end_inset

buffer
\begin_inset Quotes erd
\end_inset

 region of refined triangles.
 Thus: a triangle should also be refined if it is adjacent to a triangle
 with an excessively large error estimate.
\end_layout

\begin_layout Subsection
Representation of refined mesh
\end_layout

\begin_layout Standard
The refinement of a single element is represented by the standard refinement,
 which is a triangulation of the reference element (
\family typewriter
p_refref
\family default
,
\family typewriter
t_refref
\family default
) (here 
\begin_inset Quotes eld
\end_inset

refref
\begin_inset Quotes erd
\end_inset

 indicates 
\begin_inset Quotes eld
\end_inset

reference element refinement
\begin_inset Quotes erd
\end_inset

), being the points and triangles of the triangulation in the manner of
 (
\family typewriter
p
\family default
,
\family typewriter
t
\family default
) described above.
 We need a data structure similar to that for element types: in order to
 join refined triangles from different master triangles, we need to associate
 a unique geometric feature of the master triangle to each node of the refinemen
t.
 We also need to identify permuations of nodes that occur due to the permutation
s of the geometric features.
 These should work very much like 
\family typewriter
pxfeature()
\family default
, 
\family typewriter
nvars
\family default
 and 
\family typewriter
flist
\family default
 in the element type data structures.
 (Here we replace 
\family typewriter
nvars
\family default
 with 
\family typewriter
npts
\family default
.) This will give us a 
\begin_inset Quotes eld
\end_inset

refref
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

reference element refinement
\begin_inset Quotes erd
\end_inset

 data structure.
 An example reference refinement is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Reference-refinement-example"

\end_inset

.
 Note that for this reference refinement using piecewise linear element
 (
\family typewriter
lin2d_elt()
\family default
) we have
\begin_inset Formula 
\[
B=\left[\begin{array}{cccccc}
1 &  &  &  & 1/2 & 1/2\\
 & 1 &  & 1/2 &  & 1/2\\
 &  & 1 & 1/2 & 1/2
\end{array}\right].
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename refref1.eps
	width 45text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reference-refinement-example"

\end_inset

Reference refinement example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<reference refinement example>>=
\end_layout

\begin_layout Scrap
p_refref = [0 0; 1 0; 0 1; 1/2 1/2; 0 1/2; 1/2 0];
\end_layout

\begin_layout Scrap
t_refref = [1 5 6; 2 4 6; 3 4 5; 4 5 6];
\end_layout

\begin_layout Scrap
npts     = [1;     1;     1;     1;     1;     1];  % number of points in
 each geometric feature
\end_layout

\begin_layout Scrap
flist    = [1 0 0; 2 0 0; 3 0 0; 2 3 0; 1 3 0; 1 2 0];
\end_layout

\begin_layout Scrap
Brefref  = [1 0 0   0 1/2 1/2;
\end_layout

\begin_layout Scrap
            0 1 0 1/2   0 1/2;
\end_layout

\begin_layout Scrap
            0 0 1 1/2 1/2   0];
\end_layout

\begin_layout Scrap
refref2d = struct('p',p_refref,'t',t_refref,'npts',npts,'flist',flist, ...
\end_layout

\begin_layout Scrap
                     'Brefref',Brefref,'pxfeature',@px_refref1);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Note that the points in 
\family typewriter
p_refref
\family default
 must occur in the order described by 
\family typewriter
flist
\family default
 and 
\family typewriter
npts
\family default
.
 If a vertex of the reference refinement is also a vertex of the reference
 element, then there can only be one point associated with that geometric
 feature: if 
\family typewriter
flist(k,:)
\family default
 represents a vertex (of the reference element), then 
\family typewriter
npts(k)
\family default
 must be one.
 Also, the vertices of the reference triangle must be the initial vertices
 of the reference refinement so that 
\family typewriter
p_refref(i,:)
\family default
 must be vertex i of the reference element.
\end_layout

\begin_layout Standard
The relationship between the basis functions on the reference element, and
 the basis functions on the standard refinement is given by the 
\begin_inset Formula $\left[b_{ij}\right]$
\end_inset

 matrix 
\family typewriter
B_refref
\family default
.
 The indexes into this matrix is given by the standard ordering of basis
 functions as defined by 
\family typewriter
Aphihat()
\family default
 for 
\begin_inset Formula $i$
\end_inset

, but for 
\begin_inset Formula $j$
\end_inset

 we can use the basis function numbers assigned by 
\family typewriter
create_fht()
\family default
.
 
\end_layout

\begin_layout Standard
A test mesh for applying the refinement to is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Test-mesh-refinement"

\end_inset

.
 The dashed lines show the refined mesh.
 The triangulation of this test mesh is given below.
\end_layout

\begin_layout Scrap
<<refinement test triangulation>>=
\end_layout

\begin_layout Scrap
p_testref = [0 0; 1.5 0; 2.5 0; 3.5 0; 3.5 1; ...
\end_layout

\begin_layout Scrap
    2.5 0.7; 1.5 1; 0 1; 1.5 2; 2.5 1.5];
\end_layout

\begin_layout Scrap
t_testref = [1 2 7; 2 7 6; 2 3 6; 4 3 6; 4 5 6; ...
\end_layout

\begin_layout Scrap
    10 5 6; 6 10 7; 1 7 8; 8 7 9; 7 9 10];
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename test-ref-grid.eps
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Test-mesh-refinement"

\end_inset

Test mesh for refinement
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generating refined meshes
\end_layout

\begin_layout Standard
The algorithm to create the refined mesh basically involves processing each
 triangle in the 
\begin_inset Quotes eld
\end_inset

master triangulation
\begin_inset Quotes erd
\end_inset

.
 We process each geometric feature of each master triangle using an initially
 empty hash table of geometric features (
\family typewriter
rfht
\family default
).
 For each geometric feature that is not in the hash table, and is not a
 vertex, we create new points according to the points associated with that
 geometric feature of the reference refinement.
 The geometric feature is then added as a key to the hash table; the value
 of the key in the table is the ordered list of point indexes in the refined
 triangulation.
 For each master triangle to be refined, we need to create a map (
\family typewriter
p_rr_trx
\family default
) that translates point indexes in the reference refinement into point indexes
 in the actual refined mesh.
 The points in the reference refinement must be transformed to actual points
 in the refined mesh (this involves the transformation 
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto T\widehat{\mathbf{x}}+\mathbf{b}=\mathbf{x}$
\end_inset

.
 
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
create-refinement.m 
\backslash

\end_layout

\begin_layout Scrap
<<create-refinement.m>>=
\end_layout

\begin_layout Scrap
function [p_ref,t_ref,master_ref,idx_ref,rfht,master2rr_pt] = ...
\end_layout

\begin_layout Scrap
create_refinement(p,t,refine_list,refref)
\end_layout

\begin_layout Scrap
% function [p_ref,t_ref,master_ref,idx_ref,rfht,master2rr_pt] = ...
\end_layout

\begin_layout Scrap
% create_refinement(p,t,refine_list,refref)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Create refined mesh using reference refinement refref.
\end_layout

\begin_layout Scrap
% (p,t) represent the unrefined "master" triangulation,
\end_layout

\begin_layout Scrap
% where refine_list is the list of triangle indexes that are
\end_layout

\begin_layout Scrap
% to be refined: the triangles to be refined are
\end_layout

\begin_layout Scrap
% t(refine_list(i),:), i = 1, ..., length(refine_list).
\end_layout

\begin_layout Scrap
% The returned items are:
\end_layout

\begin_layout Scrap
% (p_ref,t_ref) are the triangulation of the refined mesh
\end_layout

\begin_layout Scrap
% master_ref(i) is the row index into t of the master triangle
\end_layout

\begin_layout Scrap
% of triangle t_ref(i,:)
\end_layout

\begin_layout Scrap
% idx_ref(i) is the row index into refref.t identifies
\end_layout

\begin_layout Scrap
% which sub-triangle of triangle master_ref(i) is t_ref(i,:).
\end_layout

\begin_layout Scrap
% Note that idx_ref(i) == 0 iff t_ref(i,:) is an unrefined triangle.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% master2rr_pt(i,:) is the ordered list of indexes of points in
\end_layout

\begin_layout Scrap
% master triangle i that are in the refined mesh.
\end_layout

\begin_layout Scrap
% master2rr_pt(i,j) is the index into p_ref of master triangle i
\end_layout

\begin_layout Scrap
% and point refref.p(j,:).
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
rfht = containers.Map('KeyType','int64','ValueType','any');
\end_layout

\begin_layout Scrap
rr_npts = refref.npts;
\end_layout

\begin_layout Scrap
rr_flist = refref.flist;
\end_layout

\begin_layout Scrap
p_ref = p; % include all points of unrefined triangles
\end_layout

\begin_layout Scrap
t_ref = [];
\end_layout

\begin_layout Scrap
master_ref = [];
\end_layout

\begin_layout Scrap
nt_ref = 0;
\end_layout

\begin_layout Scrap
np_ref = size(p,1);
\end_layout

\begin_layout Scrap
ismaster = zeros(size(t,1),1);
\end_layout

\begin_layout Scrap
ismaster(refine_list) = 1;
\end_layout

\begin_layout Scrap
master2rr_pt = zeros(size(t,1),size(refref.p,1));
\end_layout

\begin_layout Scrap
p_rr_trx = zeros(size(refref.p,1),1);
\end_layout

\begin_layout Scrap
idx_ref = [];
\end_layout

\begin_layout Scrap
for i = 1:size(t,1)
\end_layout

\begin_layout Scrap
    % master_triangle_i = t(i,:)
\end_layout

\begin_layout Scrap
    % master_triangle_points = [p(t(i,1),:); p(t(i,2),:); p(t(i,3),:)] 
\end_layout

\begin_layout Scrap
    p_rr_trx(:) = 0;
\end_layout

\begin_layout Scrap
    if ismaster(i)
\end_layout

\begin_layout Scrap
        % vertices of master triangle
\end_layout

\begin_layout Scrap
        p1 = p(t(i,1),:); p2 = p(t(i,2),:); p3 = p(t(i,3),:);
\end_layout

\begin_layout Scrap
        % transformation from ref element to master triangle
\end_layout

\begin_layout Scrap
        T = [p2'-p1', p3'-p1'];
\end_layout

\begin_layout Scrap
        b = p1';
\end_layout

\begin_layout Scrap
        % transform points in reference refinement
\end_layout

\begin_layout Scrap
        % Tp_rr = zeros(size(refref.p));
\end_layout

\begin_layout Scrap
        % for j = 1:size(refref.p,1)
\end_layout

\begin_layout Scrap
        % Tp_rr(j,:) = refref.p(j,:)*T' + b';
\end_layout

\begin_layout Scrap
        % end
\end_layout

\begin_layout Scrap
        Tp_rr = bsxfun(@plus,refref.p*T',b');
\end_layout

\begin_layout Scrap
        p_rr_idx = 1; % index into refref.p
\end_layout

\begin_layout Scrap
        % for each geometric feature of the master triangle ...
\end_layout

\begin_layout Scrap
        for k = 1:size(rr_flist,1) 
\end_layout

\begin_layout Scrap
            npts_k = refref.npts(k);
\end_layout

\begin_layout Scrap
            if length(find(rr_flist(k,:))) ~= 1 % not a vertex
\end_layout

\begin_layout Scrap
                % if geometric feature not in hash table, add the points
\end_layout

\begin_layout Scrap
                f = rr_flist(k,:);
\end_layout

\begin_layout Scrap
                f = f(find(f));
\end_layout

\begin_layout Scrap
                [f,px] = sort(t(i,f));
\end_layout

\begin_layout Scrap
                fref = get_feature_ref(f,np);
\end_layout

\begin_layout Scrap
                pt_px = refref.pxfeature(px);
\end_layout

\begin_layout Scrap
                if ~ isKey(rfht,fref)
\end_layout

\begin_layout Scrap
                    pt_list = np_ref + (1:npts_k);
\end_layout

\begin_layout Scrap
                    rfht(fref) = pt_list;
\end_layout

\begin_layout Scrap
                    p_ref = [p_ref; Tp_rr(p_rr_idx-1+pt_px,:)];
\end_layout

\begin_layout Scrap
                    np_ref = np_ref + npts_k;
\end_layout

\begin_layout Scrap
                else % isKey(rfht,fref)
\end_layout

\begin_layout Scrap
                    pt_list = rfht(fref);
\end_layout

\begin_layout Scrap
                end % if
\end_layout

\begin_layout Scrap
                p_rr_trx(p_rr_idx-1+(1:npts_k)) = pt_list(pt_px);
\end_layout

\begin_layout Scrap
            else   % is a vertex of a master triangle, so use the corresponding
 
\end_layout

\begin_layout Scrap
                % vertex of the master triangle
\end_layout

\begin_layout Scrap
                p_rr_trx(p_rr_idx) = t(i,rr_flist(k,1));
\end_layout

\begin_layout Scrap
            end % if
\end_layout

\begin_layout Scrap
            p_rr_idx = p_rr_idx + npts_k;
\end_layout

\begin_layout Scrap
        end % for k
\end_layout

\begin_layout Scrap
        % p_rr_trx
\end_layout

\begin_layout Scrap
        % refined_points = p_ref(p_rr_trx,:)
\end_layout

\begin_layout Scrap
        % now add the refined triangles to the mesh
\end_layout

\begin_layout Scrap
        % new_t_ref = p_rr_trx(refref.t)
\end_layout

\begin_layout Scrap
        t_ref = [t_ref; p_rr_trx(refref.t)];
\end_layout

\begin_layout Scrap
        idx_ref = [idx_ref; (1:size(refref.t,1))'];
\end_layout

\begin_layout Scrap
        nt_ref = nt_ref + size(refref.t,1);
\end_layout

\begin_layout Scrap
        master_ref = [master_ref, i*ones(1,size(refref.t,1))];
\end_layout

\begin_layout Scrap
        master2rr_pt(i,:) = p_rr_trx'; % turn p_rr_trx into row vector
\end_layout

\begin_layout Scrap
    else % ~ ismaster(i)
\end_layout

\begin_layout Scrap
        % no extra points, just one extra triangle
\end_layout

\begin_layout Scrap
        nt_ref = nt_ref + 1;
\end_layout

\begin_layout Scrap
        t_ref = [t_ref; t(i,:)];
\end_layout

\begin_layout Scrap
        master_ref(nt_ref) = i;
\end_layout

\begin_layout Scrap
        idx_ref(nt_ref) = 0; % not a refined triangle
\end_layout

\begin_layout Scrap
        master2rr_pt(i,1:3) = t(i,:);
\end_layout

\begin_layout Scrap
    end % if ismaster(i)
\end_layout

\begin_layout Scrap
end % for i
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Test code for 
\family typewriter
create_refinement()
\family default
 follows.
 The reference refinements for these tests are firstly a simple subdivision
 of the reference element into four congruent sub-triangles.
 The second subdivides each edge into thirds, resulting in a subdivision
 into 10 congruent sub-triangles.
 The third reference refinement included a sub-triangle that is completely
 contained within the interior of the reference element.
 This was used to check that the ordering of the vertices did not cause
 incorrect refinements.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
ref-test-script.m 
\backslash

\end_layout

\begin_layout Scrap
<<ref-test-script.m>>=
\end_layout

\begin_layout Scrap
% Test script for refinement
\end_layout

\begin_layout Scrap
p_refref = [0 0; 1 0; 0 1; 1/2 1/2; 0 1/2; 1/2 0];
\end_layout

\begin_layout Scrap
t_refref = [1 5 6; 2 4 6; 3 4 5; 4 5 6];
\end_layout

\begin_layout Scrap
npts = [1; 1; 1; 1; 1; 1];
\end_layout

\begin_layout Scrap
flist = [1 0 0; 2 0 0; 3 0 0; 2 3 0; 1 3 0; 1 2 0];
\end_layout

\begin_layout Scrap
Brefref = [1 0 0 0 1/2 1/2;
\end_layout

\begin_layout Scrap
0 1 0 1/2 0 1/2;
\end_layout

\begin_layout Scrap
0 0 1 1/2 1/2 0];
\end_layout

\begin_layout Scrap
px_refref1 = @(px)[1];
\end_layout

\begin_layout Scrap
refref2d = struct('p',p_refref,'t',t_refref,'npts',npts,'flist',flist, ...
\end_layout

\begin_layout Scrap
'Brefref',Brefref,'pxfeature',px_refref1);
\end_layout

\begin_layout Scrap
p_testref = [0 0; 1.5 0; 2.5 0; 3.5 0; 3.5 1; ...
\end_layout

\begin_layout Scrap
2.5 0.7; 1.5 1; 0 1; 1.5 2; 2.5 1.5];
\end_layout

\begin_layout Scrap
t_testref = [1 2 7; 2 7 6; 2 3 6; 4 3 6; 4 5 6; ...
\end_layout

\begin_layout Scrap
10 5 6; 6 10 7; 1 7 8; 8 7 9; 7 9 10];
\end_layout

\begin_layout Scrap
trimesh(t_testref,p_testref(:,1),p_testref(:,2))
\end_layout

\begin_layout Scrap
axis([-.3 4 -.3 3])
\end_layout

\begin_layout Scrap
master = [1,2,3,4,5,7,8]
\end_layout

\begin_layout Scrap
[p_ref,t_ref,master_ref,idx_refref,rfht] = ...
\end_layout

\begin_layout Scrap
create_refinement(p_testref,t_testref,master,refref2d)
\end_layout

\begin_layout Scrap
trimesh(t_ref,p_ref(:,1),p_ref(:,2))
\end_layout

\begin_layout Scrap
'Press any key to continue'
\end_layout

\begin_layout Scrap
pause
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
p_refref2 = [0 0; 1 0; 0 1; 2/3 1/3; 1/3 2/3; 0 1/3; 0 2/3; 1/3 0; 2/3 0;
 1/3 1/3];
\end_layout

\begin_layout Scrap
t_refref2 = [1 8 6; 6 8 10; 8 9 10; 9 4 10; 9 2 4; 7 6 10; 10 5 7; 10 4
 5; 7 5 3];
\end_layout

\begin_layout Scrap
npts2 = [ 1; 1; 1; 2; 2; 2; 1];
\end_layout

\begin_layout Scrap
flist2 = [1 0 0; 2 0 0; 3 0 0; 2 3 0; 1 3 0; 1 2 0; 1 2 3];
\end_layout

\begin_layout Scrap
px_refref2 = @(px)ifte(length(px)==2,px,[1])
\end_layout

\begin_layout Scrap
refref2d_2 = struct('p',p_refref2,'t',t_refref2,'npts',npts2,'flist',flist2,
 ...
\end_layout

\begin_layout Scrap
'Brefref',[],'pxfeature',px_refref2);
\end_layout

\begin_layout Scrap
[p_ref2,t_ref2,master_ref2,idx_refref2,rfht2] = ...
\end_layout

\begin_layout Scrap
create_refinement(p_testref,t_testref,master,refref2d_2)
\end_layout

\begin_layout Scrap
trimesh(t_ref2,p_ref2(:,1),p_ref2(:,2))
\end_layout

\begin_layout Scrap
'Press any key to continue'
\end_layout

\begin_layout Scrap
pause
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Scrap
npts3 = [ 1; 1; 1; 1; 1; 1; 3];
\end_layout

\begin_layout Scrap
flist3 = [1 0 0; 2 0 0; 3 0 0; 2 3 0; 1 3 0; 1 2 0; 1 2 3];
\end_layout

\begin_layout Scrap
p_refref3 = [0 0; 1 0; 0 1; 1/2 1/2; 0 1/2; 1/2 0; 1/6 1/6; 2/3 1/6; 1/6
 2/3];
\end_layout

\begin_layout Scrap
t_refref3 = [1 7 6; 6 7 8; 6 8 2; 7 5 1; 7 5 9; 7 8 9; 8 9 4; 2 4 8; 5 9
 3; 9 4 3];
\end_layout

\begin_layout Scrap
size_p_refref3 = size(p_refref3)
\end_layout

\begin_layout Scrap
size_t_refref3 = size(t_refref3)
\end_layout

\begin_layout Scrap
px_refref3 = @(px)ifte(length(px)==3,px,[1])
\end_layout

\begin_layout Scrap
refref2d_3 = struct('p',p_refref3,'t',t_refref3,'npts',npts3,'flist',flist3,
 ...
\end_layout

\begin_layout Scrap
'Brefref',[],'pxfeature',px_refref3)
\end_layout

\begin_layout Scrap
[p_ref3,t_ref3,master_ref3,idx_refref3,rfht3] = ...
\end_layout

\begin_layout Scrap
create_refinement(p_testref,t_testref,master,refref2d_3)
\end_layout

\begin_layout Scrap
trimesh(t_ref3,p_ref3(:,1),p_ref3(:,2))
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Finding the internal boundary between refined and unrefined elements
\end_layout

\begin_layout Standard
The next task is to determine the edges (or faces in 3-D) common to both
 the unrefined and refined master triangles.
 The main idea is to find all edges of triangles that appear exactly once
 in both the refined and unrefined sets of triangles, but appear exactly
 twice in the union of these sets of edges.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
get-internal-boundary2d.m 
\backslash

\end_layout

\begin_layout Scrap
<<get-internal-boundary2d.m>>=
\end_layout

\begin_layout Scrap
function [bedges,bnodes,t_idx1,t_idx2] = get_internal_boundary2d(t,t_list)
\end_layout

\begin_layout Scrap
% function [bedges,bnodes,t_idx1,t_idx2] = get_internal_boundary2d(t,t_list)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns the boundary between the triangles in t_list and its complement.
\end_layout

\begin_layout Scrap
% t_list is a list of row indexes i into t(i,j)
\end_layout

\begin_layout Scrap
% bedges is an m x 2 array listing the edges in the boundary.
\end_layout

\begin_layout Scrap
% bnodes is a  p x 1 array listing the nodes in the boundary.
\end_layout

\begin_layout Scrap
% t_idx1(i) is the triangle containing bedges(i) in t_list.
\end_layout

\begin_layout Scrap
% t_idx2(i) is the triangle containing bedges(i) in the complement of t_list.
\end_layout

\begin_layout Scrap
t_list = t_list';
\end_layout

\begin_layout Scrap
% compute complement of t_list
\end_layout

\begin_layout Scrap
tf = zeros(size(t,1),1);
\end_layout

\begin_layout Scrap
tf(t_list) = 1;
\end_layout

\begin_layout Scrap
ct_list = find(tf == 0);
\end_layout

\begin_layout Scrap
% compute boundary of each part ...
\end_layout

\begin_layout Scrap
[bedges1,bnodes1,t_idx1a] = boundary2d(t( t_list,:));
\end_layout

\begin_layout Scrap
[bedges2,bnodes2,t_idx2a] = boundary2d(t(ct_list,:));
\end_layout

\begin_layout Scrap
% ...
 and find the common part
\end_layout

\begin_layout Scrap
temp = sortrows([bedges1, t_list(t_idx1a); 
\end_layout

\begin_layout Scrap
                 bedges2,ct_list(t_idx2a)+size(t,1)]);
\end_layout

\begin_layout Scrap
[temp2,idx1] = unique(temp(:,1:2),'rows','first');
\end_layout

\begin_layout Scrap
[temp2,idx2] = unique(temp(:,1:2),'rows','last');
\end_layout

\begin_layout Scrap
difflist = find(idx1 ~= idx2);
\end_layout

\begin_layout Scrap
bedges = temp(idx1(difflist),1:2);
\end_layout

\begin_layout Scrap
t_idx1 = temp(idx1(difflist),3)';
\end_layout

\begin_layout Scrap
t_idx2 = temp(idx2(difflist),3)' - size(t,1);
\end_layout

\begin_layout Scrap
bnodes = unique(sort(bedges(:)));
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Getting the edges of the reference refinement corresponding to an edge of
 the reference triangle
\end_layout

\begin_layout Standard
This only needs to be computed once for each edge of the reference triangle.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
rr-get-redges.m 
\backslash

\end_layout

\begin_layout Scrap
<<rr-get-redges.m>>=
\end_layout

\begin_layout Scrap
function [elist,rrtlist] = rr_get_redges(edge,rr) 
\end_layout

\begin_layout Scrap
% function [elist,rrtlist] = rr_get_redges(edge,rr) 
\end_layout

\begin_layout Scrap
% 
\end_layout

\begin_layout Scrap
% Return list of refined edges in edge in the 
\end_layout

\begin_layout Scrap
% reference refinement.
  Note that edge % is a pair of indexes into rr.p for the 
\end_layout

\begin_layout Scrap
% reference triangle.
 0; 
\end_layout

\begin_layout Scrap
% First find list of points in refined triangulation 
\end_layout

\begin_layout Scrap
% in edge from master triangulation.
 
\end_layout

\begin_layout Scrap
ptlist = []; 
\end_layout

\begin_layout Scrap
npts  = rr.npts; 
\end_layout

\begin_layout Scrap
cnpts = cumsum(rr.npts); 
\end_layout

\begin_layout Scrap
for k = 1:size(rr.flist,1)
\end_layout

\begin_layout Scrap
    f = rr.flist(k,:);
\end_layout

\begin_layout Scrap
    f = f(find(f));
\end_layout

\begin_layout Scrap
    idx = subset_scan(f,edge);
\end_layout

\begin_layout Scrap
    if min(idx) > 0 % then f is a subset of edge
\end_layout

\begin_layout Scrap
        ptlist = [ptlist, (cnpts(k)-npts(k)+1):cnpts(k)];
\end_layout

\begin_layout Scrap
    end 
\end_layout

\begin_layout Scrap
end 
\end_layout

\begin_layout Scrap
% ptlist 
\end_layout

\begin_layout Scrap
% Now find edges in reference refinement that are 
\end_layout

\begin_layout Scrap
% in edge in the master triangulation 
\end_layout

\begin_layout Scrap
elist = []; 
\end_layout

\begin_layout Scrap
rrtlist = []; 
\end_layout

\begin_layout Scrap
for i = 1:size(rr.t)
\end_layout

\begin_layout Scrap
    % triangle = rr.t(i,:)
\end_layout

\begin_layout Scrap
    idx = subset_scan(rr.t(i,:),ptlist);
\end_layout

\begin_layout Scrap
    if sum(idx > 0) == 2
\end_layout

\begin_layout Scrap
        % 2 of the 3 vertices are in ptlist
\end_layout

\begin_layout Scrap
        elist = [elist; rr.t(i,find(idx>0))];
\end_layout

\begin_layout Scrap
        rrtlist = [rrtlist, i];
\end_layout

\begin_layout Scrap
    end 
\end_layout

\begin_layout Scrap
end 
\end_layout

\begin_layout Scrap
elist = sort(elist,2); 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Creating the stiffness matrices for adapted meshes
\end_layout

\begin_layout Standard
To create the stiffness matrices we use the assumption that the basis functions
 on the reference element can be expressed as linear combinations of the
 basis functions on the reference refinement.
 The 
\begin_inset Formula $B$
\end_inset

 matrix gives the relationship between the basis functions on the reference
 element (
\begin_inset Formula $\widehat{\phi}_{i}$
\end_inset

) and the basis functions on the reference refinement (
\begin_inset Formula $\widetilde{\phi}_{j}$
\end_inset

):
\begin_inset Formula 
\[
\widehat{\phi}_{i}=\sum_{j}b_{ij}\widetilde{\phi}_{j}.
\]

\end_inset

This matrix depends both on the reference refinement and the element type.
 This can be computed as follows for piecewise linear elements:
\end_layout

\begin_layout Scrap
<<calculation of $B$ matrix>>=
\end_layout

\begin_layout Scrap
lin2d = lin2d_elt()
\end_layout

\begin_layout Scrap
[fht_rr,v2tnum_rr,v2fnum_rr,v2fidx_rr] = ...
\end_layout

\begin_layout Scrap
    create_fht(refref2d.p,refref2d.t,lin2d)
\end_layout

\begin_layout Scrap
nvars = fht_num_vars(fht_rr)
\end_layout

\begin_layout Scrap
ls_rr = struct('coeffs',@(x)1,'rhs',@(x)lin2d.Aphihat(x,0)', ...
\end_layout

\begin_layout Scrap
    'order',0)
\end_layout

\begin_layout Scrap
A = zeros(nvars,nvars);
\end_layout

\begin_layout Scrap
b = zeros(nvars,sum(lin2d.nvars));
\end_layout

\begin_layout Scrap
[A,b] = assembly2d(A,b,ls_rr,lin2d,refref2d.p,refref2d.t, ...
\end_layout

\begin_layout Scrap
    fht_rr,@int2d_radon7)
\end_layout

\begin_layout Scrap
Brefref = A 
\backslash
 b;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The next step is to determine the edges of the sub-triangles that are part
 of the internal boundary between refined and unrefined triangles.
 We use a utility routine 
\family typewriter
subset_scan()
\family default
 defined below.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
subset-scan.m 
\backslash

\end_layout

\begin_layout Scrap
<<subset-scan.m>>=
\end_layout

\begin_layout Scrap
function idx = subset_scan(list1,list2)
\end_layout

\begin_layout Scrap
% function idx = subset_scan(list1,list2)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns index list idx where
\end_layout

\begin_layout Scrap
% if idx(i) != 0 then list1(i) == list2(idx(i)), and
\end_layout

\begin_layout Scrap
% if idx(i) == 0 then list1(i) ~= list2(j) for any j.
\end_layout

\begin_layout Scrap
idx = zeros(size(list1));
\end_layout

\begin_layout Scrap
[list1,px1] = sort(list1);
\end_layout

\begin_layout Scrap
[list2,px2] = sort(list2);
\end_layout

\begin_layout Scrap
i1 = 1;
\end_layout

\begin_layout Scrap
i2 = 1;
\end_layout

\begin_layout Scrap
while i1 <= length(list1) && i2 <= length(list2)
\end_layout

\begin_layout Scrap
    if list1(i1) < list2(i2)
\end_layout

\begin_layout Scrap
        i1 = i1 + 1;
\end_layout

\begin_layout Scrap
    elseif list1(i1) > list2(i2)
\end_layout

\begin_layout Scrap
        i2 = i2 + 1;
\end_layout

\begin_layout Scrap
    else
\end_layout

\begin_layout Scrap
        idx(px1(i1)) = px2(i2);
\end_layout

\begin_layout Scrap
        i1 = i1 + 1;
\end_layout

\begin_layout Scrap
        i2 = i2 + 1;
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
<<generate hash table of point lists for geometric features>>=
\end_layout

\begin_layout Scrap
<<find edges of refined sub-triangles>>=
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Combining multiple levels of refinement in matrix assembly
\end_layout

\begin_layout Subsection
Error estimation and identification of triangles to refine
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Output-and-visualization"

\end_inset

Output and visualization
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Visualization"

\end_inset

Visualization
\begin_inset Index idx
status open

\begin_layout Plain Layout
visualization
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Visualization of the results is greatly simplified by Matlab's 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
trimesh()
\end_layout

\end_inset

trimesh()
\family default
 function.
 For example, to see a triangulation as given by (
\family typewriter
p
\family default
,
\family typewriter
t
\family default
), we use
\end_layout

\begin_layout Scrap
<<trimesh-example>>=
\end_layout

\begin_layout Scrap
trimesh(t,p(:,1),p(:,2))
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Visualizing-solutions"

\end_inset

Visualizing solutions (and mesh functions)
\end_layout

\begin_layout Standard
One way of seeing the solution of a PDE (or some other quantity defined
 on a mesh for a certain element) is to get the list of variables associated
 with each point and plot those variable values.
 This will work for scalar element types of Lagrange type (such as the piecewise
 linear, quadratic, and cubic elements described in Sections
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piecewise-linear-elements"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piecewise-quadratic-elements"

\end_inset

, and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piecewise-cubic-elements"

\end_inset

).
 We can use the following routine:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
get_pvlist()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
get-pvlist.m 
\backslash

\end_layout

\begin_layout Scrap
<<get-pvlist.m>>=
\end_layout

\begin_layout Scrap
function pvlist = get_pvlist(fht,np)
\end_layout

\begin_layout Scrap
% function pvlist = get_pvlist(fht,np)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Get list of variable indexes for the points.
\end_layout

\begin_layout Scrap
% That is, pvlist(i) is the variable number for the point
\end_layout

\begin_layout Scrap
% in the triangulation with index i.
\end_layout

\begin_layout Scrap
% As usual, np is the number of points.
\end_layout

\begin_layout Scrap
pvlist = zeros(np,1);
\end_layout

\begin_layout Scrap
for i = 1:np
\end_layout

\begin_layout Scrap
    pvlist(i) = fht(get_feature_ref(i,np));
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Then we can view the solution via
\end_layout

\begin_layout Scrap
<<visualization-example>>=
\end_layout

\begin_layout Scrap
u = ...;  % compute solution
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
pvlist = get_pvlist(fht,np); 
\end_layout

\begin_layout Scrap
trimesh(t,p(:,1),p(:,2),u(pvlist)) 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Boundary-visualization"

\end_inset

Boundary visualization
\end_layout

\begin_layout Standard
There are two functions for boundary visualization: one which plots just
 the boundary and one with the boundary and normal vectors.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
plot_boundary2d()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
plot-boundary2d.m 
\backslash

\end_layout

\begin_layout Scrap
<<plot-boundary2d.m>>=
\end_layout

\begin_layout Scrap
function plot_boundary2d(p,t,bb)
\end_layout

\begin_layout Scrap
% function plot_boundary2d(p,t,bb)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Plots the boundary of a mesh in 2D given by p and t.
\end_layout

\begin_layout Scrap
% The i'th point is p(i,:), and triangle j is given by
\end_layout

\begin_layout Scrap
% points with indexes t(j,1), t(j,2) & t(j,3).
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% The bounding box is given in bb = [xmin, xmax, ymin,ymax].
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% See distmesh.m etc.
\end_layout

\begin_layout Scrap
[bedges,bnodes] = boundary2d(t);
\end_layout

\begin_layout Scrap
bdry_tri = [bedges(:,1),bedges(:,2),bedges(:,2)];
\end_layout

\begin_layout Scrap
triplot(bdry_tri,p(:,1),p(:,2));
\end_layout

\begin_layout Scrap
axis(bb)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
And now with normal vectors (use with equal axes to preserve orthogonality):
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
plot_boundary2dwnormals()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
plot-boundary2dwnormals.m 
\backslash

\end_layout

\begin_layout Scrap
<<plot-boundary2dwnormals.m>>=
\end_layout

\begin_layout Scrap
function plot_boundary2dwnormals(p,t,bb)
\end_layout

\begin_layout Scrap
% function plot_boundary2dwnormals(p,t,bb)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Plots the boundary of a mesh in 2D given by p and t.
\end_layout

\begin_layout Scrap
% The i'th point is p(i,:), and triangle j is given by
\end_layout

\begin_layout Scrap
% points with indexes t(j,1), t(j,2) & t(j,3).
\end_layout

\begin_layout Scrap
% The normals are also plotted from the center of each edge.
\end_layout

\begin_layout Scrap
% The length of the normal vectors is the length of the edge.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% The bounding box is given in bb = [xmin, xmax, ymin,ymax].
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% See distmesh.m etc.
\end_layout

\begin_layout Scrap
[bedges,bnodes,normals] = boundary2d_2(p,t);
\end_layout

\begin_layout Scrap
bdry_tri = [bedges(:,1),bedges(:,2),bedges(:,2)];
\end_layout

\begin_layout Scrap
midpts = 0.5*(p(bedges(:,1),:)+p(bedges(:,2),:));
\end_layout

\begin_layout Scrap
len_edges = sqrt(sum((p(bedges(:,1),:)-p(bedges(:,2),:)).^2,2));
\end_layout

\begin_layout Scrap
arrowpts = midpts + diag(sparse(len_edges))*normals;
\end_layout

\begin_layout Scrap
hold on
\end_layout

\begin_layout Scrap
triplot(bdry_tri,p(:,1),p(:,2));
\end_layout

\begin_layout Scrap
arrow(midpts,arrowpts);
\end_layout

\begin_layout Scrap
axis(bb);
\end_layout

\begin_layout Scrap
hold off
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Labelled meshes in two dimensions
\end_layout

\begin_layout Standard
While 
\family typewriter
trimesh()
\family default
 is very convenient for showing a triangulation, often we need vertex labels
 as well.
 The following code does this.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
trimesh-labelled.m 
\backslash

\end_layout

\begin_layout Scrap
<<trimesh-labelled.m>>=
\end_layout

\begin_layout Scrap
function trimesh_labelled(p,t)
\end_layout

\begin_layout Scrap
% function trimesh_labelled(p,t)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Produces plot of triangulation, labelled by vertex number
\end_layout

\begin_layout Scrap
trimesh(t,p(:,1),p(:,2));
\end_layout

\begin_layout Scrap
for i = 1:size(p,1)
\end_layout

\begin_layout Scrap
    text(p(i,1),p(i,2),num2str(i));
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Refined-output"

\end_inset

Refined output
\end_layout

\begin_layout Standard
The results of 
\family typewriter

\begin_inset Index idx
status open

\begin_layout Plain Layout
trimesh()
\end_layout

\end_inset

trimesh()
\family default
 do not capture the higher order behavior of the mesh function or solution
 as it assumes the function is piecewise linear.
 To capture the quadratic or higher order behavior we need to create a sub-mesh
 and plot on the submesh.
 This can be done by, for example, creating a sub-mesh for the reference
 element, and then replacing each triangle in the triangulation with the
 reference element's sub-mesh transformed in the usual way (
\begin_inset Formula $\widehat{\mathbf{x}}\mapsto\mathbf{x}=T_{K}\widehat{\mathbf{x}}+\mathbf{b}_{K}$
\end_inset

).
 The values can then be computed on the sub-mesh of the original triangulation,
 and the result plotted using 
\family typewriter
trimesh()
\family default
.
\end_layout

\begin_layout Standard
First we have code to create a sub-mesh for the reference element.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ref_triangle_submesh()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
ref-triangle-submesh.m 
\backslash

\end_layout

\begin_layout Scrap
<<ref-triangle-submesh.m>>=
\end_layout

\begin_layout Scrap
function [p,t] = ref_triangle_submesh(n)
\end_layout

\begin_layout Scrap
% function [p,t] = ref_triangle_submesh(n)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Creates a standard mesh on the reference triangle
\end_layout

\begin_layout Scrap
% (vertices at (0,0), (1,0) and (0,1)).
\end_layout

\begin_layout Scrap
% n+1 is the number of grid points on each edge
\end_layout

\begin_layout Scrap
% Generate points
\end_layout

\begin_layout Scrap
p = zeros(n*(n+1)/2,2);
\end_layout

\begin_layout Scrap
k = 1;
\end_layout

\begin_layout Scrap
for i = 0:n
\end_layout

\begin_layout Scrap
    for j = 0:n-i
\end_layout

\begin_layout Scrap
        p(k,:) = [i,j];
\end_layout

\begin_layout Scrap
        k = k+1;
\end_layout

\begin_layout Scrap
    end
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
p = p / n;
\end_layout

\begin_layout Scrap
% Create triangulation
\end_layout

\begin_layout Scrap
t = zeros(n*n,3);
\end_layout

\begin_layout Scrap
k = 1;
\end_layout

\begin_layout Scrap
idx = 1;
\end_layout

\begin_layout Scrap
for i = 0:n-1
\end_layout

\begin_layout Scrap
    for j = 0:n-i-1
\end_layout

\begin_layout Scrap
        if j > 0
\end_layout

\begin_layout Scrap
            t(k,:) = [idx, idx+n-i, idx+n-i+1];
\end_layout

\begin_layout Scrap
            k = k+1;
\end_layout

\begin_layout Scrap
        end
\end_layout

\begin_layout Scrap
        t(k,:) = [idx, idx+n-i+1, idx+1];
\end_layout

\begin_layout Scrap
        k = k+1;
\end_layout

\begin_layout Scrap
        idx = idx+1;
\end_layout

\begin_layout Scrap
    end % for j
\end_layout

\begin_layout Scrap
    idx = idx+1;
\end_layout

\begin_layout Scrap
end % for i
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Once a sub-mesh for the reference element has been created, the creation
 of the sub-mesh of the original triangulation, and the computation of the
 values at the sub-mesh nodes, is handled by the following code.
 Let 
\begin_inset Formula $g(\mathbf{x})$
\end_inset

 be the mesh-based function represented by the values of 
\family typewriter
vars
\family default
.
 Then 
\family typewriter
vals(i,1)
\family default
 contains 
\begin_inset Formula $g(\widetilde{\mathbf{x}}_{i})$
\end_inset

 where 
\begin_inset Formula $\widetilde{\mathbf{x}}_{i}$
\end_inset

 where 
\begin_inset Formula $\widetilde{\mathbf{x}}_{i}$
\end_inset

 is point 
\begin_inset Formula $i$
\end_inset

 in the sub-mesh of the original triangulation, provided 
\family typewriter
elt
\family default
 is a scalar element type.
 However, 
\family typewriter
vals(i,r)
\family default
 contains 
\begin_inset Formula $\mathcal{A}g(\widetilde{\mathbf{x}}_{i})$
\end_inset

 where 
\begin_inset Formula $\mathcal{A}$
\end_inset

 is the 
\begin_inset Formula $r$
\end_inset

th operator (of order 
\begin_inset Formula $\leq$
\end_inset


\family typewriter
order
\family default
) from the list of the operators for 
\family typewriter
elt
\family default
.
 In this way, derivative information can be also displayed; for vector element
 types, the different components can also be evaluated and displayed.
 For problems in elasticity, for example, components of the stress and strain
 tensors can be computed and displayed this way.
 
\end_layout

\begin_layout Standard
Note that in the submesh created, the submeshes for different triangles
 are separated; that is, variables in the submesh are not shared between
 different submeshes corresponding to different triangles.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
get_submesh_vals()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
get-submesh-vals.m 
\backslash

\end_layout

\begin_layout Scrap
<<get-submesh-vals.m>>=
\end_layout

\begin_layout Scrap
function [pv,tv,vals] = get_submesh_vals(p,t,fht,elt,vars,p_ref,t_ref,order)
\end_layout

\begin_layout Scrap
% function [pv,tv,vals] = get_submesh_vals(p,t,fht,elt,vars,p_ref,t_ref,order)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Return triangulation (pv,tv) and values (vals) for 
\end_layout

\begin_layout Scrap
% the given variable values (vars).
\end_layout

\begin_layout Scrap
% Each triangle in the master triangulation (p,t)
\end_layout

\begin_layout Scrap
% is subdivided according to the triangulation given for
\end_layout

\begin_layout Scrap
% the reference element (p_ref,t_ref).
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% The relationship between the elements of the master
\end_layout

\begin_layout Scrap
% triangulation (p,t) is given by fht and elt.
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Values and derivatives up to the given order are returned in vals.
\end_layout

\begin_layout Scrap
% Get the values for the basis functions on p_ref
\end_layout

\begin_layout Scrap
Aphihat = cell(size(p_ref,1),1);
\end_layout

\begin_layout Scrap
for i = 1:size(p_ref,1)
\end_layout

\begin_layout Scrap
    Aphihat{i} = elt.Aphihat(p_ref(i,:),order);
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
np = size(p,1);
\end_layout

\begin_layout Scrap
np_ref = size(p_ref,1);
\end_layout

\begin_layout Scrap
nt_ref = size(t_ref,1);
\end_layout

\begin_layout Scrap
pv = zeros(size(t,1)*np_ref,2);
\end_layout

\begin_layout Scrap
tv = zeros(size(t,1)*nt_ref,3);
\end_layout

\begin_layout Scrap
vals = zeros(size(t,1)*np_ref,size(Aphihat{1},2));
\end_layout

\begin_layout Scrap
for i = 1:size(t,1)
\end_layout

\begin_layout Scrap
    T = [p(t(i,2),:)'-p(t(i,1),:)', p(t(i,3),:)'-p(t(i,1),:)'];
\end_layout

\begin_layout Scrap
    b = p(t(i,1),:)';
\end_layout

\begin_layout Scrap
    pv((i-1)*np_ref+(1:np_ref),:) = p_ref*T'+ones(np_ref,1)*b';
\end_layout

\begin_layout Scrap
    tv((i-1)*nt_ref+(1:nt_ref),:) = t_ref+(i-1)*np_ref;
\end_layout

\begin_layout Scrap
    % get variable indexes
\end_layout

\begin_layout Scrap
    [vlist,slist] = get_var_triangle(t(i,:),fht,elt,np);
\end_layout

\begin_layout Scrap
    % basis function values
\end_layout

\begin_layout Scrap
    for j = 1:np_ref
\end_layout

\begin_layout Scrap
        Aphival = elt.trans_Aphihat(T,Aphihat{j},order);
\end_layout

\begin_layout Scrap
        vals((i-1)*np_ref+j,:) = (vars(vlist)'.*slist)*Aphival;
\end_layout

\begin_layout Scrap
    end % for j
\end_layout

\begin_layout Scrap
end % for i
\end_layout

\begin_layout Scrap
end % function
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
Geometric feature hash tables
\end_layout

\begin_layout Standard
Throughout this code we need hash tables keyed by geometric features.
 The initial code used the 
\family typewriter
containers.Map
\family default
 structure that is available in Matlab.
 There are a few problems with this.
 One is that these are only keyed by numbers or strings.
 Hence a 
\family typewriter
get_feature_ref()
\family default
 function was needed to obtain a unique integer for each geometric feature.
 The number of points (
\family typewriter
np
\family default
) parameter was needed for this to work.
 Overflow can occur when the numbers become too large, as is likely to happen
 for large three-dimensional triangulations.
 Instead the key should be a geometric feature.
 The other issue is that the 
\family typewriter
containers.Map
\family default
 may not be a stable part of Matlab.
 Instead, we should base the hash table on more basic Matlab features.
\end_layout

\begin_layout Standard
The hash table consists of a hash function 
\family typewriter
hash()
\family default
, an 
\family typewriter
index
\family default
 array, a 
\family typewriter
next
\family default
 array, and 
\family typewriter
key
\family default
 and 
\family typewriter
val
\family default
 cell arrays.
 If 
\family typewriter
h = hash(item)
\family default
, we set 
\family typewriter
idx = index(h)
\family default
.
 If 
\family typewriter
idx
\family default
 is zero, the item is not in the hash table.
 Otherwise we then check 
\family typewriter
key(idx)
\family default
 to see if this is equal to 
\family typewriter
item
\family default
; if so, then we return 
\family typewriter
val(idx)
\family default
.
 If 
\family typewriter
key(idx)
\family default
 is not 
\family typewriter
item
\family default
, we set 
\family typewriter
idx = next(idx)
\family default
.
 
\end_layout

\begin_layout Standard
!!! continue here !!!
\end_layout

\begin_layout Section
Utility routines
\end_layout

\begin_layout Standard
This is where we put routines that are generally useful.
\end_layout

\begin_layout Standard
The following is useful for anonymous functions where conditionals are needed.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
ifte.m 
\backslash

\end_layout

\begin_layout Scrap
<<ifte.m>>=
\end_layout

\begin_layout Scrap
function val = ifte(condition,affirmative,negative)
\end_layout

\begin_layout Scrap
% function val = ifte(condition,affirmative,negative)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns affirmative if condition is true (not zero)
\end_layout

\begin_layout Scrap
% and negative otherwise.
\end_layout

\begin_layout Scrap
% This is useful for anonymous functions.
\end_layout

\begin_layout Scrap
if condition
\end_layout

\begin_layout Scrap
    val = affirmative;
\end_layout

\begin_layout Scrap
else
\end_layout

\begin_layout Scrap
    val = negative;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
There is also a vectorized version of this where all the inputs are vectors
 of equal size.
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
iftev.m 
\backslash

\end_layout

\begin_layout Scrap
<<iftev.m>>=
\end_layout

\begin_layout Scrap
function val = iftev(condition,affirmative,negative)
\end_layout

\begin_layout Scrap
% function val = iftev(condition,affirmative,negative)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns affirmative(i) if condition(i) is true (not zero)
\end_layout

\begin_layout Scrap
% and negative(i) otherwise.
\end_layout

\begin_layout Scrap
% This is useful for anonymous functions.
\end_layout

\begin_layout Scrap
aff_idx = find(condition);
\end_layout

\begin_layout Scrap
neg_idx = find(~condition);
\end_layout

\begin_layout Scrap
val = zeros(size(condition));
\end_layout

\begin_layout Scrap
val(aff_idx) = affirmative(aff_idx);
\end_layout

\begin_layout Scrap
val(neg_idx) = negative(neg_idx);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
For example, the componentwise maximum of two vectors 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 can be computed by
\end_layout

\begin_layout LyX-Code
iftev(a<b,a,b)
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Installation"

\end_inset

Installation
\end_layout

\begin_layout Standard
This article is a simple test for using Noweb for mixing code and documentation.
 One difficulty with using Noweb is that there is no automatic way of generating
 all code files.
 However, we can use a 
\emph on
Makefile
\emph default
 to identify all actual code files and so that we can obtain all the code
 files by means of the following code fragment:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
Makefile
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<gen-all-files>>=
\end_layout

\begin_layout Scrap
notangle -t8 -RMakefile pde-code.nw > Makefile
\end_layout

\begin_layout Scrap
make all
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
-t8
\family default

\begin_inset Quotes erd
\end_inset

 option is to ensure that tabs are passed without conversion to spaces.
\end_layout

\begin_layout Standard
The 
\emph on
Makefile
\emph default
 will know which files to create and the procedure for creating them.
 The code chunk 
\emph on
filelist
\emph default
 contains the list of files to create (on separate lines but with 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 at the end of each line).
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Because of this we need a blank line following the 
\emph on
filelist
\emph default
 chunk.
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<Makefile>>=
\end_layout

\begin_layout Scrap
files1 = <<filelist>>
\end_layout

\begin_layout Scrap
files2 = pde-code.tex filelist
\end_layout

\begin_layout Scrap
files = $(files1) $(files2)
\end_layout

\begin_layout Scrap
source = pde-code.nw
\end_layout

\begin_layout Scrap
all: $(files)
\end_layout

\begin_layout Scrap
$(files): $(source)
\end_layout

\begin_layout Scrap
	notangle -R$@ $(source) > $@
\end_layout

\begin_layout Scrap
pde-code.tex: $(source)
\end_layout

\begin_layout Scrap
	noweave -delay -index $(source) > $@
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Unfortunately Noweb does not like underscores (_) while Matlab M-files cannot
 have dashes (-) in the file name.
 So in this file all the Matlab source files have underscores replaced by
 dashes.
 To fix that and be able to run in Matlab, a script has been included to
 help you do this:
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
filenamehack.bash
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
filenamehack.bash 
\backslash

\end_layout

\begin_layout Scrap
<<filenamehack.bash>>=
\end_layout

\begin_layout Scrap
#!/bin/bash
\end_layout

\begin_layout Scrap
cat filelist | tr -d '
\backslash

\backslash
' | tr -d 
\backslash

\backslash
r > templist 
\end_layout

\begin_layout Scrap
for f in `cat templist`
\end_layout

\begin_layout Scrap
do
\end_layout

\begin_layout Scrap
  if [[ "$f" =~ .*-.*
\backslash
.m ]] 
\end_layout

\begin_layout Scrap
  then mv "$f" `echo "$f" | sed -e s/-/_/g`
\end_layout

\begin_layout Scrap
  fi
\end_layout

\begin_layout Scrap
done 
\end_layout

\begin_layout Scrap
rm templist
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
To use this script in Unix (or Cygwin or \SpecialChar \ldots{}
), just use the command 
\begin_inset Quotes eld
\end_inset


\family typewriter
bash filenamehack.bash
\family default

\begin_inset Quotes erd
\end_inset

.
 In Cygwin, you may need to remove carriage returns from the script, just
 as for the 
\family typewriter
Makefile
\family default
 (see above).
\end_layout

\begin_layout Standard
There is an annoying 
\begin_inset Quotes eld
\end_inset

feature
\begin_inset Quotes erd
\end_inset

 in Cygwin where carriage returns are inserted into files (for compatibility
 with Microsoft Windows, I presume) which causes problems with make.
 So to remove them, use
\end_layout

\begin_layout LyX-Code
tr -d 
\backslash

\backslash
r < Makefile > temp; mv temp Makefile
\end_layout

\begin_layout Standard
In Unix systems we can use a shell script to automate the entire process.
 One such script is below (which uses the above scripts and 
\family typewriter
Makefile
\family default
):
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
lyx2code.bash 
\backslash

\end_layout

\begin_layout Scrap
<<lyx2code.bash>>=
\end_layout

\begin_layout Scrap
#!/bin/bash
\end_layout

\begin_layout Scrap
lyx -e literate $1.lyx
\end_layout

\begin_layout Scrap
notangle -t8 -RMakefile $1.nw > Makefile
\end_layout

\begin_layout Scrap
make all
\end_layout

\begin_layout Scrap
bash filenamehack.bash
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Test-code"

\end_inset

Test code
\end_layout

\begin_layout Subsection
Checking consistency of element values and derivatives
\end_layout

\begin_layout Standard
Checking the consistency between the element values and the derivatives
 the element structure provides is an important part of testing.
 The following code checks consistency of derivatives and values up to the
 2nd order derivatives for two-dimensional scalar elements.
 this uses centered difference approximations; 
\begin_inset Formula $\mathbf{d}$
\end_inset

 should be small.
 This code returns 
\begin_inset Formula 
\[
\frac{\phi_{i}(\mathbf{x}+\mathbf{d})-\phi_{i}(\mathbf{x}-\mathbf{d})-2\mathbf{d}^{T}\nabla\phi_{i}(\mathbf{x})}{\left\Vert \mathbf{d}\right\Vert }
\]

\end_inset

and
\begin_inset Formula 
\[
\frac{\nabla\phi_{i}(\mathbf{x}+\mathbf{d})-\nabla\phi_{i}(\mathbf{x}-\mathbf{d})-2\mbox{Hess}\,\phi_{i}(\mathbf{x})\,\mathbf{d}}{\left\Vert \mathbf{d}\right\Vert }
\]

\end_inset

where 
\begin_inset Formula $\mbox{Hess}\,\psi(\mathbf{x})$
\end_inset

 is the Hessian matrix of 2nd order partial derivatives: 
\begin_inset Formula $\left(\mbox{Hess}\,\psi(\mathbf{x})\right)_{pq}=\partial^{2}\psi/\partial x_{p}\partial x_{q}(\mathbf{x})$
\end_inset

.
 Provided 
\begin_inset Formula $\mathbf{d}$
\end_inset

 is small on the scale of 
\begin_inset Formula $\mathbf{x}$
\end_inset

, both ratios should be 
\begin_inset Formula $\mathcal{O}(\left\Vert \mathbf{d}\right\Vert ^{2})$
\end_inset

, and so be small compared to 
\begin_inset Formula $\left\Vert \mathbf{d}\right\Vert $
\end_inset

.
 If you are not sure how small is 
\begin_inset Quotes eld
\end_inset

small
\begin_inset Quotes erd
\end_inset

, reduce the size of 
\begin_inset Formula $\mathbf{d}$
\end_inset

 by a factor of two or ten, and repeat the computation.
 The returned values should be reduced by a factor of four or a hundred,
 respectively.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
check_derivs()
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
check-derivs.m 
\backslash

\end_layout

\begin_layout Scrap
<<check-derivs.m>>=
\end_layout

\begin_layout Scrap
function [err_dphi,err_ddphi] = check_derivs(Aphifunc,x,d)
\end_layout

\begin_layout Scrap
% function [err_dphi,err_ddphi] = check_derivs(Aphifunc,x,d)
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Returns errors in derivative test: err_dphi is the error vector for
\end_layout

\begin_layout Scrap
% (phi(x+d)-phi(x-d)-2*grad phi(x)'*d)/norm(d),
\end_layout

\begin_layout Scrap
% err_ddphi is the error vector for
\end_layout

\begin_layout Scrap
% (grad phi(x+d)-grad phi(x-d)-2*Hess phi(x)*d)/norm(d).
\end_layout

\begin_layout Scrap
%
\end_layout

\begin_layout Scrap
% Assumes scalar element: order of rows:
\end_layout

\begin_layout Scrap
% [phi(x), (d/dx1)phi(x), (d/dx2)phi(x), (d^2/dx1^2)phi(x), ...
\end_layout

\begin_layout Scrap
% (d^2/dx1.dx2)phi(x), (d^2/dx2^2)phi(x)]
\end_layout

\begin_layout Scrap
Aphivalx   = Aphifunc(x,2);
\end_layout

\begin_layout Scrap
Aphivalxpd = Aphifunc(x+d,2);
\end_layout

\begin_layout Scrap
Aphivalxmd = Aphifunc(x-d,2);
\end_layout

\begin_layout Scrap
phixpd = Aphivalxpd(:,1);
\end_layout

\begin_layout Scrap
phixmd = Aphivalxmd(:,1);
\end_layout

\begin_layout Scrap
dphix  = Aphivalx(:,2:3);
\end_layout

\begin_layout Scrap
err_dphi = (phixpd-phixmd-2*dphix*d)/norm(d);
\end_layout

\begin_layout Scrap
dphixpd = Aphivalxpd(:,2:3);
\end_layout

\begin_layout Scrap
dphixmd = Aphivalxmd(:,2:3);
\end_layout

\begin_layout Scrap
ddphix  = Aphivalx(:,4:6);
\end_layout

\begin_layout Scrap
err_ddphi = (dphixpd-dphixmd-2*(d(1)*ddphix(:,1:2)+d(2)*ddphix(:,2:3)))/norm(d);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Testing basic geometric operations
\end_layout

\begin_layout Standard
For testing basic geometric operations, we need a simple example of a mesh
 that includes interior nodes and non-congruent triangles.
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
test_geom.m
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
test-geom.m 
\backslash

\end_layout

\begin_layout Scrap
<<test-geom.m>>=
\end_layout

\begin_layout Scrap
p = [0 0; 1 0; 0 1; 1 2.5; 1.5 2.5; ...
\end_layout

\begin_layout Scrap
      1 1; 2 0; 2 1; 2.5 2.5; 3 3; 3 2; 3 1];
\end_layout

\begin_layout Scrap
t = [1 2 6; 8 11 9; 11 10 9; 7 8 12; 3 1 6; 6 4 3; ...
\end_layout

\begin_layout Scrap
      2 7 6; 8 11 12; 7 6 8; 4 5 6; 5 8 6; 9 5 8];
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
This triangulation is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Test-geometry-simple"

\end_inset

.
 Note that the vertices are labelled by their vertex number, and the triangles
 are labelled by their triangle number after a 
\begin_inset Quotes eld
\end_inset

T
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename test-geom.eps
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Test-geometry-simple"

\end_inset

Test geometry (simple)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The correct boundary information is given below (for 
\family typewriter
boundary2d()
\family default
):
\end_layout

\begin_layout Scrap
<<test-geom.m>>=
\end_layout

\begin_layout Scrap
[bedges,bnodes,t_index] = boundary2d(t)
\end_layout

\begin_layout Scrap
bedges_exact  = [1 2; 1 3; 2 7; 3 4; 4 5; 5 9; 7 12; 9 10; 10 11; 11 12]
\end_layout

\begin_layout Scrap
t_index_exact = [1  ; 5  ; 7  ; 6  ; 10 ; 12 ; 4   ; 3   ; 3    ; 8    ]
\end_layout

\begin_layout Scrap
bnodes_exact  = [1; 2; 3; 4; 5; 7; 9; 10; 11; 12] % only 6 & 8 are not
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
To see how this is used for creating the variables, we can use the piecewise
 quadratic Lagrange element.
 Recall that for this element type, there is a variable associated with
 each vertex and a variable associated with each edge.
\end_layout

\begin_layout Scrap
<<test-geom.m>>=
\end_layout

\begin_layout Scrap
quad2d = quad2d_elt()
\end_layout

\begin_layout Scrap
fht_quad2d = create_fht(p,t,quad2d)
\end_layout

\begin_layout Scrap
np = size(p,1)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Testing overall system
\end_layout

\begin_layout Section
To do
\end_layout

\begin_layout Standard
Here is a list of things that would be worth doing with this code.
\end_layout

\begin_layout Itemize
Properly and correctly implement a 
\begin_inset Formula $C^{1}$
\end_inset

 element, which could be Bell's triangle, Argyris element, or a composite
 element like the Hsieh--Clough--Tocher (HCT) element.
\end_layout

\begin_layout Itemize
Implement equations of linearized elasticity.
\end_layout

\begin_layout Itemize
Implement adaptive refinement.
 I have some ideas for doing that using hanging nodes and non-conforming
 meshes.
 The trick is to post-process the assembled matrices by sparse matrix--matrix
 multiplies involving matrices defining the relationship between the hanging
 nodes and the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 nodes.
\end_layout

\begin_layout Itemize
Implement discontinuous Galerkin methods.
 The elements are easy to create, but there would need to be new assembly
 routines which involve integrations over edges and faces.
\end_layout

\begin_layout Itemize
Implement three dimensional version.
 This is already started with three dimensional elements, but we need a
 three-dimensional assembly routines, and three-dimensional boundary functions.
\end_layout

\begin_layout Itemize
More testing code for testing items from bottom up.
\end_layout

\begin_layout Itemize
Optional inputs/outputs for 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\mathbf{b}$
\end_inset

 in assembly routines.
 They can be input as empty matrices (
\family typewriter
[]
\family default
) to indicate 
\begin_inset Quotes eld
\end_inset

do not create
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Replace the 
\family typewriter
container.Map
\family default
 structure and 
\family typewriter
get_feature_ref()
\family default
 with something more appropriate for the feature hash table (
\family typewriter
fht
\family default
).
 A problem with the current approach is that with three-dimensional meshes
 there is a very good chance of overflow, even with the use of 
\family typewriter
int64
\family default
 keys for the hash table.
\end_layout

\begin_layout Itemize
Modify to handle convection dominated problems (e.g., high Reynolds number
 Stokes' problems).
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Scrap
<<filelist>>=
\end_layout

\begin_layout Scrap
dummy.txt 
\end_layout

\begin_layout Scrap
<<dummy.txt>>=
\end_layout

\begin_layout Scrap
This must be the last code scrap.
\end_layout

\begin_layout Scrap
That's all folks!
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "numerical,analysis"
options "plain"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
